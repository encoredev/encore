-- service/types/types.go --
package types

type Req struct {
    Msg string
}
type Resp struct {
    Result string
}

-- service/service.go --
package service

import ("context"; "example.com/service/types")

//encore:api public path=/my/:name
func Foo(ctx context.Context, name string, req *types.Req) (*types.Resp, error) { return nil, nil }
-- want:clients/service/encore.gen.go --
package serviceclient

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	"errors"
	servicewrappers "example.com/service/servicewrappers"
	types "example.com/service/types"
)

// Client is the client interface for the service service.
//
//encore:service_client service=service
type Client interface {
	Foo(ctx context.Context, name string, req *types.Req) (*types.Resp, error)
}

// serviceClientImpl implements the Client interface.
type serviceClientImpl struct{}

// NewClient creates a new client for the service service.
func NewClient() Client {
	return &serviceClientImpl{}
}

//encore:endpoint name=Foo service=service
func (c *serviceClientImpl) Foo(ctx context.Context, name string, req *types.Req) (*types.Resp, error) {
	handler, ok := __api.LookupEndpoint("service", "Foo")
	if !ok {
		return (*types.Resp)(nil), errors.New("no endpoint registered for service.Foo")
	}
	callable, ok := handler.(__api.Callable[*servicewrappers.EncoreInternal_FooReq, servicewrappers.EncoreInternal_FooResp])
	if !ok {
		return (*types.Resp)(nil), errors.New("handler for service.Foo has unexpected type")
	}
	reqData := &servicewrappers.EncoreInternal_FooReq{
		P0:      name,
		Payload: req,
	}
	callCtx := __api.Singleton.NewCallContext(ctx)
	resp, err := callable.Call(callCtx, reqData)
	return resp, err
}
-- want:service/encore.gen.go --
// Code generated by encore. DO NOT EDIT.

package service

import (
	"context"
	types "example.com/service/types"
)

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, name string, p *types.Req) (*types.Resp, error)
}
-- want:service/encore_internal__api.go --
package service

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	__serde "encore.dev/appruntime/shared/serde"
	servicewrappers "example.com/service/servicewrappers"
	types "example.com/service/types"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*servicewrappers.EncoreInternal_FooReq, servicewrappers.EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *servicewrappers.EncoreInternal_FooReq) (servicewrappers.EncoreInternal_FooResp, error) {
		resp, err := Foo(ctx, reqData.P0, reqData.Payload)
		if err != nil {
			return (*types.Resp)(nil), err
		}
		return resp, nil
	},
	CloneReq: func(r *servicewrappers.EncoreInternal_FooReq) (*servicewrappers.EncoreInternal_FooReq, error) {
		var clone *servicewrappers.EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r servicewrappers.EncoreInternal_FooResp) (servicewrappers.EncoreInternal_FooResp, error) {
		var clone servicewrappers.EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp servicewrappers.EncoreInternal_FooResp, err error) {
		resp = new(types.Resp)
		dec := new(__etype.Unmarshaller)
		// Decode request body
		payload := dec.ReadBody(httpResp.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "result":
				dec.ParseJSON("Result", iter, &resp.Result)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

		if err := dec.Error; err != nil {
			return (*types.Resp)(nil), err
		}
		return resp, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *servicewrappers.EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(servicewrappers.EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}
		reqData.P0 = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "name", ps[0], true)
		params := new(types.Req)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode request body
			payload := dec.ReadBody(httpReq.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "msg":
					dec.ParseJSON("Msg", iter, &params.Msg)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *servicewrappers.EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		params := reqData.Payload
		if params == nil {
			// If the payload is nil, we need to return an empty request body.
			return httpHeader, queryString, err
		}

		// Encode request body
		stream.WriteObjectStart()
		stream.WriteObjectField("Msg")
		stream.WriteVal(params.Msg)
		stream.WriteObjectEnd()

		return httpHeader, queryString, err
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp servicewrappers.EncoreInternal_FooResp, status int) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("Result", resp.Result, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Set HTTP status code
		if status != 0 {
			w.WriteHeader(status)
		}

		// Write response body
		w.Write(respData)
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"POST"},
	Path:                "/my/:name",
	PathParamNames:      []string{"name"},
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/my/:0",
	ReqPath: func(reqData *servicewrappers.EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		params := __api.UnnamedParams{__etype.MarshalOne(__etype.MarshalString, reqData.P0)}
		return "/my" + "/" + url.PathEscape(params[0]), params, nil
	},
	ReqUserPayload: func(reqData *servicewrappers.EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service:           "service",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

var _ __api.Callable[*servicewrappers.EncoreInternal_FooReq, servicewrappers.EncoreInternal_FooResp] = EncoreInternal_api_APIDesc_Foo
-- want:service/servicewrappers/wrappers.go --
package servicewrappers

import types "example.com/service/types"

type EncoreInternal_FooReq struct {
	Payload *types.Req
	P0      string
}

type EncoreInternal_FooResp = *types.Resp
