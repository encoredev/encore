package userfacinggen

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"

	"encr.dev/pkg/namealloc"
	"encr.dev/pkg/option"
	"encr.dev/pkg/paths"
	"encr.dev/v2/app"
	"encr.dev/v2/app/apiframework"
	"encr.dev/v2/codegen"
	"encr.dev/v2/codegen/internal/genutil"
	"encr.dev/v2/internals/resourcepaths"
	"encr.dev/v2/internals/schema"
	"encr.dev/v2/parser/apis/api"
)

// Gen generates the encore.gen.go file containing user-facing
// generated code. If nothing needs to be generated it returns nil.
func Gen(gen *codegen.Generator, appDesc *app.Desc, svc *app.Service, withSvcStructImpl option.Option[*codegen.VarDecl]) []*codegen.File {
	if fw, ok := svc.Framework.Get(); ok {
		var files []*codegen.File
		if f, ok := genUserFacing(gen, fw, withSvcStructImpl).Get(); ok {
			files = append(files, f)
		}
		if f, ok := genClient(gen, svc.Name, fw, appDesc).Get(); ok {
			files = append(files, f)
		}

		return files
	}
	return nil
}

func genUserFacing(gen *codegen.Generator, svc *apiframework.ServiceDesc, withImpl option.Option[*codegen.VarDecl]) option.Option[*codegen.File] {
	f := gen.InjectFile(svc.RootPkg.ImportPath, svc.RootPkg.Name, svc.RootPkg.FSPath,
		"encore.gen.go", "encoregen")

	f.Jen.HeaderComment("Code generated by encore. DO NOT EDIT.")

	f.Jen.Comment("These functions are automatically generated and maintained by Encore")
	f.Jen.Comment("to simplify calling them from other services, as they were implemented as methods.")
	f.Jen.Comment("They are automatically updated by Encore whenever your API endpoints change.")
	f.Jen.Line()

	// count is the number of declarations we've generated in this file
	count := 0

	// Generate endpoint functions for endpoints defined on the service struct
	for _, ep := range svc.Endpoints {
		if ep.Recv.Empty() {
			continue
		}

		genEndpoint(gen.Util, f, ep, withImpl)
		f.Jen.Line()
		count++
	}

	// Generate the service interface (this is useful for mocking)
	if len(svc.Endpoints) > 0 {
		f.Jen.Comment("Interface defines the service's API surface area, primarily for mocking purposes.")
		f.Jen.Comment("")
		f.Jen.Comment("Raw endpoints are currently excluded from this interface, as Encore does not yet")
		f.Jen.Comment("support service-to-service API calls to raw endpoints.")
		f.Jen.Type().Id("Interface").InterfaceFunc(func(g *Group) {
			for _, ep := range svc.Endpoints {
				if !ep.Raw {
					getEndpointPrototype(gen.Util, g, ep, false, option.None[*codegen.VarDecl]())
					count++
					g.Line()
				}
			}
		})
		f.Jen.Line()
	}

	if count == 0 {
		// If we've generated no declarations, then this file can be deleted
		return option.None[*codegen.File]()
	} else {
		return option.Some(f)
	}
}

func genEndpoint(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, withImpl option.Option[*codegen.VarDecl]) {
	stmt, pathParamNames, alloc, ctxName, paramName := getEndpointPrototype(gu, f.Jen.Group, ep, true, withImpl)
	stmt.BlockFunc(func(g *Group) {
		if svcStruct, ok := withImpl.Get(); ok {
			if ep.Raw {
				g.Return(Nil(), Qual("errors", "New").Call(Lit("encore: calling raw endpoints is not yet supported")))
			} else {
				svcName := alloc("svc", false)
				g.List(Id(svcName), Err()).Op(":=").Id(svcStruct.Name()).Dot("Get").Call()
				g.If(Err().Op("!=").Nil()).Block(ReturnFunc(func(g *Group) {
					if ep.Raw {
						g.Nil()
					} else if ep.Response != nil {
						g.Add(gu.Zero(ep.Response))
					}
					g.Err()
				}))

				g.Return(Id("svc").Dot(ep.Name).CallFunc(func(g *Group) {
					g.Id(ctxName)
					for _, name := range pathParamNames {
						g.Id(name)
					}
					if paramName != "" {
						g.Id(paramName)
					}
				}))
			}
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if ep.Raw {
				g.Return(Nil(), Nil())
			} else if ep.Response != nil {
				g.Return(gu.Zero(ep.Response), Nil())
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}

func getEndpointPrototype(gu *genutil.Helper, grp *Group, ep *api.Endpoint, withFuncKeyWord bool, withImpl option.Option[*codegen.VarDecl]) (*Statement, []string, func(input string, pathParam bool) string, string, string) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			grp.Comment(line)
		}
	}

	var pathParamNames []string

	var names namealloc.Allocator
	alloc := func(input string, pathParam bool) string {
		name := names.Get(input)
		if pathParam {
			pathParamNames = append(pathParamNames, name)
		}
		return name
	}

	var (
		ctxName    = alloc("ctx", false)
		rawReqName string
		paramName  string
	)

	var stmt *Statement
	if withFuncKeyWord {
		stmt = grp.Func().Id(ep.Name)
	} else {
		stmt = grp.Id(ep.Name)
	}

	stmt = stmt.ParamsFunc(func(g *Group) {
		g.Id(ctxName).Qual("context", "Context")
		for _, p := range ep.Path.Params() {
			typ := gu.Builtin(p.Pos(), p.ValueType)
			g.Id(alloc(p.Value, true)).Add(typ)
		}
		if ep.Raw {
			rawReqName = alloc("req", false)
			g.Id(rawReqName).Op("*").Qual("net/http", "Request")
		} else if req := ep.Request; req != nil {
			paramName = alloc("p", false)
			g.Id(paramName).Add(gu.Type(req))
		}
	}).Do(func(s *Statement) {
		if withImpl.Present() {
			if ep.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := ep.Response; resp != nil {
				s.Params(gu.Type(resp), Error())
			} else {
				s.Params(Error())
			}
		} else {
			if ep.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := ep.Response; resp != nil {
				s.Params(gu.Type(resp), Error())
			} else {
				s.Error()
			}
		}
	})

	return stmt, pathParamNames, alloc, ctxName, paramName
}

func genClient(gen *codegen.Generator, svcName string, svc *apiframework.ServiceDesc, app *app.Desc) option.Option[*codegen.File] {
	pkgDir := app.MainModule.RootDir.Join("clients", svcName)
	pkgPath := paths.Pkg(app.MainModule.Path).JoinSlash("clients", paths.RelSlash(svcName))
	clientPkgName := svcName + "client"
	f := gen.InjectFile(pkgPath, clientPkgName, pkgDir, fmt.Sprintf("%s.go", svcName), svcName)

	f.Jen.HeaderComment("Code generated by encore. DO NOT EDIT.")

	// Add imports needed for client generation
	f.Jen.Line()

	// count is the number of declarations we've generated in this file
	count := 0

	// Generate request and response types for endpoints
	requestTypeGenerated := make(map[string]bool)
	responseTypeGenerated := make(map[string]bool)
	for _, ep := range svc.Endpoints {
		if !ep.Raw {
			// Always generate request type for consistency with endpointgen
			hasRequestType := genRequestType(gen.Util, f, ep)
			requestTypeGenerated[ep.Name] = hasRequestType
			if hasRequestType {
				count++
			}

			// Generate response type
			if ep.Response != nil {
				hasResponseType := genResponseType(gen.Util, f, ep)
				responseTypeGenerated[ep.Name] = hasResponseType
				if hasResponseType {
					count++
				}
			}
		}
	}

	if count > 0 {
		f.Jen.Line()
	}

	// Generate complete API descriptor variables
	descriptorGenerated := make(map[string]*codegen.VarDecl)
	for _, ep := range svc.Endpoints {
		if !ep.Raw {
			hasRequestType := requestTypeGenerated[ep.Name]
			hasResponseType := responseTypeGenerated[ep.Name]
			desc := genAPIDescriptor(gen.Util, f, ep, svcName, hasRequestType, hasResponseType)
			descriptorGenerated[ep.Name] = desc
			count++
		}
	}

	if count > 0 {
		f.Jen.Line()
	}

	// Generate endpoint functions for endpoints defined on the service struct
	for _, ep := range svc.Endpoints {
		if !ep.Raw {
			hasRequestType := requestTypeGenerated[ep.Name]
			hasResponseType := responseTypeGenerated[ep.Name]
			desc := descriptorGenerated[ep.Name]
			genClientEndpoint(gen.Util, f, ep, svcName, hasRequestType, hasResponseType, desc)
			f.Jen.Line()
			count++
		}
	}

	// Generate the service interface (this is useful for mocking)
	if len(svc.Endpoints) > 0 {
		f.Jen.Comment("Interface defines the service's API surface area, primarily for mocking purposes.")
		f.Jen.Comment("")
		f.Jen.Comment("Raw endpoints are currently excluded from this interface, as Encore does not yet")
		f.Jen.Comment("support service-to-service API calls to raw endpoints.")
		f.Jen.Type().Id("Interface").InterfaceFunc(func(g *Group) {
			for _, ep := range svc.Endpoints {
				if !ep.Raw {
					hasRequestType := requestTypeGenerated[ep.Name]
					hasResponseType := responseTypeGenerated[ep.Name]
					genClientInterfaceMethod(gen.Util, g, ep, hasRequestType, hasResponseType)
					count++
					g.Line()
				}
			}
		})
		f.Jen.Line()
	}

	if count == 0 {
		// If we've generated no declarations, then this file can be deleted
		return option.None[*codegen.File]()
	} else {
		return option.Some(f)
	}
}

func genRequestType(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint) bool {
	// Always generate request type for consistency with endpointgen
	typeName := "EncoreInternal_" + ep.Name + "Req"
	f.Jen.Type().Id(typeName).StructFunc(func(g *Group) {
		// Add request payload field if exists - use isolated types
		if ep.Request != nil {
			if structType := extractStructType(ep.Request); structType != nil {
				filteredStruct := genFilteredStruct(gu, *structType)
				if filteredStruct == nil {
					filteredStruct = Struct() // Empty struct
				}
				g.Id("Payload").Add(filteredStruct)
			} else {
				// Non-struct type, create isolated version
				g.Id("Payload").Interface()
			}
		}
		// Add path parameter fields (P0, P1, etc.) to match endpointgen pattern
		for i, param := range ep.Path.Params() {
			fieldName := fmt.Sprintf("P%d", i)
			g.Id(fieldName).Add(gu.Builtin(param.Pos(), param.ValueType))
		}
	})
	return true
}

func genResponseType(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint) bool {
	if ep.Response == nil {
		return false
	}

	// Generate response type following endpointgen pattern but with isolated types
	typeName := "EncoreInternal_" + ep.Name + "Resp"
	if structType := extractStructType(ep.Response); structType != nil {
		filteredStruct := genFilteredStruct(gu, *structType)
		if filteredStruct == nil {
			filteredStruct = Struct() // Empty struct
		}
		f.Jen.Type().Id(typeName).Add(filteredStruct)
	} else {
		// Non-struct type, create isolated version
		f.Jen.Type().Id(typeName).Interface()
	}
	return true
}

// Handler generation functions
func genDecodeReq(ep *api.Endpoint, reqTypeName string) *Statement {
	return Func().Params(
		Id("httpReq").Op("*").Qual("net/http", "Request"),
		Id("ps").Qual("encore.dev/appruntime/apisdk/api", "UnnamedParams"),
		Id("json").Qual("github.com/json-iterator/go", "API"),
	).Params(
		Id("reqData").Op("*").Id(reqTypeName),
		Id("pathParams").Qual("encore.dev/appruntime/apisdk/api", "UnnamedParams"),
		Err().Error(),
	).Block(
		Id("reqData").Op("=").New(Id(reqTypeName)),
		Return(Id("reqData"), Nil(), Nil()),
	)
}

func genCloneReq(reqTypeName string) *Statement {
	return Func().Params(Id("r").Op("*").Id(reqTypeName)).Params(Op("*").Id(reqTypeName), Error()).Block(
		Var().Id("clone").Op("*").Id(reqTypeName),
		List(Id("bytes"), Id("err")).Op(":=").Qual("github.com/json-iterator/go", "ConfigDefault").Dot("Marshal").Call(Id("r")),
		If(Err().Op("==").Nil()).Block(
			Err().Op("=").Qual("github.com/json-iterator/go", "ConfigDefault").Dot("Unmarshal").Call(Id("bytes"), Op("&").Id("clone")),
		),
		Return(Id("clone"), Err()),
	)
}

func genReqPath(ep *api.Endpoint, reqTypeName string) *Statement {
	return Func().Params(
		Id("reqData").Op("*").Id(reqTypeName),
	).Params(
		String(),
		Qual("encore.dev/appruntime/apisdk/api", "UnnamedParams"),
		Error(),
	).Block(
		Return(Lit(ep.Path.String()), Nil(), Nil()),
	)
}

func genReqUserPayload(ep *api.Endpoint, reqTypeName string) *Statement {
	return Func().Params(
		Id("reqData").Op("*").Id(reqTypeName),
	).Params(
		Any(),
	).BlockFunc(func(g *Group) {
		if ep.Request != nil {
			g.Return(Id("reqData").Dot("Payload"))
		} else {
			g.Return(Nil())
		}
	})
}

func genEncodeResp(respTypeName string, hasResponseType bool) *Statement {
	var respType *Statement
	if hasResponseType {
		respType = Id(respTypeName)
	} else {
		respType = Interface()
	}

	return Func().Params(
		Id("w").Qual("net/http", "ResponseWriter"),
		Id("json").Qual("github.com/json-iterator/go", "API"),
		Id("resp").Add(respType),
		Id("status").Int(),
	).Params(
		Err().Error(),
	).Block(
		Return(Nil()),
	)
}

func genCloneResp(respTypeName string, hasResponseType bool) *Statement {
	if !hasResponseType {
		return Nil()
	}
	return Func().Params(Id("r").Id(respTypeName)).Params(Id(respTypeName), Error()).Block(
		Var().Id("clone").Id(respTypeName),
		List(Id("bytes"), Id("err")).Op(":=").Qual("github.com/json-iterator/go", "ConfigDefault").Dot("Marshal").Call(Id("r")),
		If(Err().Op("==").Nil()).Block(
			Err().Op("=").Qual("github.com/json-iterator/go", "ConfigDefault").Dot("Unmarshal").Call(Id("bytes"), Op("&").Id("clone")),
		),
		Return(Id("clone"), Err()),
	)
}

func genEncodeExternalReq(reqTypeName string) *Statement {
	return Func().Params(
		Id("reqData").Op("*").Id(reqTypeName),
		Id("stream").Op("*").Qual("github.com/json-iterator/go", "Stream"),
	).Params(
		Id("httpHeader").Qual("net/http", "Header"),
		Id("queryString").Qual("net/url", "Values"),
		Err().Error(),
	).Block(
		Return(Nil(), Nil(), Nil()),
	)
}

// genPathParamNames yields a []string literal containing the names of the path parameters
func genPathParamNames(path *resourcepaths.Path) Code {
	if path.NumParams() == 0 {
		return Nil()
	}
	return Index().String().ValuesFunc(func(g *Group) {
		for _, s := range path.Params() {
			g.Lit(s.Value)
		}
	})
}

func genDecodeExternalResp(respTypeName string, hasResponseType bool) *Statement {
	var respType *Statement
	if hasResponseType {
		respType = Id(respTypeName)
	} else {
		respType = Interface()
	}

	return Func().Params(
		Id("httpResp").Op("*").Qual("net/http", "Response"),
		Id("json").Qual("github.com/json-iterator/go", "API"),
	).Params(
		Id("resp").Add(respType),
		Err().Error(),
	).BlockFunc(func(g *Group) {
		if hasResponseType {
			g.Var().Id("result").Id(respTypeName)
			g.Return(Id("result"), Nil())
		} else {
			g.Return(Id("resp"), Nil())
		}
	})
}

func genAPIDescriptor(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, svcName string, hasRequestType, hasResponseType bool) *codegen.VarDecl {
	reqTypeName := "EncoreInternal_" + ep.Name + "Req"
	respTypeName := "EncoreInternal_" + ep.Name + "Resp"

	var respType *Statement
	if hasResponseType {
		respType = Id(respTypeName)
	} else {
		respType = Interface()
	}

	desc := f.VarDecl("APIDesc", ep.Name)
	desc.Value(Op("&").Qual("encore.dev/appruntime/apisdk/api", "Desc").Types(
		Op("*").Id(reqTypeName),
		respType,
	).Values(Dict{
		Id("Service"):        Lit(svcName), // Use original service name for service discovery
		Id("SvcNum"):         Lit(0),       // Use 0 for external services (not in hosted services list)
		Id("Endpoint"):       Lit(ep.Name),
		Id("Methods"):        gu.GoToJen(ep.Decl.AST.Pos(), ep.HTTPMethods),
		Id("Raw"):            Lit(ep.Raw),
		Id("Fallback"):       Lit(ep.Path.HasFallback()),
		Id("Path"):           Lit(ep.Path.String()),
		Id("RawPath"):        Lit(ep.Path.String()), // Use same as Path for clients
		Id("DefLoc"):         Lit(uint32(0)),        // Not relevant for clients
		Id("PathParamNames"): genPathParamNames(ep.Path),
		Id("Tags"):           Nil(),                                              // Not relevant for clients
		Id("Access"):         Qual("encore.dev/appruntime/apisdk/api", "Public"), // Assume public for clients

		// Request handlers
		Id("DecodeReq"):      genDecodeReq(ep, reqTypeName),
		Id("CloneReq"):       genCloneReq(reqTypeName),
		Id("ReqPath"):        genReqPath(ep, reqTypeName),
		Id("ReqUserPayload"): genReqUserPayload(ep, reqTypeName),

		// Response handlers
		Id("EncodeResp"):         genEncodeResp(respTypeName, hasResponseType),
		Id("CloneResp"):          genCloneResp(respTypeName, hasResponseType),
		Id("EncodeExternalReq"):  genEncodeExternalReq(reqTypeName),
		Id("DecodeExternalResp"): genDecodeExternalResp(respTypeName, hasResponseType),

		// Handler (not used for clients)
		Id("AppHandler"): Nil(),
		Id("RawHandler"): Nil(),

		// Middleware (not used for clients)
		Id("ServiceMiddleware"):   Index().Op("*").Qual("encore.dev/appruntime/apisdk/api", "Middleware").Values(),
		Id("GlobalMiddlewareIDs"): Index().String().Values(),
	}))

	return desc
}

func genClientEndpoint(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, svcName string, hasRequestType, hasResponseType bool, desc *codegen.VarDecl) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			f.Jen.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code
	var pathParams []string

	// Add context parameter first
	ctxParam := alloc("ctx")
	params = append(params, Id(ctxParam).Qual("context", "Context"))

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		pathParams = append(pathParams, paramName)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists
	var reqParam string
	if req := ep.Request; req != nil {
		reqParam = alloc("req")
		if hasRequestType {
			requestTypeName := "EncoreInternal_" + ep.Name + "Req"
			params = append(params, Id(reqParam).Op("*").Id(requestTypeName))
		} else {
			params = append(params, Id(reqParam).Add(gu.Type(req)))
		}
	}

	// Determine return type and parameters
	var funcParams []Code
	if ep.Response != nil {
		if hasResponseType {
			responseTypeName := "EncoreInternal_" + ep.Name + "Resp"
			funcParams = []Code{Op("*").Id(responseTypeName), Error()}
		} else {
			funcParams = []Code{Add(gu.Type(ep.Response)), Error()}
		}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the function
	f.Jen.Func().Id(ep.Name).Params(params...).Params(funcParams...).BlockFunc(func(g *Group) {
		// Create call context
		g.Id("callCtx").Op(":=").Qual("encore.dev/appruntime/apisdk/api", "NewCallContext").Call(Id(ctxParam))

		// Build request object
		reqTypeName := "EncoreInternal_" + ep.Name + "Req"
		var reqVar string
		if ep.Request != nil {
			reqVar = reqParam
		} else {
			g.Id("req").Op(":=").Op("&").Id(reqTypeName).Values()
			reqVar = "req"
		}

		// Use the descriptor to make the call normally (fallback, shouldn't be reached)
		if ep.Response != nil {
			if hasResponseType {
				g.List(Id("_"), Err()).Op(":=").Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar))
				g.If(Err().Op("!=").Nil()).Block(Return(Nil(), Err()))
				// Convert response to the filtered response type
				g.Id("result").Op(":=").Op("&").Id("EncoreInternal_" + ep.Name + "Resp").Values()
				g.Comment("TODO: Map fields from response to result")
				g.Return(Id("result"), Nil())
			} else {
				g.Return(Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar)))
			}
		} else {
			g.List(Id("_"), Err()).Op(":=").Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar))
			g.Return(Err())
		}
	})
}

// genApiRequestType generates the request type for the API descriptor
func genApiRequestType(gu *genutil.Helper, ep *api.Endpoint, hasRequestType bool) Code {
	if hasRequestType {
		return Op("*").Id("EncoreInternal_" + ep.Name + "Req")
	}
	return Interface()
}

// genApiResponseType generates the response type for the API descriptor
func genApiResponseType(gu *genutil.Helper, ep *api.Endpoint, hasResponseType bool) Code {
	if hasResponseType {
		return Id("EncoreInternal_" + ep.Name + "Resp")
	}
	return Interface()
}

func genClientInterfaceMethod(gu *genutil.Helper, g *Group, ep *api.Endpoint, hasRequestType, hasResponseType bool) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			g.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code

	// Add context parameter first
	ctxParam := alloc("ctx")
	params = append(params, Id(ctxParam).Qual("context", "Context"))

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists
	if req := ep.Request; req != nil {
		reqParam := alloc("req")
		if hasRequestType {
			requestTypeName := "EncoreInternal_" + ep.Name + "Req"
			params = append(params, Id(reqParam).Op("*").Id(requestTypeName))
		} else {
			params = append(params, Id(reqParam).Add(gu.Type(req)))
		}
	}

	// Determine return type and parameters
	var funcParams []Code
	if ep.Response != nil {
		if hasResponseType {
			responseTypeName := "EncoreInternal_" + ep.Name + "Resp"
			funcParams = []Code{Op("*").Id(responseTypeName), Error()}
		} else {
			funcParams = []Code{Add(gu.Type(ep.Response)), Error()}
		}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the interface method signature
	g.Id(ep.Name).Params(params...).Params(funcParams...)
}

// extractStructType extracts the underlying StructType from a response type.
func extractStructType(responseType schema.Type) *schema.StructType {
	if responseType == nil {
		return nil
	}

	// Traverse through pointer and named types (max 10 levels to prevent infinite loops)
	currentType := responseType
	for depth := 0; depth < 10 && currentType != nil; depth++ {
		switch t := currentType.(type) {
		case schema.StructType:
			return &t
		case schema.NamedType:
			if decl := t.Decl(); decl != nil && decl.Type != nil {
				currentType = decl.Type
				continue
			}
			return nil
		case schema.PointerType:
			currentType = t.Elem
			continue
		default:
			return nil
		}
	}
	return nil
}

func genFilteredStruct(gu *genutil.Helper, structType schema.StructType) *Statement {
	var fields []Code

	for _, field := range structType.Fields {
		if !shouldIncludeField(field) {
			continue
		}

		var f *Statement
		if field.IsAnonymous() {
			f = gu.Type(field.Type)
		} else {
			f = Id(field.Name.MustGet()).Add(gu.Type(field.Type))
		}

		// Preserve only JSON tags
		if field.Tag.Len() > 0 {
			for _, tag := range field.Tag.Tags() {
				if tag.Key == "json" {
					f = f.Tag(map[string]string{"json": tag.Value()})
					break
				}
			}
		}

		if doc := strings.TrimSpace(field.Doc); doc != "" {
			f = f.Comment(doc)
		}

		fields = append(fields, f)
	}

	if len(fields) == 0 {
		return nil // No fields remain after filtering
	}

	return Struct(fields...)
}

func shouldIncludeField(field schema.StructField) bool {
	for _, tag := range field.Tag.Tags() {
		switch tag.Key {
		case "encore":
			if tag.Name == "httpstatus" {
				return false
			}
		case "query", "header", "cookie":
			return false
		}
	}
	return true
}
