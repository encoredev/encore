package userfacinggen

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"

	"encr.dev/pkg/namealloc"
	"encr.dev/pkg/option"
	"encr.dev/pkg/paths"
	"encr.dev/v2/app"
	"encr.dev/v2/app/apiframework"
	"encr.dev/v2/codegen"
	"encr.dev/v2/codegen/apigen/apigenutil"
	"encr.dev/v2/codegen/internal/genutil"
	"encr.dev/v2/internals/schema"
	"encr.dev/v2/parser/apis/api"
)

// Gen generates the encore.gen.go file containing user-facing
// generated code. If nothing needs to be generated it returns nil.
func Gen(gen *codegen.Generator, appDesc *app.Desc, svc *app.Service, withSvcStructImpl option.Option[*codegen.VarDecl], renderClientImpl bool) []*codegen.File {
	if fw, ok := svc.Framework.Get(); ok {
		var files []*codegen.File
		if f, ok := genUserFacing(gen, fw, withSvcStructImpl).Get(); ok {
			files = append(files, f)
		}
		if f, ok := genUserFacingClient(gen, svc.Name, fw, appDesc, svc, renderClientImpl).Get(); ok {
			files = append(files, f)
		}

		return files
	}
	return nil
}

func genUserFacing(gen *codegen.Generator, svc *apiframework.ServiceDesc, withImpl option.Option[*codegen.VarDecl]) option.Option[*codegen.File] {
	f := gen.InjectFile(svc.RootPkg.ImportPath, svc.RootPkg.Name, svc.RootPkg.FSPath,
		"encore.gen.go", "encoregen")

	f.Jen.HeaderComment("Code generated by encore. DO NOT EDIT.")

	f.Jen.Comment("These functions are automatically generated and maintained by Encore")
	f.Jen.Comment("to simplify calling them from other services, as they were implemented as methods.")
	f.Jen.Comment("They are automatically updated by Encore whenever your API endpoints change.")
	f.Jen.Line()

	// count is the number of declarations we've generated in this file
	count := 0

	// Generate endpoint functions for endpoints defined on the service struct
	for _, ep := range svc.Endpoints {
		if ep.Recv.Empty() {
			continue
		}

		genEndpoint(gen.Util, f, ep, withImpl)
		f.Jen.Line()
		count++
	}

	// Generate the service interface (this is useful for mocking)
	if len(svc.Endpoints) > 0 {
		f.Jen.Comment("Interface defines the service's API surface area, primarily for mocking purposes.")
		f.Jen.Comment("")
		f.Jen.Comment("Raw endpoints are currently excluded from this interface, as Encore does not yet")
		f.Jen.Comment("support service-to-service API calls to raw endpoints.")
		f.Jen.Type().Id("Interface").InterfaceFunc(func(g *Group) {
			for _, ep := range svc.Endpoints {
				if !ep.Raw {
					getEndpointPrototype(gen.Util, g, ep, false, option.None[*codegen.VarDecl]())
					count++
					g.Line()
				}
			}
		})
		f.Jen.Line()
	}

	if count == 0 {
		// If we've generated no declarations, then this file can be deleted
		return option.None[*codegen.File]()
	} else {
		return option.Some(f)
	}
}

func genEndpoint(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, withImpl option.Option[*codegen.VarDecl]) {
	stmt, pathParamNames, alloc, ctxName, paramName := getEndpointPrototype(gu, f.Jen.Group, ep, true, withImpl)
	stmt.BlockFunc(func(g *Group) {
		if svcStruct, ok := withImpl.Get(); ok {
			if ep.Raw {
				g.Return(Nil(), Qual("errors", "New").Call(Lit("encore: calling raw endpoints is not yet supported")))
			} else {
				svcName := alloc("svc", false)
				g.List(Id(svcName), Err()).Op(":=").Id(svcStruct.Name()).Dot("Get").Call()
				g.If(Err().Op("!=").Nil()).Block(ReturnFunc(func(g *Group) {
					if ep.Raw {
						g.Nil()
					} else if ep.Response != nil {
						g.Add(gu.Zero(ep.Response))
					}
					g.Err()
				}))

				g.Return(Id("svc").Dot(ep.Name).CallFunc(func(g *Group) {
					g.Id(ctxName)
					for _, name := range pathParamNames {
						g.Id(name)
					}
					if paramName != "" {
						g.Id(paramName)
					}
				}))
			}
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if ep.Raw {
				g.Return(Nil(), Nil())
			} else if ep.Response != nil {
				g.Return(gu.Zero(ep.Response), Nil())
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}

func getEndpointPrototype(gu *genutil.Helper, grp *Group, ep *api.Endpoint, withFuncKeyWord bool, withImpl option.Option[*codegen.VarDecl]) (*Statement, []string, func(input string, pathParam bool) string, string, string) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			grp.Comment(line)
		}
	}

	var pathParamNames []string

	var names namealloc.Allocator
	alloc := func(input string, pathParam bool) string {
		name := names.Get(input)
		if pathParam {
			pathParamNames = append(pathParamNames, name)
		}
		return name
	}

	var (
		ctxName    = alloc("ctx", false)
		rawReqName string
		paramName  string
	)

	var stmt *Statement
	if withFuncKeyWord {
		stmt = grp.Func().Id(ep.Name)
	} else {
		stmt = grp.Id(ep.Name)
	}

	stmt = stmt.ParamsFunc(func(g *Group) {
		g.Id(ctxName).Qual("context", "Context")
		for _, p := range ep.Path.Params() {
			typ := gu.Builtin(p.Pos(), p.ValueType)
			g.Id(alloc(p.Value, true)).Add(typ)
		}
		if ep.Raw {
			rawReqName = alloc("req", false)
			g.Id(rawReqName).Op("*").Qual("net/http", "Request")
		} else if req := ep.Request; req != nil {
			paramName = alloc("p", false)
			g.Id(paramName).Add(gu.Type(req))
		}
	}).Do(func(s *Statement) {
		if withImpl.Present() {
			if ep.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := ep.Response; resp != nil {
				s.Params(gu.Type(resp), Error())
			} else {
				s.Params(Error())
			}
		} else {
			if ep.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := ep.Response; resp != nil {
				s.Params(gu.Type(resp), Error())
			} else {
				s.Error()
			}
		}
	})

	return stmt, pathParamNames, alloc, ctxName, paramName
}

func genUserFacingClient(gen *codegen.Generator, svcName string, svc *apiframework.ServiceDesc, app *app.Desc, appSvc *app.Service, renderImpl bool) option.Option[*codegen.File] {
	// Create the client file in the clients/<service>/ directory with encore.gen.go filename
	pkgDir := app.MainModule.RootDir.Join("clients", svcName)
	pkgPath := paths.Pkg(app.MainModule.Path).JoinSlash("clients", paths.RelSlash(svcName))
	clientPkgName := svcName + "client"
	clientFileName := "encore.gen.go"
	f := gen.InjectFile(pkgPath, clientPkgName, pkgDir, clientFileName, fmt.Sprintf("%sclient_api", svcName))

	return genOriginalClient(gen, svcName, svc, app, appSvc, f, renderImpl)
}

func genOriginalClient(gen *codegen.Generator, svcName string, svc *apiframework.ServiceDesc, app *app.Desc, appSvc *app.Service, f *codegen.File, renderImpl bool) option.Option[*codegen.File] {
	f.Jen.HeaderComment("Code generated by encore. DO NOT EDIT.")

	// Add imports needed for client generation
	f.Jen.Line()

	// count is the number of declarations we've generated in this file
	count := 0

	// Generate request and response types for endpoints using apigenutil approach
	// Only generate the internal types when renderImpl is true
	requestDescs := make(map[string]*apigenutil.RequestDesc)
	responseDescs := make(map[string]*apigenutil.ResponseDesc)
	for _, ep := range svc.Endpoints {
		if !ep.Raw {
			// Use apigenutil RequestDesc and ResponseDesc like endpointgen does
			reqDesc := apigenutil.NewRequestDesc(gen.Util, ep)
			respDesc := apigenutil.NewResponseDesc(gen.Util, ep)

			if renderImpl {
				// Only generate internal type declarations when rendering implementation
				f.Add(reqDesc.TypeDecl())
				f.Add(respDesc.TypeDecl())
				count += 2 // Both request and response types
			}

			requestDescs[ep.Name] = reqDesc
			responseDescs[ep.Name] = respDesc
		}
	}

	if count > 0 {
		f.Jen.Line()
	}

	// Generate complete API descriptor variables only if renderImpl is true
	descriptorGenerated := make(map[string]*codegen.VarDecl)
	if renderImpl {
		for _, ep := range svc.Endpoints {
			if !ep.Raw {
				reqDesc := requestDescs[ep.Name]
				respDesc := responseDescs[ep.Name]

				descriptor := &apigenutil.APIDescriptor{
					ReqType:             reqDesc.Type(),
					RespType:            respDesc.Type(),
					DecodeReq:           reqDesc.DecodeRequest(),
					CloneReq:            reqDesc.Clone(),
					ReqPath:             reqDesc.ReqPath(),
					ReqUserPayload:      reqDesc.UserPayload(),
					AppHandler:          genClientAppHandler(gen.Util, ep, svcName, reqDesc, respDesc),
					RawHandler:          Nil(),
					EncodeResp:          respDesc.EncodeResponse(),
					CloneResp:           respDesc.Clone(),
					EncodeExternalReq:   reqDesc.EncodeExternalReq(),
					DecodeExternalResp:  respDesc.DecodeExternalResp(),
					ServiceMiddleware:   Nil(),
					GlobalMiddlewareIDs: Nil(),
				}

				desc := apigenutil.GenAPIDesc(gen, f, app, appSvc, ep, descriptor)
				descriptorGenerated[ep.Name] = desc
				count++
			}
		}
	}

	if count > 0 {
		f.Jen.Line()
	}

	// Generate endpoint functions for endpoints defined on the service struct
	for _, ep := range svc.Endpoints {
		if !ep.Raw {
			reqDesc := requestDescs[ep.Name]
			respDesc := responseDescs[ep.Name]
			var desc *codegen.VarDecl
			if renderImpl {
				desc = descriptorGenerated[ep.Name]
			}
			genClientEndpointWithDescs(gen.Util, f, ep, svcName, reqDesc, respDesc, desc, renderImpl)
			f.Jen.Line()
			count++
		}
	}

	// Generate the service interface (this is useful for mocking)
	if len(svc.Endpoints) > 0 {
		f.Jen.Comment("Interface defines the service's API surface area, primarily for mocking purposes.")
		f.Jen.Comment("")
		f.Jen.Comment("Raw endpoints are currently excluded from this interface, as Encore does not yet")
		f.Jen.Comment("support service-to-service API calls to raw endpoints.")
		f.Jen.Type().Id("Interface").InterfaceFunc(func(g *Group) {
			for _, ep := range svc.Endpoints {
				if !ep.Raw {
					reqDesc := requestDescs[ep.Name]
					respDesc := responseDescs[ep.Name]
					genClientInterfaceMethodWithDescs(gen.Util, g, ep, reqDesc, respDesc, renderImpl)
					count++
					g.Line()
				}
			}
		})
		f.Jen.Line()
	}

	if count == 0 {
		// If we've generated no declarations, then this file can be deleted
		return option.None[*codegen.File]()
	} else {
		return option.Some(f)
	}
}

func genRequestType(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint) bool {
	// Always generate request type for consistency with endpointgen
	typeName := "EncoreInternal_" + ep.Name + "Req"
	f.Jen.Type().Id(typeName).StructFunc(func(g *Group) {
		// Add request payload field if exists - use isolated types
		if ep.Request != nil {
			if structType := extractStructType(ep.Request); structType != nil {
				filteredStruct := genFilteredStruct(gu, *structType)
				if filteredStruct == nil {
					filteredStruct = Struct() // Empty struct
				}
				g.Id("Payload").Add(filteredStruct)
			} else {
				// Non-struct type, create isolated version
				g.Id("Payload").Interface()
			}
		}
		// Add path parameter fields (P0, P1, etc.) to match endpointgen pattern
		for i, param := range ep.Path.Params() {
			fieldName := fmt.Sprintf("P%d", i)
			g.Id(fieldName).Add(gu.Builtin(param.Pos(), param.ValueType))
		}
	})
	return true
}

func genClientEndpoint(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, svcName string, hasRequestType, hasResponseType bool, desc *codegen.VarDecl) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			f.Jen.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code
	var pathParams []string

	// Add context parameter first
	ctxParam := alloc("ctx")
	params = append(params, Id(ctxParam).Qual("context", "Context"))

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		pathParams = append(pathParams, paramName)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists
	var reqParam string
	if req := ep.Request; req != nil {
		reqParam = alloc("req")
		if hasRequestType {
			requestTypeName := "EncoreInternal_" + ep.Name + "Req"
			params = append(params, Id(reqParam).Op("*").Id(requestTypeName))
		} else {
			params = append(params, Id(reqParam).Add(gu.Type(req)))
		}
	}

	// Determine return type and parameters
	var funcParams []Code
	if ep.Response != nil {
		if hasResponseType {
			responseTypeName := "EncoreInternal_" + ep.Name + "Resp"
			funcParams = []Code{Op("*").Id(responseTypeName), Error()}
		} else {
			funcParams = []Code{Add(gu.Type(ep.Response)), Error()}
		}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the function
	f.Jen.Func().Id(ep.Name).Params(params...).Params(funcParams...).BlockFunc(func(g *Group) {
		// Create call context
		g.Id("callCtx").Op(":=").Qual("encore.dev/appruntime/apisdk/api", "NewCallContext").Call(Id(ctxParam))

		// Build request object
		reqTypeName := "EncoreInternal_" + ep.Name + "Req"
		var reqVar string
		if ep.Request != nil {
			reqVar = reqParam
		} else {
			g.Id("req").Op(":=").Op("&").Id(reqTypeName).Values()
			reqVar = "req"
		}

		// Use the descriptor to make the call normally (fallback, shouldn't be reached)
		if ep.Response != nil {
			if hasResponseType {
				g.List(Id("_"), Err()).Op(":=").Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar))
				g.If(Err().Op("!=").Nil()).Block(Return(Nil(), Err()))
				// Convert response to the filtered response type
				g.Id("result").Op(":=").Op("&").Id("EncoreInternal_" + ep.Name + "Resp").Values()
				g.Comment("TODO: Map fields from response to result")
				g.Return(Id("result"), Nil())
			} else {
				g.Return(Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar)))
			}
		} else {
			g.List(Id("_"), Err()).Op(":=").Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar))
			g.Return(Err())
		}
	})
}

func genClientInterfaceMethod(gu *genutil.Helper, g *Group, ep *api.Endpoint, hasRequestType, hasResponseType bool) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			g.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code

	// Add context parameter first
	ctxParam := alloc("ctx")
	params = append(params, Id(ctxParam).Qual("context", "Context"))

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists
	if req := ep.Request; req != nil {
		reqParam := alloc("req")
		if hasRequestType {
			requestTypeName := "EncoreInternal_" + ep.Name + "Req"
			params = append(params, Id(reqParam).Op("*").Id(requestTypeName))
		} else {
			params = append(params, Id(reqParam).Add(gu.Type(req)))
		}
	}

	// Determine return type and parameters
	var funcParams []Code
	if ep.Response != nil {
		if hasResponseType {
			responseTypeName := "EncoreInternal_" + ep.Name + "Resp"
			funcParams = []Code{Op("*").Id(responseTypeName), Error()}
		} else {
			funcParams = []Code{Add(gu.Type(ep.Response)), Error()}
		}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the interface method signature
	g.Id(ep.Name).Params(params...).Params(funcParams...)
}

// genClientAppHandler generates an AppHandler function for client-side calls
// that uses the LookupEndpoint method to find and call the target service endpoint
func genClientAppHandler(gu *genutil.Helper, ep *api.Endpoint, targetSvcName string, reqDesc *apigenutil.RequestDesc, respDesc *apigenutil.ResponseDesc) *Statement {
	if ep.Raw {
		return Nil()
	}

	return Func().Params(
		Id("ctx").Qual("context", "Context"),
		Id("reqData").Add(reqDesc.Type()),
	).Params(respDesc.Type(), Error()).BlockFunc(func(g *Group) {
		// Look up the target endpoint using the new lookup functionality
		g.Id("handlerOpt").Op(":=").Qual("encore.dev/appruntime/apisdk/api", "LookupEndpoint").Call(Lit(targetSvcName), Lit(ep.Name))
		
		// Check if the handler was found
		g.List(Id("handler"), Id("found")).Op(":=").Id("handlerOpt").Dot("Get").Call()
		g.If(Op("!").Id("found")).BlockFunc(func(g *Group) {
			g.Return(respDesc.Zero(), Qual("encore.dev/beta/errs", "B").Call().
				Dot("Code").Call(Qual("encore.dev/beta/errs", "NotFound")).
				Dot("Msgf").Call(Lit("endpoint %s.%s not found"), Lit(targetSvcName), Lit(ep.Name)).
				Dot("Err").Call())
		})
		
		// Get the AppHandler from the found handler's API descriptor
		g.Comment("Cast handler to *Desc to access AppHandler")
		g.Id("desc").Op(":=").Id("handler").Assert(Op("*").Qual("encore.dev/appruntime/apisdk/api", "Desc").Types(reqDesc.Type(), respDesc.Type()))
		
		// Check if AppHandler exists
		g.If(Id("desc").Dot("AppHandler").Op("==").Nil()).BlockFunc(func(g *Group) {
			g.Return(respDesc.Zero(), Qual("encore.dev/beta/errs", "B").Call().
				Dot("Code").Call(Qual("encore.dev/beta/errs", "Unimplemented")).
				Dot("Msgf").Call(Lit("endpoint %s.%s has no AppHandler"), Lit(targetSvcName), Lit(ep.Name)).
				Dot("Err").Call())
		})
		
		// Call the AppHandler
		if ep.Response != nil {
			g.Return(Id("desc").Dot("AppHandler").Call(Id("ctx"), Id("reqData")))
		} else {
			g.List(Id("_"), Id("err")).Op(":=").Id("desc").Dot("AppHandler").Call(Id("ctx"), Id("reqData"))
			g.Return(respDesc.Zero(), Id("err"))
		}
	})
}

func genResponseType(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint) bool {
	if ep.Response == nil {
		return false
	}

	// Generate response type following endpointgen pattern but with isolated types
	typeName := "EncoreInternal_" + ep.Name + "Resp"
	if structType := extractStructType(ep.Response); structType != nil {
		filteredStruct := genFilteredStruct(gu, *structType)
		if filteredStruct == nil {
			filteredStruct = Struct() // Empty struct
		}
		f.Jen.Type().Id(typeName).Add(filteredStruct)
	} else {
		// Non-struct type, create isolated version
		f.Jen.Type().Id(typeName).Interface()
	}
	return true
}

// extractStructType extracts the underlying StructType from a response type.
func extractStructType(responseType schema.Type) *schema.StructType {
	if responseType == nil {
		return nil
	}

	// Traverse through pointer and named types (max 10 levels to prevent infinite loops)
	currentType := responseType
	for depth := 0; depth < 10 && currentType != nil; depth++ {
		switch t := currentType.(type) {
		case schema.StructType:
			return &t
		case schema.NamedType:
			if decl := t.Decl(); decl != nil && decl.Type != nil {
				currentType = decl.Type
				continue
			}
			return nil
		case schema.PointerType:
			currentType = t.Elem
			continue
		default:
			return nil
		}
	}
	return nil
}

func genFilteredStruct(gu *genutil.Helper, structType schema.StructType) *Statement {
	var fields []Code

	for _, field := range structType.Fields {
		if !shouldIncludeField(field) {
			continue
		}

		var f *Statement
		if field.IsAnonymous() {
			f = gu.Type(field.Type)
		} else {
			f = Id(field.Name.MustGet()).Add(gu.Type(field.Type))
		}

		// Preserve only JSON tags
		if field.Tag.Len() > 0 {
			for _, tag := range field.Tag.Tags() {
				if tag.Key == "json" {
					f = f.Tag(map[string]string{"json": tag.Value()})
					break
				}
			}
		}

		if doc := strings.TrimSpace(field.Doc); doc != "" {
			f = f.Comment(doc)
		}

		fields = append(fields, f)
	}

	if len(fields) == 0 {
		return nil // No fields remain after filtering
	}

	return Struct(fields...)
}

func shouldIncludeField(field schema.StructField) bool {
	for _, tag := range field.Tag.Tags() {
		switch tag.Key {
		case "encore":
			if tag.Name == "httpstatus" {
				return false
			}
		case "query", "header", "cookie":
			return false
		}
	}
	return true
}

// New functions that use apigenutil RequestDesc and ResponseDesc

func genClientEndpointWithDescs(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, svcName string, reqDesc *apigenutil.RequestDesc, respDesc *apigenutil.ResponseDesc, desc *codegen.VarDecl, renderImpl bool) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			f.Jen.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code
	var pathParams []string

	// Add context parameter first
	ctxParam := alloc("ctx")
	params = append(params, Id(ctxParam).Qual("context", "Context"))

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		pathParams = append(pathParams, paramName)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists - always use original type for public API
	var reqParam string
	if req := ep.Request; req != nil {
		reqParam = alloc("req")
		params = append(params, Id(reqParam).Add(gu.Type(req)))
	}

	// Determine return type and parameters - always use original types for public API
	var funcParams []Code
	if ep.Response != nil {
		funcParams = []Code{Add(gu.Type(ep.Response)), Error()}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the function
	f.Jen.Func().Id(ep.Name).Params(params...).Params(funcParams...).BlockFunc(func(g *Group) {
		if renderImpl {
			// Create call context
			g.Id("callCtx").Op(":=").Qual("encore.dev/appruntime/apisdk/api", "NewCallContext").Call(Id(ctxParam))

			// Build request object using internal type
			var reqVar string
			if ep.Request != nil {
				// Convert from original type to internal type
				g.Id("internalReq").Op(":=").New(Id(reqDesc.TypeName()))
				g.Id("internalReq").Dot(reqDesc.ReqDataPayloadName()).Op("=").Id(reqParam)
				reqVar = "internalReq"
			} else {
				g.Id("req").Op(":=").New(Id(reqDesc.TypeName()))
				reqVar = "req"
			}

			// Use the descriptor to make the call
			if ep.Response != nil {
				g.Return(Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar)))
			} else {
				g.List(Id("_"), Err()).Op(":=").Add(desc.Qual()).Dot("Call").Call(Id("callCtx"), Id(reqVar))
				g.Return(Err())
			}
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if ep.Response != nil {
				g.Return(gu.Zero(ep.Response), Nil())
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}

func genClientInterfaceMethodWithDescs(gu *genutil.Helper, g *Group, ep *api.Endpoint, reqDesc *apigenutil.RequestDesc, respDesc *apigenutil.ResponseDesc, renderImpl bool) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			g.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code

	// Add context parameter first
	ctxParam := alloc("ctx")
	params = append(params, Id(ctxParam).Qual("context", "Context"))

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists - always use original type for interface
	if req := ep.Request; req != nil {
		reqParam := alloc("req")
		params = append(params, Id(reqParam).Add(gu.Type(req)))
	}

	// Determine return type and parameters - always use original types for interface
	var funcParams []Code
	if ep.Response != nil {
		funcParams = []Code{Add(gu.Type(ep.Response)), Error()}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the interface method signature
	g.Id(ep.Name).Params(params...).Params(funcParams...)
}

