package userfacinggen

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"

	"encr.dev/pkg/namealloc"
	"encr.dev/pkg/option"
	"encr.dev/pkg/paths"
	"encr.dev/v2/app"
	"encr.dev/v2/app/apiframework"
	"encr.dev/v2/codegen"
	"encr.dev/v2/codegen/internal/genutil"
	"encr.dev/v2/internals/resourcepaths"
	"encr.dev/v2/internals/schema"
	"encr.dev/v2/parser/apis/api"
)

// Gen generates the encore.gen.go file containing user-facing
// generated code. If nothing needs to be generated it returns nil.
func Gen(gen *codegen.Generator, appDesc *app.Desc, svc *app.Service, withSvcStructImpl option.Option[*codegen.VarDecl]) []*codegen.File {
	if fw, ok := svc.Framework.Get(); ok {
		var files []*codegen.File
		if f, ok := genUserFacing(gen, fw, withSvcStructImpl).Get(); ok {
			files = append(files, f)
		}
		if f, ok := genClient(gen, svc.Name, fw, appDesc).Get(); ok {
			files = append(files, f)
		}

		return files
	}
	return nil
}

func genUserFacing(gen *codegen.Generator, svc *apiframework.ServiceDesc, withImpl option.Option[*codegen.VarDecl]) option.Option[*codegen.File] {
	f := gen.InjectFile(svc.RootPkg.ImportPath, svc.RootPkg.Name, svc.RootPkg.FSPath,
		"encore.gen.go", "encoregen")

	f.Jen.HeaderComment("Code generated by encore. DO NOT EDIT.")

	f.Jen.Comment("These functions are automatically generated and maintained by Encore")
	f.Jen.Comment("to simplify calling them from other services, as they were implemented as methods.")
	f.Jen.Comment("They are automatically updated by Encore whenever your API endpoints change.")
	f.Jen.Line()

	// count is the number of declarations we've generated in this file
	count := 0

	// Generate endpoint functions for endpoints defined on the service struct
	for _, ep := range svc.Endpoints {
		if ep.Recv.Empty() {
			continue
		}

		genEndpoint(gen.Util, f, ep, withImpl)
		f.Jen.Line()
		count++
	}

	// Generate the service interface (this is useful for mocking)
	if len(svc.Endpoints) > 0 {
		f.Jen.Comment("Interface defines the service's API surface area, primarily for mocking purposes.")
		f.Jen.Comment("")
		f.Jen.Comment("Raw endpoints are currently excluded from this interface, as Encore does not yet")
		f.Jen.Comment("support service-to-service API calls to raw endpoints.")
		f.Jen.Type().Id("Interface").InterfaceFunc(func(g *Group) {
			for _, ep := range svc.Endpoints {
				if !ep.Raw {
					getEndpointPrototype(gen.Util, g, ep, false, option.None[*codegen.VarDecl]())
					count++
					g.Line()
				}
			}
		})
		f.Jen.Line()
	}

	if count == 0 {
		// If we've generated no declarations, then this file can be deleted
		return option.None[*codegen.File]()
	} else {
		return option.Some(f)
	}
}

func genEndpoint(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, withImpl option.Option[*codegen.VarDecl]) {
	stmt, pathParamNames, alloc, ctxName, paramName := getEndpointPrototype(gu, f.Jen.Group, ep, true, withImpl)
	stmt.BlockFunc(func(g *Group) {
		if svcStruct, ok := withImpl.Get(); ok {
			if ep.Raw {
				g.Return(Nil(), Qual("errors", "New").Call(Lit("encore: calling raw endpoints is not yet supported")))
			} else {
				svcName := alloc("svc", false)
				g.List(Id(svcName), Err()).Op(":=").Id(svcStruct.Name()).Dot("Get").Call()
				g.If(Err().Op("!=").Nil()).Block(ReturnFunc(func(g *Group) {
					if ep.Raw {
						g.Nil()
					} else if ep.Response != nil {
						g.Add(gu.Zero(ep.Response))
					}
					g.Err()
				}))

				g.Return(Id("svc").Dot(ep.Name).CallFunc(func(g *Group) {
					g.Id(ctxName)
					for _, name := range pathParamNames {
						g.Id(name)
					}
					if paramName != "" {
						g.Id(paramName)
					}
				}))
			}
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if ep.Raw {
				g.Return(Nil(), Nil())
			} else if ep.Response != nil {
				g.Return(gu.Zero(ep.Response), Nil())
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}

func getEndpointPrototype(gu *genutil.Helper, grp *Group, ep *api.Endpoint, withFuncKeyWord bool, withImpl option.Option[*codegen.VarDecl]) (*Statement, []string, func(input string, pathParam bool) string, string, string) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			grp.Comment(line)
		}
	}

	var pathParamNames []string

	var names namealloc.Allocator
	alloc := func(input string, pathParam bool) string {
		name := names.Get(input)
		if pathParam {
			pathParamNames = append(pathParamNames, name)
		}
		return name
	}

	var (
		ctxName    = alloc("ctx", false)
		rawReqName string
		paramName  string
	)

	var stmt *Statement
	if withFuncKeyWord {
		stmt = grp.Func().Id(ep.Name)
	} else {
		stmt = grp.Id(ep.Name)
	}

	stmt = stmt.ParamsFunc(func(g *Group) {
		g.Id(ctxName).Qual("context", "Context")
		for _, p := range ep.Path.Params() {
			typ := gu.Builtin(p.Pos(), p.ValueType)
			g.Id(alloc(p.Value, true)).Add(typ)
		}
		if ep.Raw {
			rawReqName = alloc("req", false)
			g.Id(rawReqName).Op("*").Qual("net/http", "Request")
		} else if req := ep.Request; req != nil {
			paramName = alloc("p", false)
			g.Id(paramName).Add(gu.Type(req))
		}
	}).Do(func(s *Statement) {
		if withImpl.Present() {
			if ep.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := ep.Response; resp != nil {
				s.Params(gu.Type(resp), Error())
			} else {
				s.Params(Error())
			}
		} else {
			if ep.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := ep.Response; resp != nil {
				s.Params(gu.Type(resp), Error())
			} else {
				s.Error()
			}
		}
	})

	return stmt, pathParamNames, alloc, ctxName, paramName
}

func genClient(gen *codegen.Generator, svcName string, svc *apiframework.ServiceDesc, app *app.Desc) option.Option[*codegen.File] {
	pkgDir := app.MainModule.RootDir.Join("clients", svcName)
	pkgPath := paths.Pkg(app.MainModule.Path).JoinSlash("clients", paths.RelSlash(svcName))
	clientPkgName := svcName + "client"
	f := gen.InjectFile(pkgPath, clientPkgName, pkgDir, fmt.Sprintf("%s.go", svcName), svcName)

	f.Jen.HeaderComment("Code generated by encore. DO NOT EDIT.")

	// Add imports needed for client generation
	f.Jen.Line()

	// count is the number of declarations we've generated in this file
	count := 0

	// Generate response types for endpoints
	responseTypeGenerated := make(map[string]bool)
	for _, ep := range svc.Endpoints {
		if !ep.Raw && ep.Response != nil {
			hasResponseType := genResponseType(gen.Util, f, ep)
			responseTypeGenerated[ep.Name] = hasResponseType
			if hasResponseType {
				count++
			}
		}
	}

	if count > 0 {
		f.Jen.Line()
	}

	// Generate endpoint functions for endpoints defined on the service struct
	for _, ep := range svc.Endpoints {
		if !ep.Raw {
			hasResponseType := responseTypeGenerated[ep.Name]
			genClientEndpoint(gen.Util, f, ep, hasResponseType)
			f.Jen.Line()
			count++
		}
	}

	// Generate the service interface (this is useful for mocking)
	if len(svc.Endpoints) > 0 {
		f.Jen.Comment("Interface defines the service's API surface area, primarily for mocking purposes.")
		f.Jen.Comment("")
		f.Jen.Comment("Raw endpoints are currently excluded from this interface, as Encore does not yet")
		f.Jen.Comment("support service-to-service API calls to raw endpoints.")
		f.Jen.Type().Id("Interface").InterfaceFunc(func(g *Group) {
			for _, ep := range svc.Endpoints {
				if !ep.Raw {
					hasResponseType := responseTypeGenerated[ep.Name]
					genClientInterfaceMethod(gen.Util, g, ep, hasResponseType)
					count++
					g.Line()
				}
			}
		})
		f.Jen.Line()
	}

	if count == 0 {
		// If we've generated no declarations, then this file can be deleted
		return option.None[*codegen.File]()
	} else {
		return option.Some(f)
	}
}

func genResponseType(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint) bool {
	if ep.Response == nil {
		return false
	}

	structType := extractStructType(ep.Response)
	if structType == nil {
		return false // Non-struct responses not supported
	}

	filteredStruct := genFilteredStruct(gu, *structType)
	if filteredStruct == nil {
		return false // No fields remain after filtering
	}

	typeName := ep.Name + "Response"
	f.Jen.Type().Id(typeName).Add(filteredStruct)
	return true
}

func genClientEndpoint(gu *genutil.Helper, f *codegen.File, ep *api.Endpoint, hasResponseType bool) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			f.Jen.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code
	var pathParams []string

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		pathParams = append(pathParams, paramName)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists
	var reqParam string
	if req := ep.Request; req != nil {
		reqParam = alloc("req")
		params = append(params, Id(reqParam).Add(gu.Type(req)))
	}

	// Determine return type and parameters
	var funcParams []Code
	if ep.Response != nil && hasResponseType {
		responseTypeName := ep.Name + "Response"
		funcParams = []Code{Op("*").Id(responseTypeName), Error()}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the function
	f.Jen.Func().Id(ep.Name).Params(params...).Params(funcParams...).BlockFunc(func(g *Group) {
		// Build the URL
		g.Id("url").Op(":=").Add(genUrlConstruction(ep, pathParams))

		// Determine HTTP method
		method := "GET"
		if len(ep.HTTPMethods) > 0 {
			method = ep.HTTPMethods[0]
		}

		// Make HTTP request based on method and whether we have a request body
		if method == "GET" || ep.Request == nil {
			// Simple GET request
			g.List(Id("resp"), Err()).Op(":=").Qual("net/http", "Get").Call(Id("url"))
		} else {
			// POST/PUT/etc. request with JSON body
			g.List(Id("reqBody"), Err()).Op(":=").Qual("encoding/json", "Marshal").Call(Id(reqParam))
			if hasResponseType {
				g.If(Err().Op("!=").Nil()).Block(Return(Nil(), Err()))
			} else {
				g.If(Err().Op("!=").Nil()).Block(Return(Err()))
			}
			g.Line()

			g.List(Id("resp"), Err()).Op(":=").Qual("net/http", "Post").Call(
				Id("url"),
				Lit("application/json"),
				Qual("bytes", "NewBuffer").Call(Id("reqBody")),
			)
		}

		// Error check
		if hasResponseType {
			g.If(Err().Op("!=").Nil()).Block(Return(Nil(), Err()))
		} else {
			g.If(Err().Op("!=").Nil()).Block(Return(Err()))
		}
		g.Defer().Id("resp").Dot("Body").Dot("Close").Call()

		// Handle response
		if ep.Response != nil && hasResponseType {
			g.Var().Id("response").Id(ep.Name + "Response")
			g.If(Err().Op(":=").Qual("encoding/json", "NewDecoder").Call(Id("resp").Dot("Body")).Dot("Decode").Call(Op("&").Id("response")).Op(";").Err().Op("!=").Nil()).Block(
				Return(Nil(), Err()),
			)
			g.Line()
			g.Return(Op("&").Id("response"), Nil())
		} else {
			// No response type to decode, just return error status
			g.Return(Nil())
		}
	})
}

func genUrlConstruction(ep *api.Endpoint, pathParams []string) Code {
	// Build the URL pattern and arguments for fmt.Sprintf
	urlPattern := "http://localhost:4000"
	var formatArgs []Code

	// Build path from segments
	pathPattern := ""
	paramIndex := 0
	for _, segment := range ep.Path.Segments {
		pathPattern += "/"
		switch segment.Type {
		case resourcepaths.Literal:
			pathPattern += segment.Value
		case resourcepaths.Param:
			pathPattern += "%s"
			if paramIndex < len(pathParams) {
				formatArgs = append(formatArgs, Id(pathParams[paramIndex]))
				paramIndex++
			}
		default:
			// For other types like Wildcard, Fallback - treat as parameter
			pathPattern += "%s"
			if paramIndex < len(pathParams) {
				formatArgs = append(formatArgs, Id(pathParams[paramIndex]))
				paramIndex++
			}
		}
	}

	urlPattern += pathPattern

	if len(formatArgs) == 0 {
		return Lit(urlPattern)
	}

	args := []Code{Lit(urlPattern)}
	args = append(args, formatArgs...)
	return Qual("fmt", "Sprintf").Call(args...)
}

func genClientInterfaceMethod(gu *genutil.Helper, g *Group, ep *api.Endpoint, hasResponseType bool) {
	// Add the doc comment
	if ep.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(ep.Doc), "\n") {
			g.Comment(line)
		}
	}

	var names namealloc.Allocator
	alloc := func(input string) string {
		return names.Get(input)
	}

	// Build parameter list
	var params []Code

	// Add path parameters
	for _, p := range ep.Path.Params() {
		typ := gu.Builtin(p.Pos(), p.ValueType)
		paramName := alloc(p.Value)
		params = append(params, Id(paramName).Add(typ))
	}

	// Add request parameter if exists
	if req := ep.Request; req != nil {
		reqParam := alloc("req")
		params = append(params, Id(reqParam).Add(gu.Type(req)))
	}

	// Determine return type and parameters
	var funcParams []Code
	if ep.Response != nil && hasResponseType {
		responseTypeName := ep.Name + "Response"
		funcParams = []Code{Op("*").Id(responseTypeName), Error()}
	} else {
		// Only return error if no response type
		funcParams = []Code{Error()}
	}

	// Generate the interface method signature
	g.Id(ep.Name).Params(params...).Params(funcParams...)
}

// extractStructType extracts the underlying StructType from a response type.
func extractStructType(responseType schema.Type) *schema.StructType {
	if responseType == nil {
		return nil
	}

	// Traverse through pointer and named types (max 10 levels to prevent infinite loops)
	currentType := responseType
	for depth := 0; depth < 10 && currentType != nil; depth++ {
		switch t := currentType.(type) {
		case schema.StructType:
			return &t
		case schema.NamedType:
			if decl := t.Decl(); decl != nil && decl.Type != nil {
				currentType = decl.Type
				continue
			}
			return nil
		case schema.PointerType:
			currentType = t.Elem
			continue
		default:
			return nil
		}
	}
	return nil
}

func genFilteredStruct(gu *genutil.Helper, structType schema.StructType) *Statement {
	var fields []Code

	for _, field := range structType.Fields {
		if !shouldIncludeField(field) {
			continue
		}

		var f *Statement
		if field.IsAnonymous() {
			f = gu.Type(field.Type)
		} else {
			f = Id(field.Name.MustGet()).Add(gu.Type(field.Type))
		}

		// Preserve only JSON tags
		if field.Tag.Len() > 0 {
			for _, tag := range field.Tag.Tags() {
				if tag.Key == "json" {
					f = f.Tag(map[string]string{"json": tag.Value()})
					break
				}
			}
		}

		if doc := strings.TrimSpace(field.Doc); doc != "" {
			f = f.Comment(doc)
		}

		fields = append(fields, f)
	}

	if len(fields) == 0 {
		return nil // No fields remain after filtering
	}

	return Struct(fields...)
}

func shouldIncludeField(field schema.StructField) bool {
	for _, tag := range field.Tag.Tags() {
		switch tag.Key {
		case "encore":
			if tag.Name == "httpstatus" {
				return false
			}
		case "query", "header", "cookie":
			return false
		}
	}
	return true
}
