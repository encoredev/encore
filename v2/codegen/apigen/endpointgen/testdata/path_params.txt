-- code.go --
package code

import "context"

type Params struct {
    String string
    Int int
}

//encore:api public path=/foo/:id/*baz
func Foo(ctx context.Context, id int, baz string, p *Params) error { return nil }

-- want:code.go --
package code

import _ "encore.dev/appruntime/app/appinit"
/*line :3:1*/import "context"

type Params struct {
    String string
    Int int
}

//encore:api public path=/foo/:id/*baz
func Foo(ctx context.Context, id int, baz string, p *Params) error { return nil }

-- want:encore_internal__api.go --
package code

import (
	"context"
	__api "encore.dev/appruntime/api"
	__etype "encore.dev/appruntime/etype"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

type EncoreInternal_FooReq struct {
	Payload *Params
	P0      int
	P1      string
}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx, reqData.P0, reqData.P1, reqData.Payload)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[1] = strings.TrimPrefix(ps[1], "/")

		reqData.P0 = __etype.UnmarshalOne(dec, __etype.UnmarshalInt, "id", ps[0], true)
		if value, err := url.PathUnescape(ps[1]); err == nil {
			ps[1] = value
		}
		reqData.P1 = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "baz", ps[1], true)
		params := new(Params)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode request body
			payload := dec.ReadBody(httpReq.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "string":
					dec.ParseJSON("String", iter, &params.String)
				case "int":
					dec.ParseJSON("Int", iter, &params.Int)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: int32(0),
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:       "Foo",
	Methods:        []string{"POST"},
	Path:           "/foo/:id/*baz",
	PathParamNames: []string{"id", "baz"},
	Raw:            false,
	RawHandler:     nil,
	RawPath:        "/foo/:0/*1",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		params := __api.UnnamedParams{__etype.MarshalOne(__etype.MarshalInt, reqData.P0), __etype.MarshalOne(__etype.MarshalString, reqData.P1)}
		return "/foo" + "/" + params[0] + "/" + params[1], params, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service: "code",
	SvcNum:  0,
}
