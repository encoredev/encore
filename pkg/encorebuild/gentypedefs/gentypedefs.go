package gentypedefs

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"fmt"
	"os"
	"slices"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/exp/maps"
)

type Config struct {
	// The version string to embed
	ReleaseVersion string

	// The path to the intermediate type definition file.
	TypeDefFile string

	// The path to the .d.ts output file.
	DtsOutputFile string

	// The path to the .cjs output file.
	CjsOutputFile string
}

func Generate(cfg Config) error {
	typeDefStr, exports, err := processTypeDef(cfg.TypeDefFile, false, DefaultTypeDefHeader)
	if err != nil {
		return fmt.Errorf("failed to parse type definitions: %v", err)
	}

	err = os.WriteFile(cfg.DtsOutputFile, []byte(typeDefStr), 0644)
	if err != nil {
		return fmt.Errorf("failed to write .d.ts file: %v", err)
	}

	{
		out, err := renderExportTemplate(cfg.ReleaseVersion, exports)
		if err != nil {
			return fmt.Errorf("failed to render .cjs file: %v", err)
		}
		err = os.WriteFile(cfg.CjsOutputFile, out, 0644)
		if err != nil {
			return fmt.Errorf("failed to write .cjs file: %v", err)
		}
	}

	return nil
}

//go:embed napi.cjs.tmpl
var napiCjsTemplate string

func renderExportTemplate(version string, exports []string) ([]byte, error) {
	tmpl, err := template.New("napi.cjs").Parse(napiCjsTemplate)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, map[string]any{
		"ModuleVersion": version,
		"Exports":       exports,
	})
	return buf.Bytes(), err
}

const TopLevelNamespace = "__TOP_LEVEL_MODULE__"
const DefaultTypeDefHeader = `/* tslint:disable */
/* eslint:disable */
// Automatically generated by gen_type_defs. Do not edit.
`

type TypeDefKind string

const (
	TypeDefKindConst     TypeDefKind = "const"
	TypeDefKindEnum      TypeDefKind = "enum"
	TypeDefKindInterface TypeDefKind = "interface"
	TypeDefKindFn        TypeDefKind = "fn"
	TypeDefKindStruct    TypeDefKind = "struct"
	TypeDefKindImpl      TypeDefKind = "impl"
)

type TypeDefLine struct {
	Kind         TypeDefKind `json:"kind"`
	Name         string      `json:"name"`
	OriginalName string      `json:"original_name,omitempty"`
	Def          string      `json:"def"`
	JSDoc        string      `json:"js_doc,omitempty"`
	JSMod        string      `json:"js_mod,omitempty"`
}

func prettyPrint(line *TypeDefLine, constEnum bool, indent int) string {
	s := line.JSDoc
	switch line.Kind {
	case TypeDefKindInterface:
		s += "export interface " + line.Name + " {"
		if strings.TrimSpace(line.Def) != "" {
			s += "\n" + line.Def + "\n"
		}
		s += "}"

	case TypeDefKindEnum:
		enumName := "enum"
		if constEnum {
			enumName = "const enum"
		}
		s += "export " + enumName + " " + line.Name + " {"
		if strings.TrimSpace(line.Def) != "" {
			s += "\n" + line.Def + "\n"
		}
		s += "}"

	case TypeDefKindStruct:
		s += "export class " + line.Name + " {"
		if strings.TrimSpace(line.Def) != "" {
			s += "\n" + line.Def + "\n"
		}
		s += "}"

		if line.OriginalName != "" && line.OriginalName != line.Name {
			s += "\nexport type " + line.OriginalName + " = " + line.Name
		}
	default:
		s += line.Def
	}

	return correctStringIndent(s, indent)
}

func processTypeDef(intermediateTypeFile string, constEnum bool, header string) (string, []string, error) {
	var exports []string
	content, err := os.ReadFile(intermediateTypeFile)
	if err != nil {
		return "", nil, err
	}
	defs, err := readIntermediateTypeFile(content)
	if err != nil {
		return "", nil, err
	}
	groupedDefs := preprocessTypeDef(defs)

	if header != "" {
		header += "\n"
	}
	dts := ""

	namespaces := maps.Keys(groupedDefs)
	sort.Strings(namespaces)

	for _, namespace := range namespaces {
		defs := groupedDefs[namespace]
		slices.SortFunc(defs, func(a, b *TypeDefLine) int {
			return strings.Compare(a.Name, b.Name)
		})
		if namespace == TopLevelNamespace {
			for _, def := range defs {
				dts += prettyPrint(def, constEnum, 0) + "\n\n"
				switch def.Kind {
				case TypeDefKindConst, TypeDefKindEnum, TypeDefKindFn, TypeDefKindStruct:
					exports = append(exports, def.Name)
					if def.OriginalName != "" && def.OriginalName != def.Name {
						exports = append(exports, def.OriginalName)
					}
				}
			}
		} else {
			exports = append(exports, namespace)
			dts += `export namespace ` + namespace + ` {
`
			for _, def := range defs {
				dts += prettyPrint(def, constEnum, 2) + "\n"
			}
			dts += `}
`
		}
	}

	if strings.Contains(dts, "ExternalObject<") {
		header += `
export class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`
	}

	sort.Strings(exports)
	return header + dts, exports, nil
}

func readIntermediateTypeFile(content []byte) ([]*TypeDefLine, error) {
	lines := strings.Split(string(content), "\n")
	var defs []*TypeDefLine
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		if !strings.HasPrefix(line, "{") {
			// crateName: { "def": "", ... }
			start := strings.IndexByte(line, ':') + 1
			line = line[start:]
		}
		var def TypeDefLine
		err := json.Unmarshal([]byte(line), &def)
		if err != nil {
			return nil, err
		}
		defs = append(defs, &def)
	}

	slices.SortFunc(defs, func(a, b *TypeDefLine) int {
		if a.Kind == TypeDefKindStruct {
			if b.Kind == TypeDefKindStruct {
				return strings.Compare(a.Name, b.Name)
			}
			return -1
		} else if b.Kind == TypeDefKindStruct {
			return 1
		} else {
			return strings.Compare(a.Name, b.Name)
		}
	})

	return defs, nil
}

func preprocessTypeDef(defs []*TypeDefLine) map[string][]*TypeDefLine {
	namespaceGrouped := make(map[string][]*TypeDefLine)
	classDefs := make(map[string]*TypeDefLine)

	for _, def := range defs {
		namespace := def.JSMod
		if namespace == "" {
			namespace = TopLevelNamespace
		}

		if def.Kind == TypeDefKindStruct {
			namespaceGrouped[namespace] = append(namespaceGrouped[namespace], def)
			classDefs[def.Name] = def
		} else if def.Kind == TypeDefKindImpl {
			if classDef, ok := classDefs[def.Name]; ok {
				if classDef.Def != "" {
					classDef.Def += "\n"
				}
				classDef.Def += def.Def
			}
		} else {
			namespaceGrouped[namespace] = append(namespaceGrouped[namespace], def)
		}
	}

	return namespaceGrouped
}

func correctStringIndent(src string, indent int) string {
	var result strings.Builder
	bracketDepth := 0
	for _, line := range strings.Split(src, "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			result.WriteString("\n")
			continue
		}

		isInMultilineComment := strings.HasPrefix(line, "*")
		isClosingBracket := strings.HasSuffix(line, "}")
		isOpeningBracket := strings.HasSuffix(line, "{")

		rightIndent := indent
		if isOpeningBracket && !isInMultilineComment {
			bracketDepth++
			rightIndent += (bracketDepth - 1) * 2
		} else {
			if isClosingBracket && bracketDepth > 0 && !isInMultilineComment {
				bracketDepth--
			}
			rightIndent += bracketDepth * 2
		}

		if isInMultilineComment {
			rightIndent++
		}

		result.WriteString(strings.Repeat(" ", rightIndent) + line + "\n")
	}

	res := result.String()
	if strings.HasSuffix(res, "\n") {
		res = res[:len(res)-1]
	}

	return res
}
