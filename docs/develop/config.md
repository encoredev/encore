---
title: Configuration
subtitle: When you want to change something, but not everywhere
---

As developers, we often find ourselves in a situation where we need to change something in our codebase, but we don't
want to change it everywhere the code is deployed. This is where configuration files come in, allowing us to define the
default behaviour of our applications, but then allow us to override these values for other environments.

Encore supports configuration files written in [CUE](https://cuelang.org/), which is a superset of JSON. It adds the following:
- C-style comments
- Quotes may be omitted from field names without special characters
- Commas at the end of fields are optional
- A comma after last element in list is allowed
- The outer curly braces on the file are optional
- [Expressions](https://cuelang.org/docs/tutorials/tour/expressions/) such as interpolation, comprehensions and conditionals
  are supported.

<Callout type="important">

For sensitive data use Encore's [secrets management](/docs/develop/secrets) functionality instead of configuration.

</Callout>

## Using Config

Inside your service, you can call <code className="hljs language-go">[config.Load[*SomeConfigType]()](https://pkg.go.dev/encore.dev/config#Load)</code>
to load the config. This must be done at the package level, and not inside a function.

```go
package mysvc

import (
    "encore.dev/config"
)

type SomeConfigType struct {
    ReadOnly config.Bool    // Put the system into read-only mode
    Example  config.String
}

var cfg *SomeConfigType = config.Load[*SomeConfigType]()
```

The type you pass as a type parameter to this function will be used to generate a `encore.gen.cue` file in your services
directory. This file will contain both the CUE definition for your configuration type, and some [meta data](#provided-meta-values) that Encore will
provide to your service at runtime. This allows you to change the final value of your configuration based on the environment the
application is running in.

Any files ending with `.cue` in your service directory or sub-directories will be loaded by Encore and given to CUE to
unify and compute a final configuration.

<Toggle label="Example CUE files">

```
-- mysvc/encore.gen.cue --
// Code generated by encore. DO NOT EDIT.
package mysvc

#Meta: {
	APIBaseURL: string
	Environment: {
		Name:  string
		Type:  "production" | "development" | "ephemeral" | "test"
		Cloud: "aws" | "azure" | "gcp" | "encore" | "local"
	}
}

#Config: {
	ReadOnly: bool   // Put the system into read-only mode
    Example:  string
}
#Config
-- mysvc/myconfig.cue --
// Set example to "hello world"
Example: "hello world"

// By default we're not in read only mode
ReadOnly: bool | *false

// But on the old production environment, we're in read only mode
if #Meta.Environment.Name == "old-prod" {
    ReadOnly: true
}
```

</Toggle>

<Callout type="info">

Loading configuration
is only supported in services and the loaded data can not be referenced from packages outside that service.

</Callout>

### CUE tags in Go Structs

You can use the `cue` tag in your Go to specify additional constraints on your configuration. For example:

```go
type FooBar {
    A int `cue:">100"`
    B int `cue:"A-50"` // If A is set, B can be infered by CUE
    C int `cue:"A+B"`  // Which then allows CUE to infer this too
}

var _ = config.Load[*FooBar]()
```

Will result in the following CUE type definition being generated:

```cue
#Config: {
    A: int & >100
    B: int & A-50 // If A is set, B can be infered by CUE
    C: int & A+B  // Which then allows CUE to infer this too
}
```

## Config Wrappers

Encore provides type wrappers for config in the form of `config.Value[T]` and `config.Values[T]` which expand into functions of type `T` and `[]T` respectively. These functions allow you to override the default value of your configuration in your CUE files inside unit tests, where only code run from that unit test will see the override.

In the future we plan to support real-time updating of configuration values on running applications, thus using
these wrappers in your configuration today will future proof your code and allow you to automatically take advantage of this feature when it is
available.

Any type supported in API requests and responses can be used as the type for a config wrapper. However for convenience, Encore ships with the following inbuilt aliases for the config wrappers:

 - `config.String`, `config.Bool`, `config.Int`, `config.Uint`,
 `config.Int8`, `config.Int16`, `config.Int32`, `config.In64`,
 `config.Uint8`, `config.Uint16`, `config.Uint32`, `config.Uint64`,
 `config.Float32`, `config.Float64`, `config.Bytes`, `config.Time`, `config.UUID`

<Toggle label="Example Application using Wrappers">

```go
-- svc/svc.go --
type mysvc

import (
    "encore.dev/config"
)

type Server struct {
    // The config wrappers do not have to be in the top level struct
    Enabled config.Bool
    Port    config.Int
}

type SvcConfig struct {
    GameServerPorts config.Values[Server]
}

var cfg = config.Load[*SvcConfig]()

func startServers() {
    for _, server := range cfg.GameServerPorts() {
        if server.Enabled() {
            go startServer(server.Port())
        }
    }
}

func startServer(port int) {
  // ...
}
-- svc/servers.cue --
GameServerPorts: [
    {
        Enabled: false
        Port:    12345
    },
    {
        Enabled: true
        Port:    1337
    },
]
```

</Toggle>


## Provided Meta Values

When your application is running, Encore will provide information about that environment to your CUE files, which you
can use to filter on. These fields can be found in the `encore.gen.cue` file which Encore will generate when you add a
call to load config. Encore provides the following meta values:

- **APIBaseURL**: The base URL of the Encore API, which can be used to make API calls to the application.
- **Environment**: A struct containing information about the environment the application is running in.<br />
  &nbsp;&nbsp; **Name**: The name of the environment<br />
  &nbsp;&nbsp; **Type**: One of `production`, `development`, `ephemeral` or `test`.<br />
  &nbsp;&nbsp; **Cloud**: The cloud the app is running on, which is one of `aws`, `azure`, `gcp`, `encore` or `local`.<br />

The following are useful conditionals you can use in your CUE files:

```cue
// An application running due to `encore run`
if #Meta.Environment.Type == "development" && #Meta.Environment.Cloud == "local" {}

// An application running in a development environment in the Cloud
if #Meta.Environment.Type == "development" && #Meta.Environment.Cloud != "local" {}

// An application running in a production enviroment
if #Meta.Environment.Type == "production" {}

// An application running in an enviroment that Encore has created
// for an open Pull Request on Github
if #Meta.Environment.Type == "ephemeral" {}

// Tests being run on the application either due to a call to
// `encore test` or Encore's CI system running tests
if #Meta.Environment.Type == "test" {}
```


## Useful CUE Patterns

If you're new the CUE, we'd recommend checking out the [CUE documentation](https://cuelang.org/docs/) and
[cuetorials](https://cuetorials.com/), however to get you started, here are some useful patterns you can use in your
CUE files.


<Accordion>

### Defaults

CUE supports the concept of a default value, which it will use if no other concrete value is provided. This can be useful
for when you normally want one value, but occasionally might want to provide an override in a certain scenario. A default
value is specified by prefixing it with a `*`.

```cue
// ReadOnlyMode is a boolean and if we don't provide a value, it
// will default to false.
ReadOnlyMode: bool | *false

// Because CUE allows circlular references, we can also write
// this as
ReadOnlyMode: ReadOnlyMode | *false

if #Meta.Environment.Name == "old-prod" {
    // On this enviroment, we want to set ReadOnlyMode to true
    ReadOnlyMode: true
}
```

</Accordion>

<Accordion>

### Validation within CUE

Any field prefixed with an `_` will not be exported to the concrete configuration once evaluated by CUE and can be used
to hold intermediate  values. Because CUE allows you to define the same field as many times as you want, as long as the
values unify, we can build complex validation logic.

```cue
import (
		"list" // import CUE's list package
)

// Set some port numbers defaulting just to 8080
// but in development including 8443
portNumbers: portNumbers | *[8080]
if #Meta.Environment.Type == "development" {
    portNumbers: [8080, 8443]
}

// Port numbers must be an array and all values
// are integers larger than 1024
portNumbers: [...int & > 1024]

// We only expect _portsAreValid to be true
_portsAreValid: true

// But it will be also be false here if portNumbers
// does not contain 8080, if that's the case CUE
// will report an error of conflicting values.
_portsAreValid: list.Contains(portNumbers, 8080)
```

</Accordion>

<Accordion>

### Switch Statements

If statements in CUE do not have else branches, which can make it difficult to write complex conditionals, we however
can use an array to emulate a switch statement, where the first value that matches the condition is returned. The following
example will set `SendEmailsFrom` to a single string.

```cue
SendEmailsFrom: [
	// These act as individual case statements
    if #Meta.Environment.Type == "production" { "noreply@example.com" },
    if #Meta.Environment.Name == "staging"    { "staging@example.com" },

    // This last value without a condition acts as the default case
    "dev-system@example.dev",
][0] // Return the first value which matches the condition
```

</Accordion>

<Accordion>

### Using Map Keys as Values

CUE allows us to extract map keys and use them as values to simply the config we need to write and minimise duplication.

```cue
// Define the type we want to use
#Server: {
	server: string
	port: int & > 1024
	enabled: bool | *true
}

// Specify that servers is a map of strings to #Server
// where they key we assign the the variable Name
servers: [Name=string]: #Server & {
	// Then we union the key with the value of server
	server: Name
}

servers: {
	"Foo": {
        port: 8080
    },
    "Bar": {
        port:    8081
        enabled: false
    },
}
```

This will result in the concrete configuration of:
```json
{
    "servers": {
        "Foo": {
            "server":  "Foo",
            "port":    8080,
            "enabled": true
        },
        "Bar": {
            "server":  "Bar",
            "port":    8081,
            "enabled": false
        }
    }
}
```

</Accordion>
