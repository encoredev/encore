---
seotitle: How to build a REST API
seodesc: Learn how to build and ship a REST API in just a few minutes, using TypeScript or Go with Encore. Get your backend running in the cloud in minutes!
title: Building a REST API
subtitle: Learn how to build a URL shortener with a REST API and PostgreSQL database
---

In this tutorial you will create a REST API for a URL Shortener service. In a few short minutes, you'll learn how to:

* Create REST APIs with Encore
* Use PostgreSQL databases
* Create and run tests

<LangTabGroup langs={["go", "ts"]}>
<LangTabPanel>

This is the end result:
<div className="not-prose mb-10">
   <Editor projectName="urlShortener" />
</div>

<Callout type="info">

To make it easier to follow along, we've laid out a trail of croissants to guide your way.
Whenever you see a ü•ê it means there's something for you to do.

</Callout>

## 1. Create a service and endpoint

If you haven't already, create a new application by running `encore app create` and select `Empty app` as the template.

Now let's create a new `url` service.

ü•ê In your application's root folder, create a new folder `url` and create a new file `url.go` that looks like this:

```go
// Service url takes URLs, generates random short IDs, and stores the URLs in a database.
package url

import (
	"context"
	"crypto/rand"
	"encoding/base64"
)

type URL struct {
	ID  string // short-form URL id
	URL string // complete URL, in long form
}

type ShortenParams struct {
	URL string // the URL to shorten
}

// Shorten shortens a URL.
//encore:api public method=POST path=/url
func Shorten(ctx context.Context, p *ShortenParams) (*URL, error) {
	id, err := generateID()
	if err != nil {
		return nil, err
	}
	return &URL{ID: id, URL: p.URL}, nil
}

// generateID generates a random short ID.
func generateID() (string, error) {
	var data [6]byte // 6 bytes of entropy
	if _, err := rand.Read(data[:]); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(data[:]), nil
}
```

This sets up the `POST /url` endpoint (see the `//encore:api` annotation on the `Shorten` function).

ü•ê Let‚Äôs see if it works! Start your app by running `encore run`.

You should see this:

```output
Your API is running at:     http://localhost:4000
Development Dashboard URL:  http://localhost:9400
4:19PM INF registered endpoint path=/url service=url endpoint=Shorten
```

ü•ê Next, call your endpoint:

Either do this from the Local Development Dashboard at [http://localhost:9400](http://localhost:9400) or from the terminal:

```shell
$ curl http://localhost:4000/url -d '{"URL": "https://encore.dev"}'
```

You should see this (and in the Local Development Dashboard you can see a trace):

```json
{
  "ID": "5cJpBVRp",
  "URL": "https://encore.dev"
}
```

It works! There‚Äôs just one problem...

Right now, we‚Äôre not actually storing the URL anywhere. That means we can generate shortened IDs but there‚Äôs no way to get back to the original URL! We need to store a mapping from the short ID to the complete URL.

## 2. Save URLs in a database
Fortunately, Encore makes it really easy to set up a PostgreSQL database to store our data. To do so, we first define a **database schema**, in the form of a migration file.

ü•ê Create a new folder named `migrations` inside the `url` folder. Then, inside the `migrations` folder, create an initial database migration file named `1_create_tables.up.sql`. The file name format is important (it must start with `1_` and end in `.up.sql`).

ü•ê Add the following contents to the file:

```sql
CREATE TABLE url (
	id TEXT PRIMARY KEY,
	original_url TEXT NOT NULL
);
```

ü•ê Next, go back to the `url/url.go` file and import the `encore.dev/storage/sqldb` package by modifying the import statement to become:

```go
import (
	"context"
	"crypto/rand"
	"encoding/base64"

	"encore.dev/storage/sqldb"
)
```

ü•ê Then let's define our database object by adding the following to `url/url.go`:

```go
// Define a database named 'url', using the database
// migrations in the "./migrations" folder.

var db = sqldb.NewDatabase("url", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})
```

ü•ê Now, to insert data into our database, let‚Äôs create a helper function `insert`:

```go
// insert inserts a URL into the database.
func insert(ctx context.Context, id, url string) error {
	_, err := db.Exec(ctx, `
        INSERT INTO url (id, original_url)
        VALUES ($1, $2)
    `, id, url)
	return err
}
```

ü•ê Lastly, we can update our `Shorten` function to insert into the database:

```go
func Shorten(ctx context.Context, p *ShortenParams) (*URL, error) {
	id, err := generateID()
	if err != nil {
		return nil, err
	} else if err := insert(ctx, id, p.URL); err != nil {
		return nil, err
	}
	return &URL{ID: id, URL: p.URL}, nil
}
```

<Callout type="info">

Before running your application, make sure you have [Docker](https://www.docker.com) installed and running. It's required to locally run Encore applications with databases.

</Callout>

ü•ê Next, start the application again with `encore run` and Encore automatically sets up your database.

(In case your application won't run, check the [databases troubleshooting guide](/docs/develop/databases#troubleshooting).)

ü•ê Now let's call the API again:

```shell
$ curl http://localhost:4000/url -d '{"URL": "https://encore.dev"}'
```

ü•ê Finally, let's verify that it was saved in the database by running  `encore db shell url` from the app root directory, or you can look at the trace in the local dev dashboard at [localhost:9400](http://localhost:9400).

```shell
$ encore db shell url
psql (13.1, server 11.12)
Type "help" for help.

url=# select * from url;
    id    |    original_url
----------+--------------------
 zr6RmZc4 | https://encore.dev
(1 row)
```

That was easy!

## 3. Add endpoint to retrieve URLs
To complete our URL shortener API, let‚Äôs add the endpoint to retrieve a URL given its short id.

ü•ê Add this endpoint to `url/url.go`:

```go
// Get retrieves the original URL for the id.
//encore:api public method=GET path=/url/:id
func Get(ctx context.Context, id string) (*URL, error) {
	u := &URL{ID: id}
	err := db.QueryRow(ctx, `
        SELECT original_url FROM url
        WHERE id = $1
    `, id).Scan(&u.URL)
	return u, err
}
```

Encore uses the `path=/url/:id` syntax to represent a path with a parameter. The `id` name corresponds to the parameter name in the function signature. In this case it is of type `string`, but you can also use other built-in types like `int` or `bool` if you want to restrict the values.

ü•ê Let‚Äôs make sure it works by calling it (remember to change the `id` below to the one you found in the last step):

```shell
$ curl http://localhost:4000/url/zr6RmZc4
```

You should now see this:

```json
{
  "ID": "zr6RmZc4",
  "URL": "https://encore.dev"
}
```

And there you have it! That's how you build REST APIs and use PostgreSQL databases in Encore.

## 4. Add a test

Before deployment, it is good practice to have tests to assure that
the service works properly. Such tests including database access
are easy to write.

We've prepared a test to check that the whole cycle of shortening
the URL, storing and then retrieving the original URL works. It looks like this:

```go
package url

import (
	"context"
	"testing"
)

// TestShortenAndRetrieve - test that the shortened URL is stored and retrieved from database.
func TestShortenAndRetrieve(t *testing.T) {
	testURL := "https://github.com/encoredev/encore"
	sp := ShortenParams{URL: testURL}
	resp, err := Shorten(context.Background(), &sp)
	if err != nil {
		t.Fatal(err)
	}
	wantURL := testURL
	if resp.URL != wantURL {
		t.Errorf("got %q, want %q", resp.URL, wantURL)
	}

	firstURL := resp
	gotURL, err := Get(context.Background(), firstURL.ID)
	if err != nil {
		t.Fatal(err)
	}
	if *gotURL != *firstURL {
		t.Errorf("got %v, want %v", *gotURL, *firstURL)
	}
}
```

ü•ê Save this in a separate file `url/url_test.go`.

ü•ê Now run `encore test ./...` to verify that it's working.

If you use the local development dashboard ([localhost:9400](http://localhost:9400)), you can even see traces for tests.

## 5. Deploy to the cloud

The final step before you deploy is to commit all changes to the project repo.

ü•ê Commit the new files to the project's git repo and trigger a deploy to Encore's free development cloud by running:

```shell
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore
```

Encore will now build and test your app, provision the needed infrastructure, and deploy your application to the cloud.

After triggering the deployment, you will see a URL where you can view its progress in Encore's [Cloud Dashboard](https://app.encore.dev). It will look something like: `https://app.encore.dev/$APP_ID/deploys/...`

From there you can also see metrics, traces, and connect your own AWS or GCP account to use for production deployment.

*Now you have a fully fledged backend running in the cloud, well done!*

### Celebrate with fireworks

Now that your app is running in the cloud, let's celebrate with some fireworks:

ü•ê In the Cloud Dashboard, open the Command Menu by pressing **Cmd + K** (Mac) or **Ctrl + K** (Windows/Linux).

_From here you can easily access all Cloud Dashboard features and for example jump straight to specific services in the Service Catalog or view Traces for specific endpoints._

ü•ê Type `fireworks` in the Command Menu and press enter. Sit back and enjoy the show!

![Fireworks](/assets/docs/fireworks.jpg)

## What's next

Now that you know how to build a backend with a database, you're ready to let your creativity flow and begin building your next great idea!

ü•ê A great next step is to [integrate with GitHub](/docs/how-to/github). Once you've linked with GitHub, Encore will automatically start building and running tests against your Pull Requests.

We're excited to hear what you're going to build with Encore, join the pioneering developer community on [Slack](/slack) and share your story.


</LangTabPanel>
<LangTabPanel>


This is the end result:
<div className="not-prose mb-10">
   <Editor projectName="urlShortenerTS" />
</div>

<Callout type="info">

To make it easier to follow along, we've laid out a trail of croissants to guide your way.
Whenever you see a ü•ê it means there's something for you to do.

</Callout>

## 1. Create a service and endpoint

Create a new application by running `encore app create --example=empty-ts url-shortener`.

Now let's create a new `url` service.

ü•ê In your application's root folder, create a new folder `url` and create a new file `url.ts` that looks like this:

```ts
import { api } from "encore.dev/api";
import { randomBytes } from "node:crypto";

interface URL {
  id: string; // short-form URL id
  url: string; // complete URL, in long form
}

interface ShortenParams {
  url: string; // the URL to shorten
}

// Shortens a URL.
export const shorten = api(
  { method: "POST", path: "/url", expose: true },
  async ({ url }: ShortenParams): Promise<URL> => {
    const id = randomBytes(6).toString("base64url");
    return { id, url };
  },
);
```

This sets up the `POST /url` endpoint.

ü•ê Let‚Äôs see if it works! Start your app by running `encore run`.

You should see this:

```output
Encore development server running!

Your API is running at:     http://127.0.0.1:4000
Development Dashboard URL:  http://localhost:9400/5g288
3:50PM INF registered API endpoint endpoint=shorten path=/url service=url
```

ü•ê Next, call your endpoint:

```shell
$ curl http://localhost:4000/url -d '{"url": "https://encore.dev"}'
```

You should see this:

```output
{
  "id": "5cJpBVRp",
  "url": "https://encore.dev"
}
```

It works! There‚Äôs just one problem...

Right now, we‚Äôre not actually storing the URL anywhere. That means we can generate shortened IDs but there‚Äôs no way to get back to the original URL! We need to store a mapping from the short ID to the complete URL.

## 2. Save URLs in a database
Fortunately, Encore makes it really easy to set up a PostgreSQL database to store our data. To do so, we first define a **database schema**, in the form of a migration file.

ü•ê Create a new folder named `migrations` inside the `url` folder. Then, inside the `migrations` folder, create an initial database migration file named `1_create_tables.up.sql`. The file name format is important (it must start with `1_` and end in `.up.sql`).

ü•ê Add the following contents to the file:

```sql
CREATE TABLE url (
	id TEXT PRIMARY KEY,
	original_url TEXT NOT NULL
);
```

ü•ê Next, go back to the `url/url.ts` file and import the `SQLDatabase` class from `encore.dev/storage/sqldb` module by modifying the imports to look like this:

```ts
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { randomBytes } from "node:crypto";
```

ü•ê Now, to insert data into our database, let‚Äôs create an instance of the `SQLDatabase` class:

```ts
const db = new SQLDatabase("url", { migrations: "./migrations" });
```

ü•ê Lastly, we can update our `shorten` function to insert into the database:

```ts
export const shorten = api(
  { method: "POST", path: "/url", expose: true },
  async ({ url }: ShortenParams): Promise<URL> => {
    const id = randomBytes(6).toString("base64url");
    await db.exec`
      INSERT INTO url (id, original_url)
      VALUES (${id}, ${url})
    `;
    return { id, url };
  },
);
```

<Callout type="info">

Before running your application, make sure you have [Docker](https://www.docker.com) installed and running. It's required to locally run Encore applications with databases.

</Callout>

ü•ê Next, start the application again with `encore run` and Encore automatically sets up your database.

(In case your application won't run, check the [databases troubleshooting guide](/docs/develop/databases#troubleshooting).)

ü•ê Now let's call the API again:

```shell
$ curl http://localhost:4000/url -d '{"url": "https://encore.dev"}'
```

ü•ê Finally, let's verify that it was saved in the database by running  `encore db shell url` from the app root directory:

```shell
$ encore db shell url
psql (13.1, server 11.12)
Type "help" for help.

url=# select * from url;
    id    |    original_url
----------+--------------------
 zr6RmZc4 | https://encore.dev
(1 row)
```

That was easy!

## 3. Add endpoint to retrieve URLs
To complete our URL shortener API, let‚Äôs add the endpoint to retrieve a URL given its short id.

ü•ê Add this endpoint to `url/url.ts`:

```ts
import { APIError } from "encore.dev/api";

export const get = api(
  { method: "GET", path: "/url/:id", expose: true },
  async ({ id }: { id: string }): Promise<URL> => {
    const row = await db.queryRow`
      SELECT original_url FROM url WHERE id = ${id}
    `;
    if (!row) throw APIError.notFound("url not found");
    return { id, url: row.original_url };
  },
);
```

Encore uses the `/url/:id` syntax to represent a path with a parameter. The `id` name corresponds to the parameter name in the function signature. In this case it is of type `string`, but you can also use other built-in types like `number` or `boolean` if you want to restrict the values.

ü•ê Let‚Äôs make sure it works by calling it (remember to change the `id` below to the one you found in the last step):

```shell
$ curl http://localhost:4000/url/zr6RmZc4
```

You should now see this:

```json
{
  "id": "zr6RmZc4",
  "url": "https://encore.dev"
}
```

And there you have it! That's how you build REST APIs and use PostgreSQL databases in Encore.

## 4. Deploy to the cloud

The final step before you deploy is to commit all changes to the project repo.

ü•ê Commit the new files to the project's git repo and trigger a deploy to Encore's free development cloud by running:

```shell
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore
```

Encore will now build and test your app, provision the needed infrastructure, and deploy your application to the cloud.

After triggering the deployment, you will see a URL where you can view its progress in Encore's [Cloud Dashboard](https://app.encore.dev). It will look something like: `https://app.encore.dev/$APP_ID/deploys/...`

From there you can also see metrics, traces, and connect your own AWS or GCP account to use for production deployment.

*Now you have a fully fledged backend running in the cloud, well done!*

### Celebrate with fireworks

Now that your app is running in the cloud, let's celebrate with some fireworks:

ü•ê In the Cloud Dashboard, open the Command Menu by pressing **Cmd + K** (Mac) or **Ctrl + K** (Windows/Linux).

_From here you can easily access all Cloud Dashboard features and for example jump straight to specific services in the Service Catalog or view Traces for specific endpoints._

ü•ê Type `fireworks` in the Command Menu and press enter. Sit back and enjoy the show!

![Fireworks](/assets/docs/fireworks.jpg)

## What's next

Now that you know how to build a backend with a database, you're ready to let your creativity flow and begin building your next great idea!

ü•ê A great next step is to [integrate with GitHub](/docs/how-to/github). Once you've linked with GitHub, Encore will automatically start building and running tests against your Pull Requests.

We're excited to hear what you're going to build with Encore, join the pioneering developer community on [Slack](/slack) and share your story.

</LangTabPanel>
</LangTabGroup>
