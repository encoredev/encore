---
title: Building a GraphQL API
subtitle: Learn how to build a GraphQL API using Go and Encore
seotitle: How to build a GraphQL API using Go and Encore
seodesc: Learn how to build a microservices backend in Go, powered by GraphQL and Encore.
---

Encore has great support for GraphQL with its type-safe approach to building APIs.

Encore's automatic tracing also makes it easy to find and fix
performance issues that often arise in GraphQL APIs (like the [N+1 problem](https://hygraph.com/blog/graphql-n-1-problem)).

<LangTabGroup langs={["go", "ts"]}>
<LangTabPanel>

The best way to use GraphQL with Encore is using [gqlgen](https://gqlgen.com/), which
has similar goals as Encore (type-safe APIs, minimal boilerplate, code generation, etc).

The final code will look like this:

<div className="not-prose my-10">
   <Editor projectName="graphql" />
</div>

## 1. Create your Encore application

This tutorial uses the [REST API](/docs/tutorials/rest-api) tutorial as a starting point.

You can either follow that tutorial first, or you can create a new Encore application
using the `url-shortener` template by running:

```shell
$ encore app create --example=url-shortener
```

## 2. Initialize gqlgen

To get started, initialize gqlgen by creating a `tools.go` file in the application root:

```go
-- tools.go --
//go:build tools

package tools

import (
    _ "github.com/99designs/gqlgen"
    _ "github.com/99designs/gqlgen/graphql/introspection"
)
```

Then run `go mod tidy` to download the dependencies.

Next, create a `gqlgen.yml` file in the application root containing:

```
-- gqlgen.yml --
# Where are all the schema files located? globs are supported eg  src/**/*.graphqls
schema:
  - graphql/*.graphqls

# Where should the generated server code go?
exec:
  filename: graphql/generated/generated.go
  package: generated

# Where should any generated models go?
model:
  filename: graphql/model/models_gen.go
  package: model

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: graphql
  package: graphql

# gqlgen will search for any type names in the schema in these go packages
# if they match it will use them, otherwise it will generate them.
autobind:
 - "encore.app/url"

# This section declares type mapping between the GraphQL and go type systems
#
# The first line in each type will be used as defaults for resolver arguments and
# modelgen, the others will be allowed when binding to fields. Configure them to
# your liking
models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Int:
    model:
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
```

## 3. Create Encore service

Now it's time to create our Encore service that will provide the GraphQL API.

First generate the gqlgen boilerplate:

```shell
$ mkdir -p graphql/generated graphql/model
$ echo "package model" > graphql/model/model.go
$ go run github.com/99designs/gqlgen generate
```

This will create a bunch of files in the `graphql` directory.

Next, create a `graphql/service.go` file containing:

```go
-- graphql/service.go --
// Service graphql exposes a GraphQL API.
package graphql

import (
    "net/http"

    "encore.app/graphql/generated"
    "encore.dev"
    "github.com/99designs/gqlgen/graphql/handler"
    "github.com/99designs/gqlgen/graphql/playground"
)

//go:generate go run github.com/99designs/gqlgen generate

//encore:service
type Service struct {
    srv        *handler.Server
    playground http.Handler
}

func initService() (*Service, error) {
    srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: &Resolver{}}))
    pg := playground.Handler("GraphQL Playground", "/graphql")
    return &Service{srv: srv, playground: pg}, nil
}

//encore:api public raw path=/graphql
func (s *Service) Query(w http.ResponseWriter, req *http.Request) {
    s.srv.ServeHTTP(w, req)
}

//encore:api public raw path=/graphql/playground
func (s *Service) Playground(w http.ResponseWriter, req *http.Request) {
	// Disable playground in production
	if encore.Meta().Environment.Type == encore.EnvProduction {
        http.Error(w, "Playground disabled", http.StatusNotFound)
		return
    }

    s.playground.ServeHTTP(w, req)
}
```

This creates an Encore service that exposes the `/graphql` and `/graphql/playground` endpoints.

It also adds a `//go:generate` directive that lets you re-run the gqlgen code generation
by running `go generate ./graphql`.

## 4. Add GraphQL schema

Now it's time to define the GraphQL schema. Create a `graphql/schema.graphqls` file containing:

```
-- graphql/url.graphqls --
type Query {
  urls: [URL!]!
  get(id: ID!): URL!
}

type Mutation {
  shorten(input: String!): URL!
}

type URL {
  id:  ID!     # shortened id
  url: String! # full URL
}
```

Then, re-run the code generation to generate the resolver stubs:

```shell
$ go generate ./graphql
```
The stubs will be written to `graphql/url.resolvers.go` and will contain a bunch of unimplemented resolver methods
that look something like this:

```go
// Shorten is the resolver for the shorten field.
func (r *mutationResolver) Shorten(ctx context.Context, input string) (*url.URL, error) {
	panic(fmt.Errorf("not implemented: Shorten - shorten"))
}
```

## 5. Implement resolvers

Now, modify the resolvers to call the `url` service. Since the GraphQL API uses the same types
(thanks to the `autobind` directive in `gqlgen.yml`) as the Encore API exposes, we can just call the
endpoints directly. Implement the resolvers in `graphql/url.resolvers.go` like this:

```go
-- graphql/url.resolvers.go --
// Shorten is the resolver for the shorten field.
func (r *mutationResolver) Shorten(ctx context.Context, input string) (*url.URL, error) {
	return url.Shorten(ctx, &url.ShortenParams{URL: input})
}

// Urls is the resolver for the urls field.
func (r *queryResolver) Urls(ctx context.Context) ([]*url.URL, error) {
	resp, err := url.List(ctx)
	if err != nil {
		return nil, err
	}
	return resp.URLs, nil
}

// Get is the resolver for the get field.
func (r *queryResolver) Get(ctx context.Context, id string) (*url.URL, error) {
	return url.Get(ctx, id)
}
```

As you can see, the resolvers are just thin wrappers around the Encore API endpoints themselves.

## 6. Trying it out

With that, the GraphQL API is done! Try it out by running `encore run` and opening up [the playground](http://localhost:4000/graphql/playground).

Enter the query:
```graphql
mutation {
    shorten(input: "https://encore.dev") {
        id
    }
}
```

You should get back an id like `MnTWA8Jo`. Pass the id you got (it will be something different) to a `get` query:

```graphql
query {
    get(id: "<your-id-here>") {
        url
    }
}
```

And you should get back `https://encore.dev`.

## 7. Deploy to the cloud

Push your changes and deploy your application to Encore's free development cloud by running:

```shell
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore
```

Encore will now build and test your app, provision the needed infrastructure, and deploy your application to the cloud.

After triggering the deployment, you will see a URL where you can view its progress in Encore's [Cloud Dashboard](https://app.encore.dev). It will look something like: `https://app.encore.dev/$APP_ID/deploys/...`

From there you can also see metrics, traces, link your app to a GitHub repo to get automatic deploys on new commits, and connect your own AWS or GCP account to use for production deployment.

### Celebrate with fireworks

Now that your app is running in the cloud, let's celebrate with some fireworks:

 In the Cloud Dashboard, open the Command Menu by pressing **Cmd + K** (Mac) or **Ctrl + K** (Windows/Linux).

_From here you can easily access all Cloud Dashboard features and for example jump straight to specific services in the Service Catalog or view Traces for specific endpoints._

 Type `fireworks` in the Command Menu and press enter. Sit back and enjoy the show!

![Fireworks](/assets/docs/fireworks.jpg)

## Conclusion

We've now built a GraphQL API gateway that forwards requests to the application's
underlying Encore services in a type-safe way with minimal boilerplate.

Note that the concepts discussed here are general and can be easily adapted to any GraphQL schema.

Whenever you make a change to the schema or configuration, re-run `go generate ./graphql` to
regenerate the GraphQL boilerplate. And for more information on how to use `gqlgen`,
see the [gqlgen documentation](https://gqlgen.com/).

</LangTabPanel>
<LangTabPanel>

In this tutorial we will build a GraphQL API using [Apollo](https://www.apollographql.com/docs/apollo-server/) and Encore.ts.

The final code will look like this:

<div className="not-prose my-10">
 <Editor projectName="graphqlTS" />
</div>

<Callout type="info">

To make it easier to follow along, we've laid out a trail of croissants to guide your way.
Whenever you see a  it means there's something for you to do.

</Callout>

## 1. Create your Encore application

 Create a new application by running `encore app create` and select `Empty app` as the template.

If this is the first time you're using Encore, you'll be asked if you wish to create a free account. This is optional, but is needed when you want Encore to manage functionality like secrets and handle cloud deployments (which we'll use later on in the tutorial).

## 2. GraphQL setup

First, we need to install the necessary dependencies:

 Update your `package.json` file to look like this:

```json
-- package.json --
{
  "name": "encore-graphql",
  "private": true,
  "version": "0.0.1",
  "license": "MPL-2.0",
  "type": "module",
  "scripts": {
    "generate": "graphql-codegen --config codegen.yml"
  },
  "devDependencies": {
    "@types/node": "^20.5.7",
    "typescript": "^5.2.2",
    "@graphql-codegen/cli": "2.16.5",
    "@graphql-codegen/typescript": "2.8.8",
    "@graphql-codegen/typescript-resolvers": "2.7.13"
  },
  "dependencies": {
    "@apollo/server": "^4.11.0",
    "encore.dev": "^1.35.3",
    "graphql": "^16.9.0",
    "graphql-tag": "^2.12.6"
  }
}
```

 Run `npm install` to install the dependencies.

 Next, create a `codegen.yml` file in the application root containing:

```
-- codegen.yml --
# This configuration file tells GraphQL Code Generator how to generate types based on our schema.
schema: './schema.graphql'
generates:
  # Specify where our generated types should live.
  ./graphql/__generated__/resolvers-types.ts:
    plugins:
      - 'typescript'
      - 'typescript-resolvers'
    config:
      useIndexSignature: true
```

## 3. Add GraphQL schema

Now it's time to define the GraphQL schema.

 Create a `schema.graphqls` file in the application root containing:

```
-- schema.graphqls --
type Query {
  books: [Book]
}

type Book {
  title: String!
  author: String!
}

type AddBookMutationResponse {
  code: String!
  success: Boolean!
  message: String!
  book: Book
}

type Mutation {
  addBook(title: String!, author: String!): AddBookMutationResponse
}
```

 Run the code generation script to generate the resolver types:

```shell
$ npm run generate
```
The types will be written to `graphql/__generated__/resolvers-types.ts` and will contain a bunch of types that we can use when implementing the resolvers.

## 4. Create a Book service

Let's create a simple book service that we can later query using GraphQL. It's a good idea to to make the GraphQL library query Encore endpoints because that will result in traces being created for each called endpoint. Having tracing makes it easy to find and fix performance issues that often arise in GraphQL APIs.

 In your application's root folder, create a directory named `book` containing a file named `encore.service.ts`.

```shell
$ mkdir book
$ touch book/encore.service.ts
```

 Add the following code to `book/encore.service.ts`:

```ts
-- book/encore.service.ts --
import { Service } from "encore.dev/service";

export default new Service("book");
```

This is how you define a service with Encore. Encore will now consider files in the `book` directory and all its subdirectories as part of the `book` service.

 Next, create a `book/book.ts` file containing:

```ts
import { api, APIError } from "encore.dev/api";
import { Book } from "../graphql/__generated__/resolvers-types";

const db: Book[] = [
  {
    title: "To Kill a Mockingbird",
    author: "Harper Lee",
  },
  {
    title: "1984",
    author: "George Orwell",
  },
  {
    title: "The Great Gatsby",
    author: "F. Scott Fitzgerald",
  },
  {
    title: "Moby-Dick",
    author: "Herman Melville",
  },
  {
    title: "Pride and Prejudice",
    author: "Jane Austen",
  },
];

export const list = api(
  { expose: true, method: "GET", path: "/books" },
  async (): Promise<{ books: Book[] }> => {
    return { books: db };
  },
);

// Omit the "__typename" field from the request
type AddRequest = Omit<Required<Book>, "__typename">;

export const add = api(
  { expose: true, method: "POST", path: "/book" },
  async (book: AddRequest): Promise<{ book: Book }> => {
    if (db.some((b) => b.title === book.title)) {
      throw APIError.alreadyExists(
        `Book "${book.title}" is already in database`,
      );
    }
    db.push(book);
    return { book };
  },
);
```

The `book` service contains two endpoint, one for listing all books and another to add a new book to the database. Our "database" is hardcoded just to limit the scope of this example. Take a look at the [Using SQL databases](docs/ts/primitives/databases) docs to learn how to set up and use a database.

We get the `Book` type from the generated resolver types. This will make it easier later when we create the resolver functions.

## 5. Create the GraphQL service

Now it's time to create our Encore service that will provide the GraphQL API.

 In the `graphql` directory, add a `encore.service.ts` file with the following content:

```ts
-- graphql/encore.service.ts --
import { Service } from "encore.dev/service";

export default new Service("graphql");
```

  Now, we need to create resolvers that call the `book` service. Since the GraphQL API uses the same types as the Encore API exposes (we import types form `resolvers-types.ts` in `book.ts`), our resolver can just be thin wrapper around out API endpoints.

 Create the directory `resolvers` in the `graphql` directory. In the resolvers directory we want to place three files: `index.ts`, `queries.ts` and `mutations.ts`:

```ts
-- resolvers/index.ts --
import { Resolvers } from "../__generated__/resolvers-types";
import Query from "./queries.js";
import Mutation from "./mutations.js";

const resolvers: Resolvers = { Query, Mutation };

export default resolvers;
-- resolvers/queries.ts --
import { book } from "~encore/clients";
import { QueryResolvers } from "../__generated__/resolvers-types";

// Use the generated `QueryResolvers` type to type check our queries!
const queries: QueryResolvers = {
  books: async () => {
    const { books } = await book.list();
    return books;
  },
};

export default queries;
-- resolvers/mutations.ts --
import { book } from "~encore/clients";
import { MutationResolvers } from "../__generated__/resolvers-types";
import { APIError } from "encore.dev/api";

// Use the generated `MutationResolvers` type to type check our mutations
const mutations: MutationResolvers = {
  addBook: async (_, { title, author }) => {
    try {
      const resp = await book.add({ title, author });
      return {
        book: resp.book,
        success: true,
        code: "ok",
        message: "New book added",
      };
    } catch (err) {
      const apiError = err as APIError;

      return {
        book: null,
        success: false,
        code: apiError.code,
        message: apiError.message,
      };
    }
  },
};

export default mutations;
```

Now we are ready can create the ApolloServer that makes use of our resolvers and to expose our GraphQL endpoint.

 Still in the `graphql` directory, create a `graphql.ts` file containing:

```ts
-- graphql/graphql.ts --
import { api } from "encore.dev/api";
import { ApolloServer, HeaderMap } from "@apollo/server";
import { readFileSync } from "node:fs";
import resolvers from "./resolvers";
import { json } from "node:stream/consumers";

const typeDefs = readFileSync("./schema.graphql", { encoding: "utf-8" });

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

await server.start();

export const graphqlAPI = api.raw(
  { expose: true, path: "/graphql", method: "*" },
  async (req, res) => {
    server.assertStarted("/graphql");

    const headers = new HeaderMap();
    for (const [key, value] of Object.entries(req.headers)) {
      if (value !== undefined) {
        headers.set(key, Array.isArray(value) ? value.join(", ") : value);
      }
    }

    // More on how to use executeHTTPGraphQLRequest: https://www.apollographql.com/docs/apollo-server/integrations/building-integrations/
    const httpGraphQLResponse = await server.executeHTTPGraphQLRequest({
      httpGraphQLRequest: {
        headers,
        method: req.method!.toUpperCase(),
        body: await json(req),
        search: new URLSearchParams(req.url ?? "").toString(),
      },
      context: async () => {
        return { req, res };
      },
    });

    for (const [key, value] of httpGraphQLResponse.headers) {
      res.setHeader(key, value);
    }
    res.statusCode = httpGraphQLResponse.status || 200;

    if (httpGraphQLResponse.body.kind === "complete") {
      res.end(httpGraphQLResponse.body.string);
      return;
    }

    for await (const chunk of httpGraphQLResponse.body.asyncIterator) {
      res.write(chunk);
    }
    res.end();
  },
);
```

This creates an [Raw API endpoint](https://encore.dev/docs/ts/primitives/raw-endpoints) available on `/graphql`. In the endpoint we use ApolloServer to handle the GraphQL queries and mutations. We then return the response to the client.

If we were to use another GraphQL library other than Apollo, the concept would still be the same:
1. Take client requests with a Raw endpoint.
2. Pass along the request and response objects to the GraphQL library of your choice.
3. Use the library to handle the GraphQL queries and mutations.
4. Return the GraphQL response from the Raw endpoint.

## 6. Trying it out

With that, the GraphQL API is done!

Try it out by running `encore run` and opening [https://studio.apollographql.com/sandbox](https://studio.apollographql.com/sandbox) in your browser. Set http://localhost:4000/graphql as your endpoint URL. You should now be able to read the schema and execute queries.

Enter the query:
```graphql
mutation AddBook {
  addBook(author: "J.R.R. Tolkien", title: "The Hobbit") {
    success
    message
    code
  }
}
```

Now try the GetBooks query:

```graphql
query GetBooks {
  books {
    author
    title
  }
}
```

And you should now see the "The Hobbit" in the list of books.

 Try opening the Local Development Dashboard at [http://localhost:9400](http://localhost:9400) and view the traces that were generated when calling your GraphQL API.

## 7. Deploy to the cloud

You can see how to configure and deploy your application in the [self-hosting documentation](/docs/how-to/self-host), or you can use Encore Cloud Platform to automate infrastructure provisioning. More on that below:

 Push your changes and deploy your application to Encore's free development cloud by running:

```shell
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore
```

Encore will now build and test your app, provision the needed infrastructure, and deploy your application to the cloud.

After triggering the deployment, you will see a URL where you can view its progress in Encore's [Cloud Dashboard](https://app.encore.dev). It will look something like: `https://app.encore.dev/$APP_ID/deploys/...`

From there you can also see metrics, traces, link your app to a GitHub repo to get automatic deploys on new commits, and connect your own AWS or GCP account to use for production deployment.

### Celebrate with fireworks

Now that your app is running in the cloud, let's celebrate with some fireworks:

 In the Cloud Dashboard, open the Command Menu by pressing **Cmd + K** (Mac) or **Ctrl + K** (Windows/Linux).

_From here you can easily access all Cloud Dashboard features and for example jump straight to specific services in the Service Catalog or view Traces for specific endpoints._

 Type `fireworks` in the Command Menu and press enter. Sit back and enjoy the show!

![Fireworks](/assets/docs/fireworks.jpg)

## Conclusion

We've now built a GraphQL API gateway that forwards requests to the application's underlying Encore services in a type-safe way with minimal boilerplate.

Note that the concepts discussed here are general and can be easily adapted to any GraphQL schema.

Whenever you make a change to the schema or configuration, re-run `npm run generate` to
regenerate the resolver types.

</LangTabPanel>
</LangTabGroup>
