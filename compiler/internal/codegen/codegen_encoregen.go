package codegen

import (
	"strings"

	. "github.com/dave/jennifer/jen"

	"encr.dev/parser/est"
	"encr.dev/parser/paths"
	"encr.dev/pkg/namealloc"
)

// EncoreGen generates the encore.gen.go file containing user-facing
// generated code. If nothing needs to be generated it returns nil.
func (b *Builder) EncoreGen(svc *est.Service, withImpl bool) *File {
	// If there are no API Groups, there's nothing to do.
	if len(svc.APIGroups) == 0 {
		return nil
	}

	f := NewFilePathName(svc.Root.ImportPath, svc.Root.Name)
	f.ImportNames(importNames)
	for _, pkg := range b.res.App.Packages {
		f.ImportName(pkg.ImportPath, pkg.Name)
	}

	f.HeaderComment("Code generated by encore. DO NOT EDIT.")

	f.Comment("These functions are automatically generated and maintained by Encore")
	f.Comment("to simplify calling them from other services, as they were implemented as methods.")
	f.Comment("They are automatically updated by Encore whenever your API endpoints change.")
	f.Line()

	for _, group := range svc.APIGroups {
		for _, rpc := range group.RPCs {
			b.encoreGenRPC(f, rpc, withImpl)
			f.Line()
		}
	}

	if withImpl {
		for _, group := range svc.APIGroups {
			name := b.res.Meta.Decls[group.Type.GetNamed().Id].Name
			f.Commentf("Initialization for the %s API Group", name)
			f.Var().Defs(
				Id("__encore_svc_init_once_"+name).Qual("encore.dev/runtime/runtimeutil", "Once"),
				// We currently only support a single receiver for all methods, so just pick the first one.
				Id("__encore_svc_"+name).Op("*").Add(b.schemaTypeToGoType(group.Type)),
			)
			f.Line()

			f.Func().Id("__encore_do_svc_init_" + name).Params().Error().Block(
				Return(
					Id("__encore_svc_init_once_" + name).Dot("Do").Call(
						Func().Params().Error().BlockFunc(func(g *Group) {
							if group.Init == nil {
								g.Id("__encore_svc_" + name).Op("=").New(b.schemaTypeToGoType(group.Type))
								g.Return(Nil())
							} else {
								fd := group.Init
								if fd.Type.Results.NumFields() == 2 {
									g.Var().Err().Error()
									g.List(Id("__encore_svc_"+name), Err()).Op("=").Id(fd.Name.Name).Call()
									g.If(Err().Op("!=").Nil()).Block(
										Qual("encore.dev/rlog", "Error").Call(
											Lit("service initialization failed"), Lit("err"), Err()),
										Return(Qual("encore.dev/beta/errs", "B").Call().
											Dot("Code").Call(Qual("encore.dev/beta/errs", "Internal")).
											Dot("Msg").Call(Lit("service initialization failed"))).
											Dot("Err").Call(),
									)
									g.Return(Nil())
								} else {
									g.Id("__encore_svc_" + name).Op("=").Id(fd.Name.Name).Call()
									g.Return(Nil())
								}
							}
						}),
					),
				),
			)
		}
	}

	return f
}

func (b *Builder) encoreGenRPC(f *File, rpc *est.RPC, withImpl bool) {
	if rpc.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(rpc.Doc), "\n") {
			f.Comment(line)
		}
	}

	var argNames []string

	f.Func().Id(rpc.Name).ParamsFunc(func(g *Group) {
		var names namealloc.Allocator
		alloc := func(input string) string {
			name := names.Get(input)
			argNames = append(argNames, name)
			return name
		}

		g.Id(alloc("ctx")).Qual("context", "Context")
		for _, seg := range rpc.Path.Segments {
			if seg.Type != paths.Literal {
				g.Id(alloc(seg.Value)).Add(b.builtinType(seg.ValueType))
			}
		}
		if rpc.Raw {
			g.Id(alloc("req")).Op("*").Qual("net/http", "Request")
		} else if req := rpc.Request; req != nil {
			g.Id(alloc("req")).Add(b.namedType(req))
		}
	}).Do(func(s *Statement) {
		if withImpl {
			if rpc.Raw {
				s.Params(Id("resp").Op("*").Qual("net/http", "Response"), Err().Error())
			} else if resp := rpc.Response; resp != nil {
				s.Params(Id("resp").Add(b.namedType(resp)), Err().Error())
			} else {
				s.Params(Err().Error())
			}
		} else {
			if rpc.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := rpc.Response; resp != nil {
				s.Params(b.namedType(resp), Error())
			} else {
				s.Error()
			}
		}
	}).BlockFunc(func(g *Group) {
		if withImpl {
			name := b.res.Meta.Decls[rpc.APIGroup.Type.GetNamed().Id].Name
			g.If(Err().Op("=").Id("__encore_do_svc_init_"+name).Call(), Err().Op("!=").Nil()).Block(
				Return(),
			)
			g.Return(Id("__encore_svc_" + name).Dot(rpc.Name).CallFunc(func(g *Group) {
				for _, name := range argNames {
					g.Id(name)
				}
			}))
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if rpc.Raw {
				// Do nothing
			} else if rpc.Response != nil {
				// (*T, error) or (T, error)
				if rpc.Response.IsPtr {
					g.Return(Nil(), Nil())
				} else {
					g.Return(b.namedType(rpc.Response).Values(), Nil())
				}
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}
