package codegen

import (
	"strings"

	. "github.com/dave/jennifer/jen"

	"encr.dev/parser/est"
	"encr.dev/parser/paths"
	"encr.dev/pkg/namealloc"
)

// UserFacing generates the encore.gen.go file containing user-facing
// generated code. If nothing needs to be generated it returns nil.
func (b *Builder) UserFacing(svc *est.Service, withImpl bool) *File {
	// If there are is no service struct, there's nothing to do.
	if svc.Struct == nil {
		return nil
	}

	f := NewFilePathName(svc.Root.ImportPath, svc.Root.Name)
	f.ImportNames(importNames)
	for _, pkg := range b.res.App.Packages {
		f.ImportName(pkg.ImportPath, pkg.Name)
	}

	f.HeaderComment("Code generated by encore. DO NOT EDIT.")

	f.Comment("These functions are automatically generated and maintained by Encore")
	f.Comment("to simplify calling them from other services, as they were implemented as methods.")
	f.Comment("They are automatically updated by Encore whenever your API endpoints change.")
	f.Line()

	for _, rpc := range svc.Struct.RPCs {
		b.encoreGenRPC(f, svc.Struct, rpc, withImpl)
		f.Line()
	}

	return f
}

func (b *Builder) encoreGenRPC(f *File, ss *est.ServiceStruct, rpc *est.RPC, withImpl bool) {
	if rpc.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(rpc.Doc), "\n") {
			f.Comment(line)
		}
	}

	var pathParamNames []string

	var names namealloc.Allocator
	alloc := func(input string, pathParam bool) string {
		name := names.Get(input)
		if pathParam {
			pathParamNames = append(pathParamNames, name)
		}
		return name
	}

	var (
		ctxName    = alloc("ctx", false)
		rawReqName string
		paramName  string
	)

	f.Func().Id(rpc.Name).ParamsFunc(func(g *Group) {
		g.Id(ctxName).Qual("context", "Context")
		for _, seg := range rpc.Path.Segments {
			if seg.Type != paths.Literal {
				typ := b.builtinType(seg.ValueType)
				// Wrap wildcards as a slice of values
				if seg.Type == paths.Wildcard {
					typ = Index().Add(typ)
				}
				g.Id(alloc(seg.Value, true)).Add(typ)
			}
		}
		if rpc.Raw {
			rawReqName = alloc("req", false)
			g.Id(rawReqName).Op("*").Qual("net/http", "Request")
		} else if req := rpc.Request; req != nil {
			paramName = alloc("p", false)
			g.Id(paramName).Add(b.namedType(f, req))
		}
	}).Do(func(s *Statement) {
		if withImpl {
			if rpc.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := rpc.Response; resp != nil {
				s.Params(Add(b.namedType(f, resp)), Error())
			} else {
				s.Params(Error())
			}
		} else {
			if rpc.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := rpc.Response; resp != nil {
				s.Params(b.namedType(f, resp), Error())
			} else {
				s.Error()
			}
		}
	}).BlockFunc(func(g *Group) {
		if withImpl {
			if rpc.Raw {
				g.Return(Nil(), Qual("errors", "New").Call(Lit("encore: calling raw endpoints is not yet supported")))
			} else {
				svcName := alloc("svc", false)
				g.List(Id(svcName), Err()).Op(":=").Id(b.serviceStructName(ss)).Dot("Get").Call()
				g.If(Err().Op("!=").Nil()).Block(ReturnFunc(func(g *Group) {
					if rpc.Raw {
						g.Nil()
					} else if rpc.Response != nil {
						// (*T, error) or (T, error)
						if rpc.Response.IsPointer() {
							g.Nil()
						} else {
							g.Add(b.namedType(f, rpc.Response).Values())
						}
					}
					g.Err()
				}))

				g.Return(Id("svc").Dot(rpc.Name).CallFunc(func(g *Group) {
					g.Id(ctxName)
					for _, name := range pathParamNames {
						g.Id(name)
					}
					if paramName != "" {
						g.Id(paramName)
					}
				}))
			}
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if rpc.Raw {
				g.Return(Nil(), Nil())
			} else if rpc.Response != nil {
				// (*T, error) or (T, error)
				if rpc.Response.IsPointer() {
					g.Return(Nil(), Nil())
				} else {
					g.Return(b.namedType(f, rpc.Response).Values(), Nil())
				}
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}
