package codegen

import (
	"strings"

	. "github.com/dave/jennifer/jen"

	"encr.dev/parser/est"
	"encr.dev/parser/paths"
	"encr.dev/pkg/namealloc"
)

// EncoreGen generates the encore.gen.go file containing user-facing
// generated code. If nothing needs to be generated it returns nil.
func (b *Builder) EncoreGen(svc *est.Service, withImpl bool) *File {
	// If there are no API Groups, there's nothing to do.
	if len(svc.APIGroups) == 0 {
		return nil
	}

	f := NewFilePathName(svc.Root.ImportPath, svc.Root.Name)
	f.ImportNames(importNames)
	for _, pkg := range b.res.App.Packages {
		f.ImportName(pkg.ImportPath, pkg.Name)
	}

	f.HeaderComment("Code generated by encore. DO NOT EDIT.")

	f.Comment("These functions are automatically generated and maintained by Encore")
	f.Comment("to simplify calling them from other services, as they were implemented as methods.")
	f.Comment("They are automatically updated by Encore whenever your API endpoints change.")
	f.Line()

	for _, group := range svc.APIGroups {
		for _, rpc := range group.RPCs {
			b.encoreGenRPC(f, group, rpc, withImpl)
			f.Line()
		}
	}

	return f
}

func (b *Builder) encoreGenRPC(f *File, group *est.APIGroup, rpc *est.RPC, withImpl bool) {
	if rpc.Doc != "" {
		for _, line := range strings.Split(strings.TrimSpace(rpc.Doc), "\n") {
			f.Comment(line)
		}
	}

	var argNames []string

	f.Func().Id(rpc.Name).ParamsFunc(func(g *Group) {
		var names namealloc.Allocator
		alloc := func(input string) string {
			name := names.Get(input)
			argNames = append(argNames, name)
			return name
		}

		g.Id(alloc("ctx")).Qual("context", "Context")
		for _, seg := range rpc.Path.Segments {
			if seg.Type != paths.Literal {
				g.Id(alloc(seg.Value)).Add(b.builtinType(seg.ValueType))
			}
		}
		if rpc.Raw {
			g.Id(alloc("req")).Op("*").Qual("net/http", "Request")
		} else if req := rpc.Request; req != nil {
			g.Id(alloc("req")).Add(b.namedType(f, req))
		}
	}).Do(func(s *Statement) {
		if withImpl {
			if rpc.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := rpc.Response; resp != nil {
				s.Params(Add(b.namedType(f, resp)), Error())
			} else {
				s.Params(Error())
			}
		} else {
			if rpc.Raw {
				s.Params(Op("*").Qual("net/http", "Response"), Error())
			} else if resp := rpc.Response; resp != nil {
				s.Params(b.namedType(f, resp), Error())
			} else {
				s.Error()
			}
		}
	}).BlockFunc(func(g *Group) {
		if withImpl {
			g.List(Id("svc"), Err()).Op(":=").Id(b.apiGroupHandlerName(group)).Dot("Get").Call()
			g.If(Err().Op("!=").Nil()).Block(ReturnFunc(func(g *Group) {
				if rpc.Raw {
					g.Nil()
				} else if rpc.Response != nil {
					// (*T, error) or (T, error)
					if rpc.Response.IsPtr {
						g.Nil()
					} else {
						g.Add(b.namedType(f, rpc.Response).Values())
					}
				}
				g.Err()
			}))

			g.Return(Id("svc").Dot(rpc.Name).CallFunc(func(g *Group) {
				for _, name := range argNames {
					g.Id(name)
				}
			}))
		} else {
			g.Comment("The implementation is elided here, and generated at compile-time by Encore.")
			if rpc.Raw {
				g.Return(Nil(), Nil())
			} else if rpc.Response != nil {
				// (*T, error) or (T, error)
				if rpc.Response.IsPtr {
					g.Return(Nil(), Nil())
				} else {
					g.Return(b.namedType(f, rpc.Response).Values(), Nil())
				}
			} else {
				// Just an error return
				g.Return(Nil())
			}
		}
	})
}
