// main code
package main

import (
	"encore.app/svc"
	"encore.dev/appruntime/api"
	"encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/config"
	"reflect"
	_ "unsafe"
)

// loadApp loads the Encore app runtime.
//go:linkname loadApp encore.dev/appruntime/app/appinit.load
func loadApp() *appinit.LoadData {
	static := &config.Static{
		AppCommit: config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		PubsubTopics:   map[string]*config.StaticPubsubTopic{},
		TestService:    "",
		Testing:        false,
	}
	handlers := []api.Handler{
		svc.EncoreInternal_EightHandler,
	}
	return &appinit.LoadData{
		APIHandlers: handlers,
		AuthHandler: svc.EncoreInternal_AuthHandlerAuthHandler,
		StaticCfg:   static,
	}
}

func main() {
	appinit.AppMain()
}


// generated types for service svc
package svc

import (
	"context"
	"encore.app/__encore/etype"
	"encore.dev/appruntime/api"
	_ "encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/model"
	"encore.dev/appruntime/serde"
	"encore.dev/beta/errs"
	"github.com/json-iterator/go"
	"github.com/julienschmidt/httprouter"
	"net/http"
	"net/url"
	"strings"
)

type EncoreInternal_EightReq struct {
	Bar    string
	Baz    string
	Params *FooParams
}

func (p *EncoreInternal_EightReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 3)
	for i, val := range [...]any{p.Bar, p.Baz, p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_EightReq) Clone() (*EncoreInternal_EightReq, error) {
	var clone EncoreInternal_EightReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_EightReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Bar",
		Value: enc.FromString(p.Bar),
	}, {
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/eight" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EncoreInternal_EightResp struct {
	Data *Response
}

func (p *EncoreInternal_EightResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_EightResp) Clone() (*EncoreInternal_EightResp, error) {
	var clone EncoreInternal_EightResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_EightHandler = &api.Desc[*EncoreInternal_EightReq, *EncoreInternal_EightResp]{
	Service:  "svc",
	Endpoint: "Eight",
	Methods:  []string{"POST"},
	Raw:      false,
	Path:     "/eight/:bar/:baz",
	DefLoc:   2,
	Access:   api.RequiresAuth,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_EightReq, err error) {
		reqData = &EncoreInternal_EightReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_EightReq) (*EncoreInternal_EightResp, error) {
		var fn func(context.Context, string, string, *FooParams) (*Response, error)
		fn = Eight
		resp, err := fn(ctx, req.Bar, req.Baz, req.Params)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_EightResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_EightResp) (err error) {
		respData := []byte("null\n")
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", out.Data.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallEight(ctx context.Context, bar string, baz string, params *FooParams) (*Response, error) {
	resp, err := EncoreInternal_EightHandler.Call(api.NewCallContext(ctx), &EncoreInternal_EightReq{bar, baz, params})
	if err != nil {
		return nil, err
	}
	return resp.Data, nil
}

type EncoreInternal_AuthHandlerAuthData struct {
	Params *AuthHeaders
}

func (p *EncoreInternal_AuthHandlerAuthData) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_AuthHandlerAuthData) Clone() (*EncoreInternal_AuthHandlerAuthData, error) {
	var clone EncoreInternal_AuthHandlerAuthData
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_AuthHandlerAuthHandler = &api.AuthHandlerDesc[*EncoreInternal_AuthHandlerAuthData]{
	Service:     "svc",
	Endpoint:    "AuthHandler",
	DefLoc:      3,
	HasAuthData: true,
	DecodeAuth: func(req *http.Request) (authData *EncoreInternal_AuthHandlerAuthData, err error) {
		authData = &EncoreInternal_AuthHandlerAuthData{}
		params := &AuthHeaders{}
		authData.Params = params
		dec := &etype.Marshaller{}
		// Decode headers
		h := req.Header
		params.Header1 = dec.ToString("header1", h.Get("header1"), false)
		params.Header2 = dec.ToInt("header2", h.Get("header2"), false)

		if dec.LastError != nil {
			return nil, errs.B().Code(errs.InvalidArgument).Msgf("invalid auth param: %v", dec.LastError).Err()
		}
		if dec.NonEmptyValues == 0 {
			return nil, errs.B().Code(errs.Unauthenticated).Msg("missing auth param").Err()
		}
		return authData, nil
	},
	AuthHandler: func(ctx context.Context, authData *EncoreInternal_AuthHandlerAuthData) (info model.AuthInfo, err error) {
		info.UID, info.UserData, err = AuthHandler(ctx, authData.Params)
		return info, err
	},
}
// etype package
package etype

import (
	_ "encore.dev/appruntime/app/appinit"
	"fmt"
	"github.com/json-iterator/go"
	"io"
	"io/ioutil"
	"strconv"
)

// Marshaller is used to serialize request data into strings and deserialize response data from strings
type Marshaller struct {
	LastError      error // The last error that occurred
	NonEmptyValues int   // The number of values this decoder has decoded
}

func (e *Marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) FromString(s string) (v string) {
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) ToInt(field string, s string, required bool) (v int) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseInt(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return int(x)
}

// setErr sets the last error within the object if one is not already set
func (e *Marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *Marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *Marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}
