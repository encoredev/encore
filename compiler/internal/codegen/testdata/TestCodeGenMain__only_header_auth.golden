// main code
package main

import (
	"encore.app/svc"
	"encore.dev/appruntime/api"
	"encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/config"
	"reflect"
	_ "unsafe"
)

// loadApp loads the Encore app runtime.
//go:linkname loadApp encore.dev/appruntime/app/appinit.load
func loadApp() *appinit.LoadData {
	static := &config.Static{
		AppCommit: config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		TestService:    "",
		Testing:        false,
	}
	handlers := []api.Handler{
		svc.EightHandler,
	}
	return &appinit.LoadData{
		APIHandlers: handlers,
		StaticCfg:   static,
	}
}

func main() {
	appinit.AppMain()
}


// generated types for service svc
package svc

import (
	"context"
	"encore.app/__encore/etype"
	"encore.dev/appruntime/api"
	_ "encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/serde"
	"github.com/json-iterator/go"
	"github.com/julienschmidt/httprouter"
	"net/http"
	"net/url"
	"strings"
)

type EightReq struct {
	Bar    string
	Baz    string
	Params *FooParams
}

func (p *EightReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 3)
	for i, val := range [...]any{p.Bar, p.Baz, p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EightReq) Clone() (*EightReq, error) {
	var clone EightReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EightReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Bar",
		Value: enc.FromString(p.Bar),
	}, {
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/eight" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EightResp struct {
	Data *Response
}

func (p *EightResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EightResp) Clone() (*EightResp, error) {
	var clone EightResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EightHandler = &api.Desc[*EightReq, *EightResp]{
	Service:  "svc",
	Endpoint: "Eight",
	Methods:  []string{"POST"},
	Path:     "/eight/:bar/:baz",
	DefLoc:   2,
	Access:   api.RequiresAuth,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EightReq, err error) {
		reqData = &EightReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "POST":
			// Decode JSON Body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EightReq) (*EightResp, error) {
		resp, err := Eight(ctx, req.Bar, req.Baz, req.Params)
		if err != nil {
			return nil, err
		}
		return &EightResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EightResp) error {
		var err error
		respData := []byte("null\n")
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", out.Data.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
}

func CallEight(ctx context.Context, bar string, baz string, params *FooParams) (*Response, error) {
	resp, err := EightHandler.Call(api.CallContext{}, &EightReq{bar, baz, params})
	return resp.Data, err
}
// etype package
package etype

import (
	_ "encore.dev/appruntime/app/appinit"
	"fmt"
	"github.com/json-iterator/go"
	"io"
	"io/ioutil"
)

// Marshaller is used to serialize request data into strings and deserialize response data from strings
type Marshaller struct {
	LastError      error // The last error that occurred
	NonEmptyValues int   // The number of values this decoder has decoded
}

func (e *Marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) FromString(s string) (v string) {
	e.NonEmptyValues++
	return s
}

// setErr sets the last error within the object if one is not already set
func (e *Marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *Marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *Marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}
