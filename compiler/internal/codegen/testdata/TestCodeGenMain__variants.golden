// main code
package main

import (
	"encore.app/svc"
	"encore.dev/appruntime/api"
	"encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/config"
	"reflect"
	_ "unsafe"
)

// loadApp loads the Encore app runtime.
//go:linkname loadApp encore.dev/appruntime/app/appinit.load
func loadApp() *appinit.LoadData {
	static := &config.Static{
		AppCommit: config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		TestService:    "",
		Testing:        false,
	}
	handlers := []api.Handler{
		svc.CronOneHandler,
		svc.EightHandler,
		svc.FiveHandler,
		svc.FourHandler,
		svc.NineHandler,
		svc.OneHandler,
		svc.QueryHandler,
		svc.SevenHandler,
		svc.SixHandler,
		svc.TenHandler,
		svc.ThreeHandler,
		svc.TwoHandler,
	}
	return &appinit.LoadData{
		APIHandlers: handlers,
		StaticCfg:   static,
	}
}

func main() {
	appinit.AppMain()
}


// generated types for service svc
package svc

import (
	"context"
	"encore.app/__encore/etype"
	"encore.dev/appruntime/api"
	_ "encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/serde"
	"encore.dev/types/uuid"
	"github.com/json-iterator/go"
	"github.com/julienschmidt/httprouter"
	"net/http"
	"net/url"
	"strings"
)

type CronOneReq struct{}

func (p *CronOneReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *CronOneReq) Clone() (*CronOneReq, error) {
	var clone CronOneReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *CronOneReq) Path() (string, api.PathParams, error) {

	return "/cron", nil, nil
}

type CronOneResp = api.Void

var CronOneHandler = &api.Desc[*CronOneReq, *CronOneResp]{
	Service:  "svc",
	Endpoint: "CronOne",
	Methods:  []string{"GET", "POST"},
	Path:     "/cron",
	DefLoc:   17,
	Access:   api.Private,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *CronOneReq, err error) {
		reqData = &CronOneReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *CronOneReq) (*CronOneResp, error) {
		err := CronOne(ctx)
		if err != nil {
			return nil, err
		}
		return &CronOneResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *CronOneResp) error {
		return nil
	},
}

func CallCronOne(ctx context.Context) error {
	_, err := CronOneHandler.Call(api.CallContext{}, &CronOneReq{})
	return err
}

type EightReq struct {
	Bar string
	Baz string
}

func (p *EightReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 2)
	for i, val := range [...]any{p.Bar, p.Baz} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EightReq) Clone() (*EightReq, error) {
	var clone EightReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EightReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Bar",
		Value: enc.FromString(p.Bar),
	}, {
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/eight" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EightResp struct {
	Data *Response
}

func (p *EightResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EightResp) Clone() (*EightResp, error) {
	var clone EightResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EightHandler = &api.Desc[*EightReq, *EightResp]{
	Service:  "svc",
	Endpoint: "Eight",
	Methods:  []string{"GET", "POST"},
	Path:     "/eight/:bar/:baz",
	DefLoc:   18,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EightReq, err error) {
		reqData = &EightReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EightReq) (*EightResp, error) {
		resp, err := Eight(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return &EightResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EightResp) error {
		var err error
		respData := []byte("null\n")
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", out.Data.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
}

func CallEight(ctx context.Context, bar string, baz string) (*Response, error) {
	resp, err := EightHandler.Call(api.CallContext{}, &EightReq{bar, baz})
	return resp.Data, err
}

type FiveReq struct {
	Id     uuid.UUID
	Key    uint
	Params *FooParams
}

func (p *FiveReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 3)
	for i, val := range [...]any{p.Id, p.Key, p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *FiveReq) Clone() (*FiveReq, error) {
	var clone FiveReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *FiveReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Id",
		Value: enc.FromUUID(p.Id),
	}, {
		Key:   "Key",
		Value: enc.FromUint(p.Key),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/five" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type FiveResp = api.Void

var FiveHandler = &api.Desc[*FiveReq, *FiveResp]{
	Service:  "svc",
	Endpoint: "Five",
	Methods:  []string{"GET", "POST"},
	Path:     "/five/:id/:key",
	DefLoc:   19,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *FiveReq, err error) {
		reqData = &FiveReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToUUID("id", ps[0].Value, true)

		reqData.Key = dec.ToUint("key", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode Query String
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON Body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *FiveReq) (*FiveResp, error) {
		err := Five(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return nil, err
		}
		return &FiveResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *FiveResp) error {
		return nil
	},
}

func CallFive(ctx context.Context, id uuid.UUID, key uint, params *FooParams) error {
	_, err := FiveHandler.Call(api.CallContext{}, &FiveReq{id, key, params})
	return err
}

type FourReq struct {
	Baz string
}

func (p *FourReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Baz} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *FourReq) Clone() (*FourReq, error) {
	var clone FourReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *FourReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/four" + "/" + params[0].Value, params, nil
}

type FourResp = api.Void

var FourHandler = &api.Desc[*FourReq, *FourResp]{
	Service:  "svc",
	Endpoint: "Four",
	Methods:  []string{"GET", "POST"},
	Path:     "/four/*baz",
	DefLoc:   20,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *FourReq, err error) {
		reqData = &FourReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[0].Value = strings.TrimPrefix(ps[0].Value, "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[0].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *FourReq) (*FourResp, error) {
		err := Four(ctx, req.Baz)
		if err != nil {
			return nil, err
		}
		return &FourResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *FourResp) error {
		return nil
	},
}

func CallFour(ctx context.Context, baz string) error {
	_, err := FourHandler.Call(api.CallContext{}, &FourReq{baz})
	return err
}

type NineReq struct {
	Bar string
	Baz string
}

func (p *NineReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 2)
	for i, val := range [...]any{p.Bar, p.Baz} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *NineReq) Clone() (*NineReq, error) {
	var clone NineReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *NineReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Bar",
		Value: enc.FromString(p.Bar),
	}, {
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/nine" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type NineResp struct {
	Data *ComplexResponse
}

func (p *NineResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *NineResp) Clone() (*NineResp, error) {
	var clone NineResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var NineHandler = &api.Desc[*NineReq, *NineResp]{
	Service:  "svc",
	Endpoint: "Nine",
	Methods:  []string{"GET", "POST"},
	Path:     "/nine/:bar/:baz",
	DefLoc:   21,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *NineReq, err error) {
		reqData = &NineReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *NineReq) (*NineResp, error) {
		resp, err := Nine(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return &NineResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *NineResp) error {
		var err error
		respData := []byte("null\n")
		var headers map[string][]string
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", out.Data.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(out.Data.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
}

func CallNine(ctx context.Context, bar string, baz string) (*ComplexResponse, error) {
	resp, err := NineHandler.Call(api.CallContext{}, &NineReq{bar, baz})
	return resp.Data, err
}

type OneReq struct{}

func (p *OneReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *OneReq) Clone() (*OneReq, error) {
	var clone OneReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *OneReq) Path() (string, api.PathParams, error) {

	return "/svc.One", nil, nil
}

type OneResp = api.Void

var OneHandler = &api.Desc[*OneReq, *OneResp]{
	Service:  "svc",
	Endpoint: "One",
	Methods:  []string{"GET", "POST"},
	Path:     "/svc.One",
	DefLoc:   22,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *OneReq, err error) {
		reqData = &OneReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *OneReq) (*OneResp, error) {
		err := One(ctx)
		if err != nil {
			return nil, err
		}
		return &OneResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *OneResp) error {
		return nil
	},
}

func CallOne(ctx context.Context) error {
	_, err := OneHandler.Call(api.CallContext{}, &OneReq{})
	return err
}

type QueryReq struct {
	Params *QueryParams
}

func (p *QueryReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *QueryReq) Clone() (*QueryReq, error) {
	var clone QueryReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *QueryReq) Path() (string, api.PathParams, error) {

	return "/query", nil, nil
}

type QueryResp struct {
	Data *QueryParams
}

func (p *QueryResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *QueryResp) Clone() (*QueryResp, error) {
	var clone QueryResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var QueryHandler = &api.Desc[*QueryReq, *QueryResp]{
	Service:  "svc",
	Endpoint: "Query",
	Methods:  []string{"GET", "POST"},
	Path:     "/query",
	DefLoc:   23,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *QueryReq, err error) {
		reqData = &QueryReq{}
		dec := &etype.Marshaller{}

		params := &QueryParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode Query String
			qs := req.URL.Query()
			params.Time = dec.ToTime("time", qs.Get("time"), false)
			params.UID = dec.ToUserID("uid", qs.Get("uid"), false)
			params.JSON = dec.ToJSON("json", qs.Get("json"), false)
			params.Float32 = dec.ToFloat32("float32", qs.Get("float32"), false)
			params.Float64 = dec.ToFloat64("float64", qs.Get("float64"), false)
			params.Strings = dec.ToStringList("strings", qs["strings"], false)
			params.Times = dec.ToTimeList("times", qs["times"], false)

		case "POST":
			// Decode JSON Body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "time":
					dec.ParseJSON("Time", iter, &params.Time)
				case "uid":
					dec.ParseJSON("UID", iter, &params.UID)
				case "json":
					dec.ParseJSON("JSON", iter, &params.JSON)
				case "float32":
					dec.ParseJSON("Float32", iter, &params.Float32)
				case "float64":
					dec.ParseJSON("Float64", iter, &params.Float64)
				case "strings":
					dec.ParseJSON("Strings", iter, &params.Strings)
				case "times":
					dec.ParseJSON("Times", iter, &params.Times)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *QueryReq) (*QueryResp, error) {
		resp, err := Query(ctx, req.Params)
		if err != nil {
			return nil, err
		}
		return &QueryResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *QueryResp) error {
		var err error
		respData := []byte("null\n")
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Time", out.Data.Time, false)
				ser.WriteField("UID", out.Data.UID, false)
				ser.WriteField("JSON", out.Data.JSON, false)
				ser.WriteField("Float32", out.Data.Float32, false)
				ser.WriteField("Float64", out.Data.Float64, false)
				ser.WriteField("Strings", out.Data.Strings, false)
				ser.WriteField("Times", out.Data.Times, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
}

func CallQuery(ctx context.Context, params *QueryParams) (*QueryParams, error) {
	resp, err := QueryHandler.Call(api.CallContext{}, &QueryReq{params})
	return resp.Data, err
}

type SevenReq struct {
	W   http.ResponseWriter
	Req *http.Request
}

func (p *SevenReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 2)
	for i, val := range [...]any{p.W, p.Req} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *SevenReq) Clone() (*SevenReq, error) {
	var clone SevenReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *SevenReq) Path() (string, api.PathParams, error) {

	return "/foo/:bar/:baz", nil, nil
}

type SevenResp = api.Void

var SevenHandler = &api.Desc[*SevenReq, *SevenResp]{
	Service:  "svc",
	Endpoint: "Seven",
	Methods:  []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Path:     "/foo/:bar/:baz",
	DefLoc:   24,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *SevenReq, err error) {
		reqData = &SevenReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		_ = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		_ = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *SevenReq) (*SevenResp, error) {
		Seven(req.W, req.Req)
		return &SevenResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *SevenResp) error {
		return nil
	},
}

type SixReq struct {
	Id     uuid.UUID
	Key    string
	Params *FooParams
}

func (p *SixReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 3)
	for i, val := range [...]any{p.Id, p.Key, p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *SixReq) Clone() (*SixReq, error) {
	var clone SixReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *SixReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Id",
		Value: enc.FromUUID(p.Id),
	}, {
		Key:   "Key",
		Value: enc.FromString(p.Key),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/six" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type SixResp = api.Void

var SixHandler = &api.Desc[*SixReq, *SixResp]{
	Service:  "svc",
	Endpoint: "Six",
	Methods:  []string{"GET", "POST"},
	Path:     "/six/:id/*key",
	DefLoc:   25,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *SixReq, err error) {
		reqData = &SixReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[1].Value = strings.TrimPrefix(ps[1].Value, "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToUUID("id", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Key = dec.ToString("key", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode Query String
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON Body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *SixReq) (*SixResp, error) {
		err := Six(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return nil, err
		}
		return &SixResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *SixResp) error {
		return nil
	},
}

func CallSix(ctx context.Context, id uuid.UUID, key string, params *FooParams) error {
	_, err := SixHandler.Call(api.CallContext{}, &SixReq{id, key, params})
	return err
}

type TenReq struct{}

func (p *TenReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *TenReq) Clone() (*TenReq, error) {
	var clone TenReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *TenReq) Path() (string, api.PathParams, error) {

	return "/ten", nil, nil
}

type TenResp struct {
	Data *HeaderResponse
}

func (p *TenResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *TenResp) Clone() (*TenResp, error) {
	var clone TenResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var TenHandler = &api.Desc[*TenReq, *TenResp]{
	Service:  "svc",
	Endpoint: "Ten",
	Methods:  []string{"GET", "POST"},
	Path:     "/ten",
	DefLoc:   26,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *TenReq, err error) {
		reqData = &TenReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *TenReq) (*TenResp, error) {
		resp, err := Ten(ctx)
		if err != nil {
			return nil, err
		}
		return &TenResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *TenResp) error {
		var err error
		respData := []byte{'\n'}
		var headers map[string][]string
		if out.Data != nil {

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(out.Data.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
}

func CallTen(ctx context.Context) (*HeaderResponse, error) {
	resp, err := TenHandler.Call(api.CallContext{}, &TenReq{})
	return resp.Data, err
}

type ThreeReq struct {
	Id string
}

func (p *ThreeReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Id} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *ThreeReq) Clone() (*ThreeReq, error) {
	var clone ThreeReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *ThreeReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Id",
		Value: enc.FromString(p.Id),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/three" + "/" + params[0].Value, params, nil
}

type ThreeResp = api.Void

var ThreeHandler = &api.Desc[*ThreeReq, *ThreeResp]{
	Service:  "svc",
	Endpoint: "Three",
	Methods:  []string{"GET", "POST"},
	Path:     "/three/:id",
	DefLoc:   27,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *ThreeReq, err error) {
		reqData = &ThreeReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToString("id", ps[0].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *ThreeReq) (*ThreeResp, error) {
		err := Three(ctx, req.Id)
		if err != nil {
			return nil, err
		}
		return &ThreeResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *ThreeResp) error {
		return nil
	},
}

func CallThree(ctx context.Context, id string) error {
	_, err := ThreeHandler.Call(api.CallContext{}, &ThreeReq{id})
	return err
}

type TwoReq struct {
	Params *FooParams
}

func (p *TwoReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *TwoReq) Clone() (*TwoReq, error) {
	var clone TwoReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *TwoReq) Path() (string, api.PathParams, error) {

	return "/svc.Two", nil, nil
}

type TwoResp = api.Void

var TwoHandler = &api.Desc[*TwoReq, *TwoResp]{
	Service:  "svc",
	Endpoint: "Two",
	Methods:  []string{"POST"},
	Path:     "/svc.Two",
	DefLoc:   28,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *TwoReq, err error) {
		reqData = &TwoReq{}
		dec := &etype.Marshaller{}

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "POST":
			// Decode JSON Body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *TwoReq) (*TwoResp, error) {
		err := Two(ctx, req.Params)
		if err != nil {
			return nil, err
		}
		return &TwoResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *TwoResp) error {
		return nil
	},
}

func CallTwo(ctx context.Context, params *FooParams) error {
	_, err := TwoHandler.Call(api.CallContext{}, &TwoReq{params})
	return err
}
// etype package
package etype

import (
	stdjson "encoding/json"
	_ "encore.dev/appruntime/app/appinit"
	auth "encore.dev/beta/auth"
	"encore.dev/types/uuid"
	"fmt"
	"github.com/json-iterator/go"
	"io"
	"io/ioutil"
	"strconv"
	"time"
)

// Marshaller is used to serialize request data into strings and deserialize response data from strings
type Marshaller struct {
	LastError      error // The last error that occurred
	NonEmptyValues int   // The number of values this decoder has decoded
}

func (e *Marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) FromString(s string) (v string) {
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) ToUUID(field string, s string, required bool) (v uuid.UUID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := uuid.FromString(s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUint(field string, s string, required bool) (v uint) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseUint(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return uint(x)
}

func (e *Marshaller) FromUUID(s uuid.UUID) (v string) {
	e.NonEmptyValues++
	return s.String()
}

func (e *Marshaller) FromUint(s uint) (v string) {
	e.NonEmptyValues++
	return strconv.FormatUint(uint64(s), 10)
}

func (e *Marshaller) ToTime(field string, s string, required bool) (v time.Time) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := time.Parse(time.RFC3339, s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUserID(field string, s string, required bool) (v auth.UID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return auth.UID(s)
}

func (e *Marshaller) ToJSON(field string, s string, required bool) (v stdjson.RawMessage) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return stdjson.RawMessage(s)
}

func (e *Marshaller) ToFloat32(field string, s string, required bool) (v float32) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 32)
	e.setErr("invalid parameter", field, err)
	return float32(x)
}

func (e *Marshaller) ToFloat64(field string, s string, required bool) (v float64) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 64)
	e.setErr("invalid parameter", field, err)
	return x
}

func (e *Marshaller) ToStringList(field string, s []string, required bool) (v []string) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToString(field, x, required))
	}
	return v
}

func (e *Marshaller) ToTimeList(field string, s []string, required bool) (v []time.Time) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToTime(field, x, required))
	}
	return v
}

// setErr sets the last error within the object if one is not already set
func (e *Marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *Marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *Marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}
