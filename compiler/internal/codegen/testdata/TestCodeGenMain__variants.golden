// main code
package main

import (
	"encore.app/svc"
	"encore.dev/appruntime/api"
	"encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/config"
	"reflect"
	_ "unsafe"
)

// loadApp loads the Encore app runtime.
//go:linkname loadApp encore.dev/appruntime/app/appinit.load
func loadApp() *appinit.LoadData {
	static := &config.Static{
		AppCommit: config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		PubsubTopics:   map[string]*config.StaticPubsubTopic{},
		TestService:    "",
		Testing:        false,
	}
	handlers := []api.Handler{
		svc.EncoreInternal_CronOneHandler,
		svc.EncoreInternal_DIHandler,
		svc.EncoreInternal_EightHandler,
		svc.EncoreInternal_FiveHandler,
		svc.EncoreInternal_FourHandler,
		svc.EncoreInternal_NineHandler,
		svc.EncoreInternal_OneHandler,
		svc.EncoreInternal_QueryHandler,
		svc.EncoreInternal_SevenHandler,
		svc.EncoreInternal_SixHandler,
		svc.EncoreInternal_TenHandler,
		svc.EncoreInternal_ThreeHandler,
		svc.EncoreInternal_TwoHandler,
	}
	return &appinit.LoadData{
		APIHandlers: handlers,
		AuthHandler: svc.EncoreInternal_AuthHandlerAuthHandler,
		StaticCfg:   static,
	}
}

func main() {
	appinit.AppMain()
}


// generated types for service svc
package svc

import (
	"context"
	"encore.app/__encore/etype"
	"encore.dev/appruntime/api"
	_ "encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/model"
	"encore.dev/appruntime/serde"
	"encore.dev/appruntime/service"
	"encore.dev/beta/errs"
	"encore.dev/types/uuid"
	"github.com/json-iterator/go"
	"github.com/julienschmidt/httprouter"
	"net/http"
	"net/url"
	"strings"
)

var EncoreInternal_ServiceService = &service.Decl[Service]{
	Service:     "svc",
	Name:        "Service",
	Setup:       InitService,
	SetupDefLoc: 31,
}

type EncoreInternal_CronOneReq struct{}

func (p *EncoreInternal_CronOneReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *EncoreInternal_CronOneReq) Clone() (*EncoreInternal_CronOneReq, error) {
	var clone EncoreInternal_CronOneReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_CronOneReq) Path() (string, api.PathParams, error) {

	return "/cron", nil, nil
}

type EncoreInternal_CronOneResp = api.Void

var EncoreInternal_CronOneHandler = &api.Desc[*EncoreInternal_CronOneReq, *EncoreInternal_CronOneResp]{
	Service:  "svc",
	Endpoint: "CronOne",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/cron",
	DefLoc:   18,
	Access:   api.Private,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_CronOneReq, err error) {
		reqData = &EncoreInternal_CronOneReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_CronOneReq) (*EncoreInternal_CronOneResp, error) {
		var fn func(context.Context) error
		fn = CronOne
		err := fn(ctx)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_CronOneResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_CronOneResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallCronOne(ctx context.Context) error {
	_, err := EncoreInternal_CronOneHandler.Call(api.NewCallContext(ctx), &EncoreInternal_CronOneReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_DIReq struct{}

func (p *EncoreInternal_DIReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *EncoreInternal_DIReq) Clone() (*EncoreInternal_DIReq, error) {
	var clone EncoreInternal_DIReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_DIReq) Path() (string, api.PathParams, error) {

	return "/di", nil, nil
}

type EncoreInternal_DIResp = api.Void

var EncoreInternal_DIHandler = &api.Desc[*EncoreInternal_DIReq, *EncoreInternal_DIResp]{
	Service:  "svc",
	Endpoint: "DI",
	Methods:  []string{"GET"},
	Raw:      false,
	Path:     "/di",
	DefLoc:   19,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_DIReq, err error) {
		reqData = &EncoreInternal_DIReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_DIReq) (*EncoreInternal_DIResp, error) {
		var fn func(context.Context) error
		svc, initErr := EncoreInternal_ServiceService.Get()
		if initErr != nil {
			return nil, initErr
		}
		fn = svc.DI
		err := fn(ctx)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_DIResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_DIResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallDI(ctx context.Context) error {
	_, err := EncoreInternal_DIHandler.Call(api.NewCallContext(ctx), &EncoreInternal_DIReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_EightReq struct {
	Bar string
	Baz string
}

func (p *EncoreInternal_EightReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 2)
	for i, val := range [...]any{p.Bar, p.Baz} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_EightReq) Clone() (*EncoreInternal_EightReq, error) {
	var clone EncoreInternal_EightReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_EightReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Bar",
		Value: enc.FromString(p.Bar),
	}, {
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/eight" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EncoreInternal_EightResp struct {
	Data *Response
}

func (p *EncoreInternal_EightResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_EightResp) Clone() (*EncoreInternal_EightResp, error) {
	var clone EncoreInternal_EightResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_EightHandler = &api.Desc[*EncoreInternal_EightReq, *EncoreInternal_EightResp]{
	Service:  "svc",
	Endpoint: "Eight",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/eight/:bar/:baz",
	DefLoc:   20,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_EightReq, err error) {
		reqData = &EncoreInternal_EightReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_EightReq) (*EncoreInternal_EightResp, error) {
		var fn func(context.Context, string, string) (*Response, error)
		fn = Eight
		resp, err := fn(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_EightResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_EightResp) (err error) {
		respData := []byte("null\n")
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", out.Data.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallEight(ctx context.Context, bar string, baz string) (*Response, error) {
	resp, err := EncoreInternal_EightHandler.Call(api.NewCallContext(ctx), &EncoreInternal_EightReq{bar, baz})
	if err != nil {
		return nil, err
	}
	return resp.Data, nil
}

type EncoreInternal_FiveReq struct {
	Id     uuid.UUID
	Key    uint
	Params *FooParams
}

func (p *EncoreInternal_FiveReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 3)
	for i, val := range [...]any{p.Id, p.Key, p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_FiveReq) Clone() (*EncoreInternal_FiveReq, error) {
	var clone EncoreInternal_FiveReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_FiveReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Id",
		Value: enc.FromUUID(p.Id),
	}, {
		Key:   "Key",
		Value: enc.FromUint(p.Key),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/five" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EncoreInternal_FiveResp = api.Void

var EncoreInternal_FiveHandler = &api.Desc[*EncoreInternal_FiveReq, *EncoreInternal_FiveResp]{
	Service:  "svc",
	Endpoint: "Five",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/five/:id/:key",
	DefLoc:   21,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_FiveReq, err error) {
		reqData = &EncoreInternal_FiveReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToUUID("id", ps[0].Value, true)

		reqData.Key = dec.ToUint("key", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_FiveReq) (*EncoreInternal_FiveResp, error) {
		var fn func(context.Context, uuid.UUID, uint, *FooParams) error
		fn = Five
		err := fn(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_FiveResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_FiveResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallFive(ctx context.Context, id uuid.UUID, key uint, params *FooParams) error {
	_, err := EncoreInternal_FiveHandler.Call(api.NewCallContext(ctx), &EncoreInternal_FiveReq{id, key, params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_FourReq struct {
	Baz string
}

func (p *EncoreInternal_FourReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Baz} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_FourReq) Clone() (*EncoreInternal_FourReq, error) {
	var clone EncoreInternal_FourReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_FourReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/four" + "/" + params[0].Value, params, nil
}

type EncoreInternal_FourResp = api.Void

var EncoreInternal_FourHandler = &api.Desc[*EncoreInternal_FourReq, *EncoreInternal_FourResp]{
	Service:  "svc",
	Endpoint: "Four",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/four/*baz",
	DefLoc:   22,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_FourReq, err error) {
		reqData = &EncoreInternal_FourReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[0].Value = strings.TrimPrefix(ps[0].Value, "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[0].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_FourReq) (*EncoreInternal_FourResp, error) {
		var fn func(context.Context, string) error
		fn = Four
		err := fn(ctx, req.Baz)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_FourResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_FourResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallFour(ctx context.Context, baz string) error {
	_, err := EncoreInternal_FourHandler.Call(api.NewCallContext(ctx), &EncoreInternal_FourReq{baz})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_NineReq struct {
	Bar string
	Baz string
}

func (p *EncoreInternal_NineReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 2)
	for i, val := range [...]any{p.Bar, p.Baz} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_NineReq) Clone() (*EncoreInternal_NineReq, error) {
	var clone EncoreInternal_NineReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_NineReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Bar",
		Value: enc.FromString(p.Bar),
	}, {
		Key:   "Baz",
		Value: enc.FromString(p.Baz),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/nine" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EncoreInternal_NineResp struct {
	Data *ComplexResponse
}

func (p *EncoreInternal_NineResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_NineResp) Clone() (*EncoreInternal_NineResp, error) {
	var clone EncoreInternal_NineResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_NineHandler = &api.Desc[*EncoreInternal_NineReq, *EncoreInternal_NineResp]{
	Service:  "svc",
	Endpoint: "Nine",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/nine/:bar/:baz",
	DefLoc:   23,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_NineReq, err error) {
		reqData = &EncoreInternal_NineReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_NineReq) (*EncoreInternal_NineResp, error) {
		var fn func(context.Context, string, string) (*ComplexResponse, error)
		fn = Nine
		resp, err := fn(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_NineResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_NineResp) (err error) {
		respData := []byte("null\n")
		var headers map[string][]string
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", out.Data.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(out.Data.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallNine(ctx context.Context, bar string, baz string) (*ComplexResponse, error) {
	resp, err := EncoreInternal_NineHandler.Call(api.NewCallContext(ctx), &EncoreInternal_NineReq{bar, baz})
	if err != nil {
		return nil, err
	}
	return resp.Data, nil
}

type EncoreInternal_OneReq struct{}

func (p *EncoreInternal_OneReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *EncoreInternal_OneReq) Clone() (*EncoreInternal_OneReq, error) {
	var clone EncoreInternal_OneReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_OneReq) Path() (string, api.PathParams, error) {

	return "/svc.One", nil, nil
}

type EncoreInternal_OneResp = api.Void

var EncoreInternal_OneHandler = &api.Desc[*EncoreInternal_OneReq, *EncoreInternal_OneResp]{
	Service:  "svc",
	Endpoint: "One",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/svc.One",
	DefLoc:   24,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_OneReq, err error) {
		reqData = &EncoreInternal_OneReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_OneReq) (*EncoreInternal_OneResp, error) {
		var fn func(context.Context) error
		fn = One
		err := fn(ctx)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_OneResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_OneResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallOne(ctx context.Context) error {
	_, err := EncoreInternal_OneHandler.Call(api.NewCallContext(ctx), &EncoreInternal_OneReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_QueryReq struct {
	Params *QueryParams
}

func (p *EncoreInternal_QueryReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_QueryReq) Clone() (*EncoreInternal_QueryReq, error) {
	var clone EncoreInternal_QueryReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_QueryReq) Path() (string, api.PathParams, error) {

	return "/query", nil, nil
}

type EncoreInternal_QueryResp struct {
	Data *QueryParams
}

func (p *EncoreInternal_QueryResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_QueryResp) Clone() (*EncoreInternal_QueryResp, error) {
	var clone EncoreInternal_QueryResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_QueryHandler = &api.Desc[*EncoreInternal_QueryReq, *EncoreInternal_QueryResp]{
	Service:  "svc",
	Endpoint: "Query",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/query",
	DefLoc:   25,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_QueryReq, err error) {
		reqData = &EncoreInternal_QueryReq{}
		dec := &etype.Marshaller{}

		params := &QueryParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Time = dec.ToTime("time", qs.Get("time"), false)
			params.UID = dec.ToUserID("uid", qs.Get("uid"), false)
			params.JSON = dec.ToJSON("json", qs.Get("json"), false)
			params.Float32 = dec.ToFloat32("float32", qs.Get("float32"), false)
			params.Float64 = dec.ToFloat64("float64", qs.Get("float64"), false)
			params.Strings = dec.ToStringList("strings", qs["strings"], false)
			params.Times = dec.ToTimeList("times", qs["times"], false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "time":
					dec.ParseJSON("Time", iter, &params.Time)
				case "uid":
					dec.ParseJSON("UID", iter, &params.UID)
				case "json":
					dec.ParseJSON("JSON", iter, &params.JSON)
				case "float32":
					dec.ParseJSON("Float32", iter, &params.Float32)
				case "float64":
					dec.ParseJSON("Float64", iter, &params.Float64)
				case "strings":
					dec.ParseJSON("Strings", iter, &params.Strings)
				case "times":
					dec.ParseJSON("Times", iter, &params.Times)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_QueryReq) (*EncoreInternal_QueryResp, error) {
		var fn func(context.Context, *QueryParams) (*QueryParams, error)
		fn = Query
		resp, err := fn(ctx, req.Params)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_QueryResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_QueryResp) (err error) {
		respData := []byte("null\n")
		if out.Data != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Time", out.Data.Time, false)
				ser.WriteField("UID", out.Data.UID, false)
				ser.WriteField("JSON", out.Data.JSON, false)
				ser.WriteField("Float32", out.Data.Float32, false)
				ser.WriteField("Float64", out.Data.Float64, false)
				ser.WriteField("Strings", out.Data.Strings, false)
				ser.WriteField("Times", out.Data.Times, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallQuery(ctx context.Context, params *QueryParams) (*QueryParams, error) {
	resp, err := EncoreInternal_QueryHandler.Call(api.NewCallContext(ctx), &EncoreInternal_QueryReq{params})
	if err != nil {
		return nil, err
	}
	return resp.Data, nil
}

type EncoreInternal_SevenReq struct{}

func (p *EncoreInternal_SevenReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *EncoreInternal_SevenReq) Clone() (*EncoreInternal_SevenReq, error) {
	var clone EncoreInternal_SevenReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_SevenReq) Path() (string, api.PathParams, error) {

	return "/foo/:bar/:baz", nil, nil
}

type EncoreInternal_SevenResp = api.Void

var EncoreInternal_SevenHandler = &api.Desc[*EncoreInternal_SevenReq, *EncoreInternal_SevenResp]{
	Service:  "svc",
	Endpoint: "Seven",
	Methods:  []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Raw:      true,
	Path:     "/foo/:bar/:baz",
	DefLoc:   26,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_SevenReq, err error) {
		reqData = &EncoreInternal_SevenReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		_ = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		_ = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: nil,
	EncodeResp: nil,
	RawHandler: Seven,
}

type EncoreInternal_SixReq struct {
	Id     uuid.UUID
	Key    string
	Params *FooParams
}

func (p *EncoreInternal_SixReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 3)
	for i, val := range [...]any{p.Id, p.Key, p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_SixReq) Clone() (*EncoreInternal_SixReq, error) {
	var clone EncoreInternal_SixReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_SixReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Id",
		Value: enc.FromUUID(p.Id),
	}, {
		Key:   "Key",
		Value: enc.FromString(p.Key),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/six" + "/" + params[0].Value + "/" + params[1].Value, params, nil
}

type EncoreInternal_SixResp = api.Void

var EncoreInternal_SixHandler = &api.Desc[*EncoreInternal_SixReq, *EncoreInternal_SixResp]{
	Service:  "svc",
	Endpoint: "Six",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/six/:id/*key",
	DefLoc:   27,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_SixReq, err error) {
		reqData = &EncoreInternal_SixReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[1].Value = strings.TrimPrefix(ps[1].Value, "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToUUID("id", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Key = dec.ToString("key", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_SixReq) (*EncoreInternal_SixResp, error) {
		var fn func(context.Context, uuid.UUID, string, *FooParams) error
		fn = Six
		err := fn(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_SixResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_SixResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallSix(ctx context.Context, id uuid.UUID, key string, params *FooParams) error {
	_, err := EncoreInternal_SixHandler.Call(api.NewCallContext(ctx), &EncoreInternal_SixReq{id, key, params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_TenReq struct{}

func (p *EncoreInternal_TenReq) Serialize(json jsoniter.API) ([][]byte, error) {
	return nil, nil
}
func (p *EncoreInternal_TenReq) Clone() (*EncoreInternal_TenReq, error) {
	var clone EncoreInternal_TenReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_TenReq) Path() (string, api.PathParams, error) {

	return "/ten", nil, nil
}

type EncoreInternal_TenResp struct {
	Data *HeaderResponse
}

func (p *EncoreInternal_TenResp) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Data} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_TenResp) Clone() (*EncoreInternal_TenResp, error) {
	var clone EncoreInternal_TenResp
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_TenHandler = &api.Desc[*EncoreInternal_TenReq, *EncoreInternal_TenResp]{
	Service:  "svc",
	Endpoint: "Ten",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/ten",
	DefLoc:   28,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_TenReq, err error) {
		reqData = &EncoreInternal_TenReq{}
		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_TenReq) (*EncoreInternal_TenResp, error) {
		var fn func(context.Context) (*HeaderResponse, error)
		fn = Ten
		resp, err := fn(ctx)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_TenResp{resp}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_TenResp) (err error) {
		respData := []byte{'\n'}
		var headers map[string][]string
		if out.Data != nil {

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(out.Data.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallTen(ctx context.Context) (*HeaderResponse, error) {
	resp, err := EncoreInternal_TenHandler.Call(api.NewCallContext(ctx), &EncoreInternal_TenReq{})
	if err != nil {
		return nil, err
	}
	return resp.Data, nil
}

type EncoreInternal_ThreeReq struct {
	Id string
}

func (p *EncoreInternal_ThreeReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Id} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_ThreeReq) Clone() (*EncoreInternal_ThreeReq, error) {
	var clone EncoreInternal_ThreeReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_ThreeReq) Path() (string, api.PathParams, error) {
	enc := &etype.Marshaller{}

	params := api.PathParams{{
		Key:   "Id",
		Value: enc.FromString(p.Id),
	}}
	if enc.LastError != nil {

		return "", nil, enc.LastError
	}

	return "/three" + "/" + params[0].Value, params, nil
}

type EncoreInternal_ThreeResp = api.Void

var EncoreInternal_ThreeHandler = &api.Desc[*EncoreInternal_ThreeReq, *EncoreInternal_ThreeResp]{
	Service:  "svc",
	Endpoint: "Three",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/three/:id",
	DefLoc:   29,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_ThreeReq, err error) {
		reqData = &EncoreInternal_ThreeReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToString("id", ps[0].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_ThreeReq) (*EncoreInternal_ThreeResp, error) {
		var fn func(context.Context, string) error
		fn = Three
		err := fn(ctx, req.Id)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_ThreeResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_ThreeResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallThree(ctx context.Context, id string) error {
	_, err := EncoreInternal_ThreeHandler.Call(api.NewCallContext(ctx), &EncoreInternal_ThreeReq{id})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_TwoReq struct {
	Params *FooParams
}

func (p *EncoreInternal_TwoReq) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_TwoReq) Clone() (*EncoreInternal_TwoReq, error) {
	var clone EncoreInternal_TwoReq
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}
func (p *EncoreInternal_TwoReq) Path() (string, api.PathParams, error) {

	return "/svc.Two", nil, nil
}

type EncoreInternal_TwoResp = api.Void

var EncoreInternal_TwoHandler = &api.Desc[*EncoreInternal_TwoReq, *EncoreInternal_TwoResp]{
	Service:  "svc",
	Endpoint: "Two",
	Methods:  []string{"POST"},
	Raw:      false,
	Path:     "/svc.Two",
	DefLoc:   30,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_TwoReq, err error) {
		reqData = &EncoreInternal_TwoReq{}
		dec := &etype.Marshaller{}

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_TwoReq) (*EncoreInternal_TwoResp, error) {
		var fn func(context.Context, *FooParams) error
		fn = Two
		err := fn(ctx, req.Params)
		if err != nil {
			return nil, err
		}
		return &EncoreInternal_TwoResp{}, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, out *EncoreInternal_TwoResp) (err error) {
		return nil
	},
	RawHandler: nil,
}

func EncoreInternal_CallTwo(ctx context.Context, params *FooParams) error {
	_, err := EncoreInternal_TwoHandler.Call(api.NewCallContext(ctx), &EncoreInternal_TwoReq{params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_AuthHandlerAuthData struct {
	Params *AuthParams
}

func (p *EncoreInternal_AuthHandlerAuthData) Serialize(json jsoniter.API) ([][]byte, error) {
	data := make([][]byte, 1)
	for i, val := range [...]any{p.Params} {
		v, err := json.Marshal(val)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}
func (p *EncoreInternal_AuthHandlerAuthData) Clone() (*EncoreInternal_AuthHandlerAuthData, error) {
	var clone EncoreInternal_AuthHandlerAuthData
	bytes, err := jsoniter.ConfigDefault.Marshal(p)
	if err == nil {
		err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
	}
	return &clone, err
}

var EncoreInternal_AuthHandlerAuthHandler = &api.AuthHandlerDesc[*EncoreInternal_AuthHandlerAuthData]{
	Service:     "svc",
	Endpoint:    "AuthHandler",
	DefLoc:      32,
	HasAuthData: true,
	DecodeAuth: func(req *http.Request) (authData *EncoreInternal_AuthHandlerAuthData, err error) {
		authData = &EncoreInternal_AuthHandlerAuthData{}
		params := &AuthParams{}
		authData.Params = params
		dec := &etype.Marshaller{}
		// Decode headers
		h := req.Header
		params.Header1 = dec.ToString("one", h.Get("one"), false)
		params.Header2 = dec.ToInt("two", h.Get("two"), false)
		params.Header3 = dec.ToUint("three", h.Get("three"), false)

		// Decode query string
		qs := req.URL.Query()
		params.Query1 = dec.ToString("one", qs.Get("one"), false)
		params.Query2 = dec.ToStringList("two", qs["two"], false)
		params.Query3 = dec.ToTime("three", qs.Get("three"), false)

		if dec.LastError != nil {
			return nil, errs.B().Code(errs.InvalidArgument).Msgf("invalid auth param: %v", dec.LastError).Err()
		}
		if dec.NonEmptyValues == 0 {
			return nil, errs.B().Code(errs.Unauthenticated).Msg("missing auth param").Err()
		}
		return authData, nil
	},
	AuthHandler: func(ctx context.Context, authData *EncoreInternal_AuthHandlerAuthData) (info model.AuthInfo, err error) {
		info.UID, info.UserData, err = AuthHandler(ctx, authData.Params)
		return info, err
	},
}


// encore.gen.go for service svc
// Code generated by encore. DO NOT EDIT.

package svc

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func DI(ctx context.Context) error {
	svc, err := EncoreInternal_ServiceService.Get()
	if err != nil {
		return err
	}
	return svc.DI(ctx)
}
// etype package
package etype

import (
	stdjson "encoding/json"
	_ "encore.dev/appruntime/app/appinit"
	auth "encore.dev/beta/auth"
	"encore.dev/types/uuid"
	"fmt"
	"github.com/json-iterator/go"
	"io"
	"io/ioutil"
	"strconv"
	"time"
)

// Marshaller is used to serialize request data into strings and deserialize response data from strings
type Marshaller struct {
	LastError      error // The last error that occurred
	NonEmptyValues int   // The number of values this decoder has decoded
}

func (e *Marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) FromString(s string) (v string) {
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) ToUUID(field string, s string, required bool) (v uuid.UUID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := uuid.FromString(s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUint(field string, s string, required bool) (v uint) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseUint(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return uint(x)
}

func (e *Marshaller) FromUUID(s uuid.UUID) (v string) {
	e.NonEmptyValues++
	return s.String()
}

func (e *Marshaller) FromUint(s uint) (v string) {
	e.NonEmptyValues++
	return strconv.FormatUint(uint64(s), 10)
}

func (e *Marshaller) ToTime(field string, s string, required bool) (v time.Time) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := time.Parse(time.RFC3339, s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUserID(field string, s string, required bool) (v auth.UID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return auth.UID(s)
}

func (e *Marshaller) ToJSON(field string, s string, required bool) (v stdjson.RawMessage) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return stdjson.RawMessage(s)
}

func (e *Marshaller) ToFloat32(field string, s string, required bool) (v float32) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 32)
	e.setErr("invalid parameter", field, err)
	return float32(x)
}

func (e *Marshaller) ToFloat64(field string, s string, required bool) (v float64) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 64)
	e.setErr("invalid parameter", field, err)
	return x
}

func (e *Marshaller) ToStringList(field string, s []string, required bool) (v []string) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToString(field, x, required))
	}
	return v
}

func (e *Marshaller) ToTimeList(field string, s []string, required bool) (v []time.Time) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToTime(field, x, required))
	}
	return v
}

func (e *Marshaller) ToInt(field string, s string, required bool) (v int) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseInt(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return int(x)
}

// setErr sets the last error within the object if one is not already set
func (e *Marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *Marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *Marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}
