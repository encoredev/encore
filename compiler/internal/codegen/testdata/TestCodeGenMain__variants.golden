// main code
package main

import (
	"encore.app/svc"
	"encore.dev/appruntime/api"
	"encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/config"
	middleware "encore.dev/middleware"
	"reflect"
	_ "unsafe"
)

// loadApp loads the Encore app runtime.
//go:linkname loadApp encore.dev/appruntime/app/appinit.load
func loadApp() *appinit.LoadData {
	static := &config.Static{
		AppCommit: config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		PubsubTopics:   map[string]*config.StaticPubsubTopic{},
		TestService:    "",
		Testing:        false,
	}
	handlers := []api.HandlerRegistration{
		{
			Handler:    svc.EncoreInternal_CronOneHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_DIHandler,
			Middleware: []*api.Middleware{EncoreInternal_svcMyMiddleware},
		},
		{
			Handler:    svc.EncoreInternal_EightHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_FiveHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_FourHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_NineHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_OneHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_QueryHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_SevenHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_SixHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_TenHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_ThreeHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_TwoHandler,
			Middleware: nil,
		},
	}
	return &appinit.LoadData{
		APIHandlers: handlers,
		AuthHandler: svc.EncoreInternal_AuthHandlerAuthHandler,
		StaticCfg:   static,
	}
}

func main() {
	appinit.AppMain()
}

var EncoreInternal_svcMyMiddleware = &api.Middleware{
	PkgName: "svc",
	Name:    "MyMiddleware",
	Global:  false,
	DefLoc:  33,
	Invoke: func(req middleware.Request, next middleware.Next) middleware.Response {
		svc, err := svc.EncoreInternal_ServiceService.Get()
		if err != nil {
			return middleware.Response{Err: err}
		}
		return svc.MyMiddleware(req, next)
	},
}


// generated types for service svc
package svc

import (
	"context"
	"encore.app/__encore/etype"
	"encore.dev/appruntime/api"
	_ "encore.dev/appruntime/app/appinit"
	"encore.dev/appruntime/model"
	"encore.dev/appruntime/serde"
	"encore.dev/appruntime/service"
	"encore.dev/beta/errs"
	"encore.dev/types/uuid"
	"github.com/json-iterator/go"
	"github.com/julienschmidt/httprouter"
	"net/http"
	"net/url"
	"strings"
)

var EncoreInternal_ServiceService = &service.Decl[Service]{
	Service:     "svc",
	Name:        "Service",
	Setup:       initService,
	SetupDefLoc: 31,
}

type EncoreInternal_CronOneReq struct{}

type EncoreInternal_CronOneResp = api.Void

var EncoreInternal_CronOneHandler = &api.Desc[*EncoreInternal_CronOneReq, EncoreInternal_CronOneResp]{
	Service:  "svc",
	Endpoint: "CronOne",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/cron",
	DefLoc:   18,
	Access:   api.Private,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_CronOneReq, err error) {
		reqData = &EncoreInternal_CronOneReq{}
		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_CronOneReq) (*EncoreInternal_CronOneReq, error) {
		var clone EncoreInternal_CronOneReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_CronOneReq) ([][]byte, error) {
		return nil, nil
	},
	ReqPath: func(p *EncoreInternal_CronOneReq) (string, api.PathParams, error) {

		return "/cron", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_CronOneReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_CronOneReq) (EncoreInternal_CronOneResp, error) {
		err := CronOne(ctx)
		if err != nil {
			return EncoreInternal_CronOneResp{}, err
		}
		return EncoreInternal_CronOneResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_CronOneResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallCronOne(ctx context.Context) error {
	_, err := EncoreInternal_CronOneHandler.Call(api.NewCallContext(ctx), &EncoreInternal_CronOneReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_DIReq struct{}

type EncoreInternal_DIResp = api.Void

var EncoreInternal_DIHandler = &api.Desc[*EncoreInternal_DIReq, EncoreInternal_DIResp]{
	Service:  "svc",
	Endpoint: "DI",
	Methods:  []string{"GET"},
	Raw:      false,
	Path:     "/di",
	DefLoc:   19,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_DIReq, err error) {
		reqData = &EncoreInternal_DIReq{}
		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_DIReq) (*EncoreInternal_DIReq, error) {
		var clone EncoreInternal_DIReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_DIReq) ([][]byte, error) {
		return nil, nil
	},
	ReqPath: func(p *EncoreInternal_DIReq) (string, api.PathParams, error) {

		return "/di", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_DIReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_DIReq) (EncoreInternal_DIResp, error) {
		svc, initErr := EncoreInternal_ServiceService.Get()
		if initErr != nil {
			return EncoreInternal_DIResp{}, initErr
		}
		err := svc.DI(ctx)
		if err != nil {
			return EncoreInternal_DIResp{}, err
		}
		return EncoreInternal_DIResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_DIResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallDI(ctx context.Context) error {
	_, err := EncoreInternal_DIHandler.Call(api.NewCallContext(ctx), &EncoreInternal_DIReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_EightReq struct {
	Bar string
	Baz string
}

type EncoreInternal_EightResp = Response

var EncoreInternal_EightHandler = &api.Desc[*EncoreInternal_EightReq, *EncoreInternal_EightResp]{
	Service:  "svc",
	Endpoint: "Eight",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/eight/:bar/:baz",
	DefLoc:   20,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_EightReq, err error) {
		reqData = &EncoreInternal_EightReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_EightReq) (*EncoreInternal_EightReq, error) {
		var clone EncoreInternal_EightReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_EightReq) ([][]byte, error) {
		data := make([][]byte, 2)
		for i, val := range [...]any{p.Bar, p.Baz} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_EightReq) (string, api.PathParams, error) {
		enc := &etype.Marshaller{}

		params := api.PathParams{{
			Key:   "Bar",
			Value: enc.FromString(p.Bar),
		}, {
			Key:   "Baz",
			Value: enc.FromString(p.Baz),
		}}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/eight" + "/" + params[0].Value + "/" + params[1].Value, params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_EightReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_EightReq) (*EncoreInternal_EightResp, error) {
		resp, err := Eight(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_EightResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", resp.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	SerializeResp: func(json jsoniter.API, resp *EncoreInternal_EightResp) ([][]byte, error) {
		v, err := json.Marshal(resp)
		if err != nil {
			return nil, err
		}
		return [][]byte{v}, nil
	},
	CloneResp: func(resp *EncoreInternal_EightResp) (*EncoreInternal_EightResp, error) {
		var clone EncoreInternal_EightResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallEight(ctx context.Context, bar string, baz string) (*Response, error) {
	resp, err := EncoreInternal_EightHandler.Call(api.NewCallContext(ctx), &EncoreInternal_EightReq{bar, baz})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_FiveReq struct {
	Id     uuid.UUID
	Key    uint
	Params *FooParams
}

type EncoreInternal_FiveResp = api.Void

var EncoreInternal_FiveHandler = &api.Desc[*EncoreInternal_FiveReq, EncoreInternal_FiveResp]{
	Service:  "svc",
	Endpoint: "Five",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/five/:id/:key",
	DefLoc:   21,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_FiveReq, err error) {
		reqData = &EncoreInternal_FiveReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToUUID("id", ps[0].Value, true)

		reqData.Key = dec.ToUint("key", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_FiveReq) (*EncoreInternal_FiveReq, error) {
		var clone EncoreInternal_FiveReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_FiveReq) ([][]byte, error) {
		data := make([][]byte, 3)
		for i, val := range [...]any{p.Id, p.Key, p.Params} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_FiveReq) (string, api.PathParams, error) {
		enc := &etype.Marshaller{}

		params := api.PathParams{{
			Key:   "Id",
			Value: enc.FromUUID(p.Id),
		}, {
			Key:   "Key",
			Value: enc.FromUint(p.Key),
		}}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/five" + "/" + params[0].Value + "/" + params[1].Value, params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_FiveReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_FiveReq) (EncoreInternal_FiveResp, error) {
		err := Five(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return EncoreInternal_FiveResp{}, err
		}
		return EncoreInternal_FiveResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FiveResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallFive(ctx context.Context, id uuid.UUID, key uint, params *FooParams) error {
	_, err := EncoreInternal_FiveHandler.Call(api.NewCallContext(ctx), &EncoreInternal_FiveReq{id, key, params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_FourReq struct {
	Baz string
}

type EncoreInternal_FourResp = api.Void

var EncoreInternal_FourHandler = &api.Desc[*EncoreInternal_FourReq, EncoreInternal_FourResp]{
	Service:  "svc",
	Endpoint: "Four",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/four/*baz",
	DefLoc:   22,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_FourReq, err error) {
		reqData = &EncoreInternal_FourReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[0].Value = strings.TrimPrefix(ps[0].Value, "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[0].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_FourReq) (*EncoreInternal_FourReq, error) {
		var clone EncoreInternal_FourReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_FourReq) ([][]byte, error) {
		data := make([][]byte, 1)
		for i, val := range [...]any{p.Baz} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_FourReq) (string, api.PathParams, error) {
		enc := &etype.Marshaller{}

		params := api.PathParams{{
			Key:   "Baz",
			Value: enc.FromString(p.Baz),
		}}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/four" + "/" + params[0].Value, params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_FourReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_FourReq) (EncoreInternal_FourResp, error) {
		err := Four(ctx, req.Baz)
		if err != nil {
			return EncoreInternal_FourResp{}, err
		}
		return EncoreInternal_FourResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FourResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallFour(ctx context.Context, baz string) error {
	_, err := EncoreInternal_FourHandler.Call(api.NewCallContext(ctx), &EncoreInternal_FourReq{baz})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_NineReq struct {
	Bar string
	Baz string
}

type EncoreInternal_NineResp = ComplexResponse

var EncoreInternal_NineHandler = &api.Desc[*EncoreInternal_NineReq, *EncoreInternal_NineResp]{
	Service:  "svc",
	Endpoint: "Nine",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/nine/:bar/:baz",
	DefLoc:   23,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_NineReq, err error) {
		reqData = &EncoreInternal_NineReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Bar = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Baz = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_NineReq) (*EncoreInternal_NineReq, error) {
		var clone EncoreInternal_NineReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_NineReq) ([][]byte, error) {
		data := make([][]byte, 2)
		for i, val := range [...]any{p.Bar, p.Baz} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_NineReq) (string, api.PathParams, error) {
		enc := &etype.Marshaller{}

		params := api.PathParams{{
			Key:   "Bar",
			Value: enc.FromString(p.Bar),
		}, {
			Key:   "Baz",
			Value: enc.FromString(p.Baz),
		}}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/nine" + "/" + params[0].Value + "/" + params[1].Value, params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_NineReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_NineReq) (*EncoreInternal_NineResp, error) {
		resp, err := Nine(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_NineResp) (err error) {
		respData := []byte("null\n")
		var headers map[string][]string
		if resp != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Message", resp.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(resp.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	SerializeResp: func(json jsoniter.API, resp *EncoreInternal_NineResp) ([][]byte, error) {
		v, err := json.Marshal(resp)
		if err != nil {
			return nil, err
		}
		return [][]byte{v}, nil
	},
	CloneResp: func(resp *EncoreInternal_NineResp) (*EncoreInternal_NineResp, error) {
		var clone EncoreInternal_NineResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallNine(ctx context.Context, bar string, baz string) (*ComplexResponse, error) {
	resp, err := EncoreInternal_NineHandler.Call(api.NewCallContext(ctx), &EncoreInternal_NineReq{bar, baz})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_OneReq struct{}

type EncoreInternal_OneResp = api.Void

var EncoreInternal_OneHandler = &api.Desc[*EncoreInternal_OneReq, EncoreInternal_OneResp]{
	Service:  "svc",
	Endpoint: "One",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/svc.One",
	DefLoc:   24,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_OneReq, err error) {
		reqData = &EncoreInternal_OneReq{}
		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_OneReq) (*EncoreInternal_OneReq, error) {
		var clone EncoreInternal_OneReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_OneReq) ([][]byte, error) {
		return nil, nil
	},
	ReqPath: func(p *EncoreInternal_OneReq) (string, api.PathParams, error) {

		return "/svc.One", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_OneReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_OneReq) (EncoreInternal_OneResp, error) {
		err := One(ctx)
		if err != nil {
			return EncoreInternal_OneResp{}, err
		}
		return EncoreInternal_OneResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_OneResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallOne(ctx context.Context) error {
	_, err := EncoreInternal_OneHandler.Call(api.NewCallContext(ctx), &EncoreInternal_OneReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_QueryReq struct {
	Params *QueryParams
}

type EncoreInternal_QueryResp = QueryParams

var EncoreInternal_QueryHandler = &api.Desc[*EncoreInternal_QueryReq, *EncoreInternal_QueryResp]{
	Service:  "svc",
	Endpoint: "Query",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/query",
	DefLoc:   25,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_QueryReq, err error) {
		reqData = &EncoreInternal_QueryReq{}
		dec := &etype.Marshaller{}

		params := &QueryParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Time = dec.ToTime("time", qs.Get("time"), false)
			params.UID = dec.ToUserID("uid", qs.Get("uid"), false)
			params.JSON = dec.ToJSON("json", qs.Get("json"), false)
			params.Float32 = dec.ToFloat32("float32", qs.Get("float32"), false)
			params.Float64 = dec.ToFloat64("float64", qs.Get("float64"), false)
			params.Strings = dec.ToStringList("strings", qs["strings"], false)
			params.Times = dec.ToTimeList("times", qs["times"], false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "time":
					dec.ParseJSON("Time", iter, &params.Time)
				case "uid":
					dec.ParseJSON("UID", iter, &params.UID)
				case "json":
					dec.ParseJSON("JSON", iter, &params.JSON)
				case "float32":
					dec.ParseJSON("Float32", iter, &params.Float32)
				case "float64":
					dec.ParseJSON("Float64", iter, &params.Float64)
				case "strings":
					dec.ParseJSON("Strings", iter, &params.Strings)
				case "times":
					dec.ParseJSON("Times", iter, &params.Times)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_QueryReq) (*EncoreInternal_QueryReq, error) {
		var clone EncoreInternal_QueryReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_QueryReq) ([][]byte, error) {
		data := make([][]byte, 1)
		for i, val := range [...]any{p.Params} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_QueryReq) (string, api.PathParams, error) {

		return "/query", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_QueryReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_QueryReq) (*EncoreInternal_QueryResp, error) {
		resp, err := Query(ctx, req.Params)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_QueryResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
				ser.WriteField("Time", resp.Time, false)
				ser.WriteField("UID", resp.UID, false)
				ser.WriteField("JSON", resp.JSON, false)
				ser.WriteField("Float32", resp.Float32, false)
				ser.WriteField("Float64", resp.Float64, false)
				ser.WriteField("Strings", resp.Strings, false)
				ser.WriteField("Times", resp.Times, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	SerializeResp: func(json jsoniter.API, resp *EncoreInternal_QueryResp) ([][]byte, error) {
		v, err := json.Marshal(resp)
		if err != nil {
			return nil, err
		}
		return [][]byte{v}, nil
	},
	CloneResp: func(resp *EncoreInternal_QueryResp) (*EncoreInternal_QueryResp, error) {
		var clone EncoreInternal_QueryResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallQuery(ctx context.Context, params *QueryParams) (*QueryParams, error) {
	resp, err := EncoreInternal_QueryHandler.Call(api.NewCallContext(ctx), &EncoreInternal_QueryReq{params})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_SevenReq struct{}

type EncoreInternal_SevenResp = api.Void

var EncoreInternal_SevenHandler = &api.Desc[*EncoreInternal_SevenReq, EncoreInternal_SevenResp]{
	Service:  "svc",
	Endpoint: "Seven",
	Methods:  []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Raw:      true,
	Path:     "/foo/:bar/:baz",
	DefLoc:   26,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_SevenReq, err error) {
		reqData = &EncoreInternal_SevenReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		_ = dec.ToString("bar", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		_ = dec.ToString("baz", ps[1].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_SevenReq) (*EncoreInternal_SevenReq, error) {
		var clone EncoreInternal_SevenReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_SevenReq) ([][]byte, error) {
		return nil, nil
	},
	ReqPath: func(p *EncoreInternal_SevenReq) (string, api.PathParams, error) {

		return "/foo/:bar/:baz", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_SevenReq) any {
		return nil
	},
	AppHandler:    nil,
	RawHandler:    Seven,
	EncodeResp:    nil,
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

type EncoreInternal_SixReq struct {
	Id     uuid.UUID
	Key    string
	Params *FooParams
}

type EncoreInternal_SixResp = api.Void

var EncoreInternal_SixHandler = &api.Desc[*EncoreInternal_SixReq, EncoreInternal_SixResp]{
	Service:  "svc",
	Endpoint: "Six",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/six/:id/*key",
	DefLoc:   27,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_SixReq, err error) {
		reqData = &EncoreInternal_SixReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[1].Value = strings.TrimPrefix(ps[1].Value, "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToUUID("id", ps[0].Value, true)

		if value, err := url.PathUnescape(ps[1].Value); err == nil {
			ps[1].Value = value
		}

		reqData.Key = dec.ToString("key", ps[1].Value, true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_SixReq) (*EncoreInternal_SixReq, error) {
		var clone EncoreInternal_SixReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_SixReq) ([][]byte, error) {
		data := make([][]byte, 3)
		for i, val := range [...]any{p.Id, p.Key, p.Params} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_SixReq) (string, api.PathParams, error) {
		enc := &etype.Marshaller{}

		params := api.PathParams{{
			Key:   "Id",
			Value: enc.FromUUID(p.Id),
		}, {
			Key:   "Key",
			Value: enc.FromString(p.Key),
		}}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/six" + "/" + params[0].Value + "/" + params[1].Value, params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_SixReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_SixReq) (EncoreInternal_SixResp, error) {
		err := Six(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return EncoreInternal_SixResp{}, err
		}
		return EncoreInternal_SixResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_SixResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallSix(ctx context.Context, id uuid.UUID, key string, params *FooParams) error {
	_, err := EncoreInternal_SixHandler.Call(api.NewCallContext(ctx), &EncoreInternal_SixReq{id, key, params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_TenReq struct{}

type EncoreInternal_TenResp = HeaderResponse

var EncoreInternal_TenHandler = &api.Desc[*EncoreInternal_TenReq, *EncoreInternal_TenResp]{
	Service:  "svc",
	Endpoint: "Ten",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/ten",
	DefLoc:   28,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_TenReq, err error) {
		reqData = &EncoreInternal_TenReq{}
		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_TenReq) (*EncoreInternal_TenReq, error) {
		var clone EncoreInternal_TenReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_TenReq) ([][]byte, error) {
		return nil, nil
	},
	ReqPath: func(p *EncoreInternal_TenReq) (string, api.PathParams, error) {

		return "/ten", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_TenReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_TenReq) (*EncoreInternal_TenResp, error) {
		resp, err := Ten(ctx)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_TenResp) (err error) {
		respData := []byte{'\n'}
		var headers map[string][]string
		if resp != nil {

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(resp.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	SerializeResp: func(json jsoniter.API, resp *EncoreInternal_TenResp) ([][]byte, error) {
		v, err := json.Marshal(resp)
		if err != nil {
			return nil, err
		}
		return [][]byte{v}, nil
	},
	CloneResp: func(resp *EncoreInternal_TenResp) (*EncoreInternal_TenResp, error) {
		var clone EncoreInternal_TenResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallTen(ctx context.Context) (*HeaderResponse, error) {
	resp, err := EncoreInternal_TenHandler.Call(api.NewCallContext(ctx), &EncoreInternal_TenReq{})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_ThreeReq struct {
	Id string
}

type EncoreInternal_ThreeResp = api.Void

var EncoreInternal_ThreeHandler = &api.Desc[*EncoreInternal_ThreeReq, EncoreInternal_ThreeResp]{
	Service:  "svc",
	Endpoint: "Three",
	Methods:  []string{"GET", "POST"},
	Raw:      false,
	Path:     "/three/:id",
	DefLoc:   29,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_ThreeReq, err error) {
		reqData = &EncoreInternal_ThreeReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0].Value); err == nil {
			ps[0].Value = value
		}

		reqData.Id = dec.ToString("id", ps[0].Value, true)
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_ThreeReq) (*EncoreInternal_ThreeReq, error) {
		var clone EncoreInternal_ThreeReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_ThreeReq) ([][]byte, error) {
		data := make([][]byte, 1)
		for i, val := range [...]any{p.Id} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_ThreeReq) (string, api.PathParams, error) {
		enc := &etype.Marshaller{}

		params := api.PathParams{{
			Key:   "Id",
			Value: enc.FromString(p.Id),
		}}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/three" + "/" + params[0].Value, params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_ThreeReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_ThreeReq) (EncoreInternal_ThreeResp, error) {
		err := Three(ctx, req.Id)
		if err != nil {
			return EncoreInternal_ThreeResp{}, err
		}
		return EncoreInternal_ThreeResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_ThreeResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallThree(ctx context.Context, id string) error {
	_, err := EncoreInternal_ThreeHandler.Call(api.NewCallContext(ctx), &EncoreInternal_ThreeReq{id})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_TwoReq struct {
	Params *FooParams
}

type EncoreInternal_TwoResp = api.Void

var EncoreInternal_TwoHandler = &api.Desc[*EncoreInternal_TwoReq, EncoreInternal_TwoResp]{
	Service:  "svc",
	Endpoint: "Two",
	Methods:  []string{"POST"},
	Raw:      false,
	Path:     "/svc.Two",
	DefLoc:   30,
	Access:   api.Public,
	DecodeReq: func(req *http.Request, ps httprouter.Params, json jsoniter.API) (reqData *EncoreInternal_TwoReq, err error) {
		reqData = &EncoreInternal_TwoReq{}
		dec := &etype.Marshaller{}

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, dec.LastError
		}

		return reqData, nil
	},
	CloneReq: func(p *EncoreInternal_TwoReq) (*EncoreInternal_TwoReq, error) {
		var clone EncoreInternal_TwoReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	SerializeReq: func(json jsoniter.API, p *EncoreInternal_TwoReq) ([][]byte, error) {
		data := make([][]byte, 1)
		for i, val := range [...]any{p.Params} {
			v, err := json.Marshal(val)
			if err != nil {
				return nil, err
			}
			data[i] = v
		}
		return data, nil
	},
	ReqPath: func(p *EncoreInternal_TwoReq) (string, api.PathParams, error) {

		return "/svc.Two", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_TwoReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_TwoReq) (EncoreInternal_TwoResp, error) {
		err := Two(ctx, req.Params)
		if err != nil {
			return EncoreInternal_TwoResp{}, err
		}
		return EncoreInternal_TwoResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_TwoResp) (err error) {
		return nil
	},
	SerializeResp: api.SerializeVoid,
	CloneResp:     api.CloneVoid,
}

func EncoreInternal_CallTwo(ctx context.Context, params *FooParams) error {
	_, err := EncoreInternal_TwoHandler.Call(api.NewCallContext(ctx), &EncoreInternal_TwoReq{params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_AuthHandlerAuthParams = AuthParams

var EncoreInternal_AuthHandlerAuthHandler = &api.AuthHandlerDesc[*EncoreInternal_AuthHandlerAuthParams]{
	Service:     "svc",
	Endpoint:    "AuthHandler",
	DefLoc:      32,
	HasAuthData: true,
	DecodeAuth: func(req *http.Request) (params *EncoreInternal_AuthHandlerAuthParams, err error) {
		params = &EncoreInternal_AuthHandlerAuthParams{}
		dec := &etype.Marshaller{}
		// Decode headers
		h := req.Header
		params.Header1 = dec.ToString("one", h.Get("one"), false)
		params.Header2 = dec.ToInt("two", h.Get("two"), false)
		params.Header3 = dec.ToUint("three", h.Get("three"), false)

		// Decode query string
		qs := req.URL.Query()
		params.Query1 = dec.ToString("one", qs.Get("one"), false)
		params.Query2 = dec.ToStringList("two", qs["two"], false)
		params.Query3 = dec.ToTime("three", qs.Get("three"), false)

		if dec.LastError != nil {
			return nil, errs.B().Code(errs.InvalidArgument).Msgf("invalid auth param: %v", dec.LastError).Err()
		}
		if dec.NonEmptyValues == 0 {
			return nil, errs.B().Code(errs.Unauthenticated).Msg("missing auth param").Err()
		}
		return params, nil
	},
	AuthHandler: func(ctx context.Context, params *EncoreInternal_AuthHandlerAuthParams) (info model.AuthInfo, err error) {
		info.UID, info.UserData, err = AuthHandler(ctx, params)
		return info, err
	},
	SerializeParams: func(json jsoniter.API, params *EncoreInternal_AuthHandlerAuthParams) ([][]byte, error) {
		v, err := json.Marshal(params)
		if err != nil {
			return nil, err
		}
		return [][]byte{v}, nil
	},
}


// encore.gen.go for service svc
// Code generated by encore. DO NOT EDIT.

package svc

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func DI(ctx context.Context) error {
	svc, err := EncoreInternal_ServiceService.Get()
	if err != nil {
		return err
	}
	return svc.DI(ctx)
}
// etype package
package etype

import (
	stdjson "encoding/json"
	_ "encore.dev/appruntime/app/appinit"
	auth "encore.dev/beta/auth"
	"encore.dev/types/uuid"
	"fmt"
	"github.com/json-iterator/go"
	"io"
	"io/ioutil"
	"strconv"
	"time"
)

// Marshaller is used to serialize request data into strings and deserialize response data from strings
type Marshaller struct {
	LastError      error // The last error that occurred
	NonEmptyValues int   // The number of values this decoder has decoded
}

func (e *Marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) FromString(s string) (v string) {
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) ToUUID(field string, s string, required bool) (v uuid.UUID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := uuid.FromString(s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUint(field string, s string, required bool) (v uint) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseUint(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return uint(x)
}

func (e *Marshaller) FromUUID(s uuid.UUID) (v string) {
	e.NonEmptyValues++
	return s.String()
}

func (e *Marshaller) FromUint(s uint) (v string) {
	e.NonEmptyValues++
	return strconv.FormatUint(uint64(s), 10)
}

func (e *Marshaller) ToTime(field string, s string, required bool) (v time.Time) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := time.Parse(time.RFC3339, s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUserID(field string, s string, required bool) (v auth.UID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return auth.UID(s)
}

func (e *Marshaller) ToJSON(field string, s string, required bool) (v stdjson.RawMessage) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return stdjson.RawMessage(s)
}

func (e *Marshaller) ToFloat32(field string, s string, required bool) (v float32) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 32)
	e.setErr("invalid parameter", field, err)
	return float32(x)
}

func (e *Marshaller) ToFloat64(field string, s string, required bool) (v float64) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 64)
	e.setErr("invalid parameter", field, err)
	return x
}

func (e *Marshaller) ToStringList(field string, s []string, required bool) (v []string) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToString(field, x, required))
	}
	return v
}

func (e *Marshaller) ToTimeList(field string, s []string, required bool) (v []time.Time) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToTime(field, x, required))
	}
	return v
}

func (e *Marshaller) ToInt(field string, s string, required bool) (v int) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseInt(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return int(x)
}

// setErr sets the last error within the object if one is not already set
func (e *Marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *Marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *Marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}
