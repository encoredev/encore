// main code
package main

import (
	"context"
	stdjson "encoding/json"
	"encore.app/svc"
	auth "encore.dev/beta/auth"
	"encore.dev/beta/errs"
	"encore.dev/runtime"
	"encore.dev/runtime/config"
	serde "encore.dev/runtime/serde"
	"encore.dev/types/uuid"
	"fmt"
	"github.com/felixge/httpsnoop"
	"github.com/json-iterator/go"
	"github.com/julienschmidt/httprouter"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"
	_ "unsafe"
)

var json = jsoniter.Config{
	EscapeHTML:             false,
	IndentionStep:          config.JsonIndentStepForResponses(),
	SortMapKeys:            true,
	ValidateJsonRawMessage: true,
}.Froze()

func __encore_svc_CronOne(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "CronOne")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "CronOne",
		EndpointExprIdx: 16,
		Inputs:          nil,
		Path:            req.URL.Path,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.CronOne(req.Context())
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Eight(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	p0 := dec.ToString("bar", ps[0].Value, true)
	if value, err := url.PathUnescape(ps[1].Value); err == nil {
		ps[1].Value = value
	}
	p1 := dec.ToString("baz", ps[1].Value, true)
	inputs, _ := runtime.SerializeInputs(p0, p1)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Eight")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Eight",
		EndpointExprIdx: 17,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	resp, respErr := svc.Eight(req.Context(), p0, p1)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	// Serialize the response
	respData := []byte("null\n")
	if resp != nil {
		// Encode JSON body
		respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
			ser.WriteField("Message", resp.Message, false)
		})
		if err != nil {
			marshalErr := errs.WrapCode(err, errs.Internal, "failed to marshal response")
			runtime.FinishRequest(nil, marshalErr)
			errs.HTTPError(w, marshalErr)
			return
		}
		respData = append(respData, '\n')
	}

	// Record tracing data
	output := [][]byte{respData}
	runtime.FinishRequest(output, nil)

	// Write response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	w.Write(respData)
}

func __encore_svc_Five(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	p0 := dec.ToUUID("id", ps[0].Value, true)
	p1 := dec.ToUint("key", ps[1].Value, true)
	inputs, _ := runtime.SerializeInputs(p0, p1)

	params := &svc.FooParams{}
	switch m := req.Method; m {
	case "GET":
		// Decode Query String
		qs := req.URL.Query()
		params.Name = qs.Get("name")

	case "POST":
		// Decode JSON Body
		payload := dec.Body(req.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "name":
				dec.ParseJSON("Name", iter, &params.Name)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

	default:
		panic("HTTP method is not supported")
	}
	// Add trace info
	jsonParams, err := json.Marshal(params)
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	inputs = append(inputs, jsonParams)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Five")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Five",
		EndpointExprIdx: 18,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.Five(req.Context(), p0, p1, params)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Four(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}

	// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
	// while the httprouter implementation includes it.
	ps[0].Value = strings.TrimPrefix(ps[0].Value, "/")

	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	p0 := dec.ToString("baz", ps[0].Value, true)
	inputs, _ := runtime.SerializeInputs(p0)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Four")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Four",
		EndpointExprIdx: 19,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.Four(req.Context(), p0)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Nine(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	p0 := dec.ToString("bar", ps[0].Value, true)
	if value, err := url.PathUnescape(ps[1].Value); err == nil {
		ps[1].Value = value
	}
	p1 := dec.ToString("baz", ps[1].Value, true)
	inputs, _ := runtime.SerializeInputs(p0, p1)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Nine")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Nine",
		EndpointExprIdx: 20,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	resp, respErr := svc.Nine(req.Context(), p0, p1)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	// Serialize the response
	respData := []byte("null\n")
	var headers map[string][]string
	if resp != nil {
		// Encode JSON body
		respData, err = serde.SerializeJSONFunc(json, func(ser *serde.JSONSerializer) {
			ser.WriteField("Message", resp.Message, false)
		})
		if err != nil {
			marshalErr := errs.WrapCode(err, errs.Internal, "failed to marshal response")
			runtime.FinishRequest(nil, marshalErr)
			errs.HTTPError(w, marshalErr)
			return
		}
		respData = append(respData, '\n')

		// Encode headers
		headers = map[string][]string{"x-header": {resp.Header}}
	}

	// Record tracing data
	output := [][]byte{respData}
	runtime.FinishRequest(output, nil)

	// Write response
	for k, vs := range headers {
		for _, v := range vs {
			w.Header().Add(k, v)
		}
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	w.Write(respData)
}

func __encore_svc_One(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "One")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "One",
		EndpointExprIdx: 21,
		Inputs:          nil,
		Path:            req.URL.Path,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.One(req.Context())
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Query(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	var inputs [][]byte

	params := &svc.QueryParams{}
	switch m := req.Method; m {
	case "GET":
		// Decode Query String
		qs := req.URL.Query()
		params.Time = dec.ToTime("time", qs.Get("time"), false)
		params.UID = dec.ToUserID("uid", qs.Get("uid"), false)
		params.JSON = dec.ToJSON("json", qs.Get("json"), false)
		params.Float32 = dec.ToFloat32("float32", qs.Get("float32"), false)
		params.Float64 = dec.ToFloat64("float64", qs.Get("float64"), false)
		params.Strings = qs["strings"]
		params.Times = dec.ToTimeList("times", qs["times"], false)

	default:
		panic("HTTP method is not supported")
	}
	// Add trace info
	jsonParams, err := json.Marshal(params)
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	inputs = append(inputs, jsonParams)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Query")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Query",
		EndpointExprIdx: 22,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.Query(req.Context(), params)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Seven(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	_ = dec.ToString("bar", ps[0].Value, true)
	if value, err := url.PathUnescape(ps[1].Value); err == nil {
		ps[1].Value = value
	}
	_ = dec.ToString("baz", ps[1].Value, true)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Seven")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Seven",
		EndpointExprIdx: 23,
		Inputs:          nil,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	m := httpsnoop.CaptureMetrics(http.HandlerFunc(svc.Seven), w, req)
	if m.Code >= 400 {
		err = fmt.Errorf("response status code %d", m.Code)
	}
	runtime.FinishHTTPRequest(nil, err, m.Code)
}

func __encore_svc_Six(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}

	// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
	// while the httprouter implementation includes it.
	ps[1].Value = strings.TrimPrefix(ps[1].Value, "/")

	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	p0 := dec.ToUUID("id", ps[0].Value, true)
	if value, err := url.PathUnescape(ps[1].Value); err == nil {
		ps[1].Value = value
	}
	p1 := dec.ToString("key", ps[1].Value, true)
	inputs, _ := runtime.SerializeInputs(p0, p1)

	params := &svc.FooParams{}
	switch m := req.Method; m {
	case "GET":
		// Decode Query String
		qs := req.URL.Query()
		params.Name = qs.Get("name")

	case "POST":
		// Decode JSON Body
		payload := dec.Body(req.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "name":
				dec.ParseJSON("Name", iter, &params.Name)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

	default:
		panic("HTTP method is not supported")
	}
	// Add trace info
	jsonParams, err := json.Marshal(params)
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	inputs = append(inputs, jsonParams)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Six")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Six",
		EndpointExprIdx: 24,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.Six(req.Context(), p0, p1, params)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Ten(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Ten")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Ten",
		EndpointExprIdx: 25,
		Inputs:          nil,
		Path:            req.URL.Path,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	resp, respErr := svc.Ten(req.Context())
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	// Serialize the response
	respData := []byte{'\n'}
	var headers map[string][]string
	if resp != nil {

		// Encode headers
		headers = map[string][]string{"x-header": {resp.Header}}
	}

	// Record tracing data
	output := [][]byte{respData}
	runtime.FinishRequest(output, nil)

	// Write response
	for k, vs := range headers {
		for _, v := range vs {
			w.Header().Add(k, v)
		}
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	w.Write(respData)
}

func __encore_svc_Three(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	if value, err := url.PathUnescape(ps[0].Value); err == nil {
		ps[0].Value = value
	}
	p0 := dec.ToString("id", ps[0].Value, true)
	inputs, _ := runtime.SerializeInputs(p0)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Three")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Three",
		EndpointExprIdx: 26,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.Three(req.Context(), p0)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

func __encore_svc_Two(w http.ResponseWriter, req *http.Request, ps httprouter.Params) {
	ctx := req.Context()
	runtime.BeginOperation()
	defer runtime.FinishOperation()

	var err error
	dec := &marshaller{}
	// Decode request
	var inputs [][]byte

	params := &svc.FooParams{}
	switch m := req.Method; m {
	case "POST":
		// Decode JSON Body
		payload := dec.Body(req.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "name":
				dec.ParseJSON("Name", iter, &params.Name)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

	default:
		panic("HTTP method is not supported")
	}
	// Add trace info
	jsonParams, err := json.Marshal(params)
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	inputs = append(inputs, jsonParams)

	uid, authData, proceed := __encore_authenticate(w, req, false, "svc", "Two")
	if !proceed {
		return
	}

	err = runtime.BeginRequest(ctx, runtime.RequestData{
		AuthData:        authData,
		Endpoint:        "Two",
		EndpointExprIdx: 27,
		Inputs:          inputs,
		Path:            req.URL.Path,
		PathSegments:    ps,
		Service:         "svc",
		Type:            runtime.RPCCall,
		UID:             uid,
	})
	if err != nil {
		errs.HTTPError(w, errs.B().Code(errs.Internal).Msg("internal error").Err())
		return
	}
	if dec.LastError != nil {
		err := dec.LastError
		runtime.FinishRequest(nil, err)
		errs.HTTPError(w, err)
		return
	}

	// Call the endpoint
	defer func() {
		// Catch handler panic
		if e := recover(); e != nil {
			err := errs.B().Code(errs.Internal).Msgf("panic handling request: %v", e).Err()
			runtime.FinishRequest(nil, err)
			errs.HTTPError(w, err)
		}
	}()
	respErr := svc.Two(req.Context(), params)
	if respErr != nil {
		respErr = errs.Convert(respErr)
		runtime.FinishRequest(nil, respErr)
		errs.HTTPError(w, respErr)
		return
	}

	runtime.FinishRequest(nil, nil)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
}

// loadConfig registers the Encore services.
//go:linkname loadConfig encore.dev/runtime/config.loadConfig
func loadConfig() (*config.Config, error) {
	services := []*config.Service{{
		Endpoints: []*config.Endpoint{{
			Access:  config.Private,
			Handler: __encore_svc_CronOne,
			Methods: []string{"GET", "POST"},
			Name:    "CronOne",
			Path:    "/cron",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Eight,
			Methods: []string{"GET", "POST"},
			Name:    "Eight",
			Path:    "/eight/:bar/:baz",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Five,
			Methods: []string{"GET", "POST"},
			Name:    "Five",
			Path:    "/five/:id/:key",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Four,
			Methods: []string{"GET", "POST"},
			Name:    "Four",
			Path:    "/four/*baz",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Nine,
			Methods: []string{"GET", "POST"},
			Name:    "Nine",
			Path:    "/nine/:bar/:baz",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_One,
			Methods: []string{"GET", "POST"},
			Name:    "One",
			Path:    "/svc.One",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Query,
			Methods: []string{"GET"},
			Name:    "Query",
			Path:    "/query",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Seven,
			Methods: []string{"*"},
			Name:    "Seven",
			Path:    "/foo/:bar/:baz",
			Raw:     true,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Six,
			Methods: []string{"GET", "POST"},
			Name:    "Six",
			Path:    "/six/:id/*key",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Ten,
			Methods: []string{"GET", "POST"},
			Name:    "Ten",
			Path:    "/ten",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Three,
			Methods: []string{"GET", "POST"},
			Name:    "Three",
			Path:    "/three/:id",
			Raw:     false,
		}, {
			Access:  config.Public,
			Handler: __encore_svc_Two,
			Methods: []string{"POST"},
			Name:    "Two",
			Path:    "/svc.Two",
			Raw:     false,
		}},
		Name:    "svc",
		RelPath: "svc",
	}}
	static := &config.Static{
		AppCommit: config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		Services:       services,
		TestService:    "",
		Testing:        false,
	}
	return &config.Config{
		Runtime: config.ParseRuntime(getAndClearEnv("ENCORE_RUNTIME_CONFIG")),
		Secrets: config.ParseSecrets(getAndClearEnv("ENCORE_APP_SECRETS")),
		Static:  static,
	}, nil
}

func main() {
	if err := runtime.ListenAndServe(); err != nil {
		runtime.Logger().Fatal().Err(err).Msg("could not listen and serve")
	}
}

// getAndClearEnv gets an env variable and unsets it.
func getAndClearEnv(env string) string {
	val := os.Getenv(env)
	os.Unsetenv(env)
	return val
}

type validationDetails struct {
	Field string `json:"field"`
	Err   string `json:"err"`
}

func (validationDetails) ErrDetails() {}

// __encore_authenticate authenticates a request.
// It reports the user id, user data, and whether or not to proceed with the request.
// If requireAuth is false, it reports ("", nil, true) on authentication failure.
func __encore_authenticate(w http.ResponseWriter, req *http.Request, requireAuth bool, svcName, rpcName string) (uid auth.UID, authData interface{}, proceed bool) {
	param, err := __encore_resolveAuthParam(req)
	if err != nil {
		if requireAuth {
			runtime.Logger().Info().Str("service", svcName).Str("endpoint", rpcName).Msg("rejecting request due to missing auth")
			errs.HTTPError(w, errs.B().Code(errs.Unauthenticated).Msg("invalid auth param").Err())
			return "", nil, false
		}
		return "", nil, true
	}

	uid, authData, err = __encore_validateToken(req.Context(), param)
	if errs.Code(err) == errs.Unauthenticated && !requireAuth {
		return "", nil, true
	} else if err != nil {
		errs.HTTPError(w, err)
		return "", nil, false
	}
	return uid, authData, true
}

// __encore_resolveAuthParam resolves the auth parameters from the http request
//  or returns an error if auth params cannot be found
func __encore_resolveAuthParam(req *http.Request) (param *svc.AuthParams, err error) {
	params := &svc.AuthParams{}
	dec := &marshaller{}
	// Decode Headers
	h := req.Header
	params.Header1 = h.Get("one")
	params.Header2 = dec.ToInt("two", h.Get("two"), false)
	params.Header3 = dec.ToUint("three", h.Get("three"), false)

	// Decode Query String
	qs := req.URL.Query()
	params.Query1 = qs.Get("one")
	params.Query2 = qs["two"]
	params.Query3 = dec.ToTime("three", qs.Get("three"), false)

	if dec.LastError != nil {
		return nil, dec.LastError
	}
	return params, nil
}

// __encore_validateToken validates an auth token.
func __encore_validateToken(ctx context.Context, param *svc.AuthParams) (uid auth.UID, authData interface{}, authErr error) {
	done := make(chan struct{})
	paramStr, err := json.MarshalToString(param)
	if err != nil {
		return "", nil, err
	}
	call, err := runtime.BeginAuth(28, paramStr)
	if err != nil {
		return "", nil, err
	}

	go func() {
		defer close(done)
		authErr = call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "AuthHandler",
			EndpointExprIdx: 28,
			Inputs:          [][]byte{[]byte(paramStr)},
			Service:         "svc",
			Type:            runtime.AuthHandler,
		})
		if authErr != nil {
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				authErr = errs.B().Code(errs.Internal).Msgf("auth handler panicked: %v", err2).Err()
				call.FinishReq(nil, authErr)
			}
		}()
		uid, authData, authErr = svc.AuthHandler(ctx, param)
		serialized, _ := runtime.SerializeInputs(uid, authData)
		if authErr != nil {
			call.FinishReq(nil, authErr)
		} else {
			call.FinishReq(serialized, nil)
		}
	}()
	<-done
	call.Finish(uid, authErr)
	return uid, authData, authErr
}

// marshaller is used to serialize request data into strings and deserialize response data from strings
type marshaller struct {
	LastError error // The last error that occurred
}

func (e *marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	return s
}

func (e *marshaller) ToUUID(field string, s string, required bool) (v uuid.UUID) {
	if !required && s == "" {
		return
	}
	v, err := uuid.FromString(s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *marshaller) ToUint(field string, s string, required bool) (v uint) {
	if !required && s == "" {
		return
	}
	x, err := strconv.ParseUint(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return uint(x)
}

func (e *marshaller) ToTime(field string, s string, required bool) (v time.Time) {
	if !required && s == "" {
		return
	}
	v, err := time.Parse(time.RFC3339, s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *marshaller) ToUserID(field string, s string, required bool) (v auth.UID) {
	if !required && s == "" {
		return
	}
	return auth.UID(s)
}

func (e *marshaller) ToJSON(field string, s string, required bool) (v stdjson.RawMessage) {
	if !required && s == "" {
		return
	}
	return stdjson.RawMessage(s)
}

func (e *marshaller) ToFloat32(field string, s string, required bool) (v float32) {
	if !required && s == "" {
		return
	}
	x, err := strconv.ParseFloat(s, 32)
	e.setErr("invalid parameter", field, err)
	return float32(x)
}

func (e *marshaller) ToFloat64(field string, s string, required bool) (v float64) {
	if !required && s == "" {
		return
	}
	x, err := strconv.ParseFloat(s, 64)
	e.setErr("invalid parameter", field, err)
	return x
}

func (e *marshaller) ToTimeList(field string, s []string, required bool) (v []time.Time) {
	if !required && len(s) == 0 {
		return
	}
	for _, x := range s {
		v = append(v, e.ToTime(field, x, required))
	}
	return v
}

func (e *marshaller) ToInt(field string, s string, required bool) (v int) {
	if !required && s == "" {
		return
	}
	x, err := strconv.ParseInt(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return int(x)
}

// setErr sets the last error within the object if one is not already set
func (e *marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}


// wrappers for service svc
package svc

import (
	"context"
	"encore.dev/beta/errs"
	"encore.dev/runtime"
	"encore.dev/types/uuid"
	"fmt"
	"github.com/julienschmidt/httprouter"
	"net/url"
)

func __encore_svc_CronOne(ctx context.Context) (err error) {
	var inputs [][]byte
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "CronOne",
		EndpointExprIdx: 16,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "CronOne",
			EndpointExprIdx: 16,
			Inputs:          inputs,
			Path:            "/cron",
			PathSegments:    nil,
			RequireAuth:     false,
			Service:         "svc",
			Type:            runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		rpcErr := CronOne(ctx)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Eight(ctx context.Context, p0 string, p1 string) (resp *Response, err error) {
	inputs, err := runtime.SerializeInputs(p0, p1)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Eight",
		EndpointExprIdx: 17,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Eight",
			EndpointExprIdx: 17,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/eight/%s/%s", url.PathEscape(p0), url.PathEscape(p1)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "bar",
				Value: p0,
			}, httprouter.Param{
				Key:   "baz",
				Value: p1,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 string
			r1 string
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0, &r1}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcResp, rpcErr := Eight(ctx, r0, r1)
		response.data, _ = runtime.SerializeInputs(rpcResp)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	if response.data != nil {
		_ = runtime.CopyInputs(response.data, []interface{}{&resp})
	}
	return resp, response.err
}

func __encore_svc_Five(ctx context.Context, p0 uuid.UUID, p1 uint, p2 *FooParams) (err error) {
	inputs, err := runtime.SerializeInputs(p0, p1, p2)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Five",
		EndpointExprIdx: 18,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		p0Str := fmt.Sprint(p0)
		p1Str := fmt.Sprint(p1)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Five",
			EndpointExprIdx: 18,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/five/%s/%s", url.PathEscape(p0Str), url.PathEscape(p1Str)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "id",
				Value: p0Str,
			}, httprouter.Param{
				Key:   "key",
				Value: p1Str,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 uuid.UUID
			r1 uint
			r2 *FooParams
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0, &r1, &r2}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Five(ctx, r0, r1, r2)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Four(ctx context.Context, p0 string) (err error) {
	inputs, err := runtime.SerializeInputs(p0)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Four",
		EndpointExprIdx: 19,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Four",
			EndpointExprIdx: 19,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/four/%s", url.PathEscape(p0)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "baz",
				Value: p0,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 string
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Four(ctx, r0)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Nine(ctx context.Context, p0 string, p1 string) (resp *ComplexResponse, err error) {
	inputs, err := runtime.SerializeInputs(p0, p1)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Nine",
		EndpointExprIdx: 20,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Nine",
			EndpointExprIdx: 20,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/nine/%s/%s", url.PathEscape(p0), url.PathEscape(p1)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "bar",
				Value: p0,
			}, httprouter.Param{
				Key:   "baz",
				Value: p1,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 string
			r1 string
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0, &r1}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcResp, rpcErr := Nine(ctx, r0, r1)
		response.data, _ = runtime.SerializeInputs(rpcResp)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	if response.data != nil {
		_ = runtime.CopyInputs(response.data, []interface{}{&resp})
	}
	return resp, response.err
}

func __encore_svc_One(ctx context.Context) (err error) {
	var inputs [][]byte
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "One",
		EndpointExprIdx: 21,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "One",
			EndpointExprIdx: 21,
			Inputs:          inputs,
			Path:            "/svc.One",
			PathSegments:    nil,
			RequireAuth:     false,
			Service:         "svc",
			Type:            runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		rpcErr := One(ctx)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Query(ctx context.Context, p0 *QueryParams) (err error) {
	inputs, err := runtime.SerializeInputs(p0)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Query",
		EndpointExprIdx: 22,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Query",
			EndpointExprIdx: 22,
			Inputs:          inputs,
			Path:            "/query",
			PathSegments:    nil,
			RequireAuth:     false,
			Service:         "svc",
			Type:            runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 *QueryParams
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Query(ctx, r0)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Seven(ctx context.Context, p0 string, p1 string) (err error) {
	inputs, err := runtime.SerializeInputs(p0, p1)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Seven",
		EndpointExprIdx: 23,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Seven",
			EndpointExprIdx: 23,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/foo/%s/%s", url.PathEscape(p0), url.PathEscape(p1)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "bar",
				Value: p0,
			}, httprouter.Param{
				Key:   "baz",
				Value: p1,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 string
			r1 string
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0, &r1}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Seven(ctx, r0, r1)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Six(ctx context.Context, p0 uuid.UUID, p1 string, p2 *FooParams) (err error) {
	inputs, err := runtime.SerializeInputs(p0, p1, p2)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Six",
		EndpointExprIdx: 24,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		p0Str := fmt.Sprint(p0)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Six",
			EndpointExprIdx: 24,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/six/%s/%s", url.PathEscape(p0Str), url.PathEscape(p1)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "id",
				Value: p0Str,
			}, httprouter.Param{
				Key:   "key",
				Value: p1,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 uuid.UUID
			r1 string
			r2 *FooParams
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0, &r1, &r2}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Six(ctx, r0, r1, r2)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Ten(ctx context.Context) (resp *HeaderResponse, err error) {
	var inputs [][]byte
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Ten",
		EndpointExprIdx: 25,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Ten",
			EndpointExprIdx: 25,
			Inputs:          inputs,
			Path:            "/ten",
			PathSegments:    nil,
			RequireAuth:     false,
			Service:         "svc",
			Type:            runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		rpcResp, rpcErr := Ten(ctx)
		response.data, _ = runtime.SerializeInputs(rpcResp)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	if response.data != nil {
		_ = runtime.CopyInputs(response.data, []interface{}{&resp})
	}
	return resp, response.err
}

func __encore_svc_Three(ctx context.Context, p0 string) (err error) {
	inputs, err := runtime.SerializeInputs(p0)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Three",
		EndpointExprIdx: 26,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Three",
			EndpointExprIdx: 26,
			Inputs:          inputs,
			Path:            fmt.Sprintf("/three/%s", url.PathEscape(p0)),
			PathSegments: httprouter.Params{httprouter.Param{
				Key:   "id",
				Value: p0,
			}},
			RequireAuth: false,
			Service:     "svc",
			Type:        runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 string
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Three(ctx, r0)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}

func __encore_svc_Two(ctx context.Context, p0 *FooParams) (err error) {
	inputs, err := runtime.SerializeInputs(p0)
	if err != nil {
		return
	}
	call, err := runtime.BeginCall(runtime.CallParams{
		Endpoint:        "Two",
		EndpointExprIdx: 27,
		Service:         "svc",
	})
	if err != nil {
		return
	}

	// Run the request in a different goroutine
	var response struct {
		data [][]byte
		err  error
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		err := call.BeginReq(ctx, runtime.RequestData{
			Endpoint:        "Two",
			EndpointExprIdx: 27,
			Inputs:          inputs,
			Path:            "/svc.Two",
			PathSegments:    nil,
			RequireAuth:     false,
			Service:         "svc",
			Type:            runtime.RPCCall,
		})
		if err != nil {
			response.err = err
			return
		}
		defer func() {
			if err2 := recover(); err2 != nil {
				response.err = errs.B().Code(errs.Internal).Msgf("panic handling request: %v", err2).Err()
				call.FinishReq(nil, response.err)
			}
		}()

		var (
			r0 *FooParams
		)
		if response.err = runtime.CopyInputs(inputs, []interface{}{&r0}); response.err != nil {
			call.FinishReq(nil, response.err)
			return
		}

		rpcErr := Two(ctx, r0)
		if rpcErr != nil {
			call.FinishReq(nil, rpcErr)
			response.err = errs.RoundTrip(rpcErr)
		} else {
			call.FinishReq(response.data, nil)
		}
	}()
	<-done

	call.Finish(response.err)
	return response.err
}
