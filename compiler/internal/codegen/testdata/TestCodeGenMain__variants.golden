// main code
package main

import (
	_ "encore.app/otherservice"
	"encore.app/svc"
	__api "encore.dev/appruntime/api"
	__appinit "encore.dev/appruntime/app/appinit"
	__config "encore.dev/appruntime/config"
	errs "encore.dev/beta/errs"
	middleware "encore.dev/middleware"
	"reflect"
	_ "unsafe"
)

// loadApp loads the Encore app runtime.
//
//go:linkname loadApp encore.dev/appruntime/app/appinit.load
func loadApp() *__appinit.LoadData {
	static := &__config.Static{
		AppCommit: __config.CommitInfo{
			Revision:    "",
			Uncommitted: false,
		},
		AuthData:       reflect.TypeOf((*svc.AuthData)(nil)),
		EncoreCompiler: "test",
		PubsubTopics: map[string]*__config.StaticPubsubTopic{"test-topic": {Subscriptions: map[string]*__config.StaticPubsubSubscription{"subscription-name": {
			Service:  "otherservice",
			TraceIdx: 1,
		}}}},
		TestService: "",
		Testing:     false,
	}
	handlers := []__api.HandlerRegistration{
		{
			Handler:    svc.EncoreInternal_CronOneHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_DIHandler,
			Middleware: []*__api.Middleware{EncoreInternal_svcMyMiddleware},
		},
		{
			Handler:    svc.EncoreInternal_DIRawHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_EightHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_FiveHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_FourHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_NineHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_OneHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_QueryHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_SevenHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_SixHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_TenHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_ThreeHandler,
			Middleware: nil,
		},
		{
			Handler:    svc.EncoreInternal_TwoHandler,
			Middleware: nil,
		},
	}
	return &__appinit.LoadData{
		APIHandlers: handlers,
		AuthHandler: svc.EncoreInternal_AuthHandlerAuthHandler,
		StaticCfg:   static,
	}
}

func main() {
	__appinit.AppMain()
}

var EncoreInternal_svcMyMiddleware = &__api.Middleware{
	DefLoc: 40,
	Global: false,
	Invoke: func(req middleware.Request, next middleware.Next) middleware.Response {
		svc, err := svc.EncoreInternal_ServiceService.Get()
		if err != nil {
			return middleware.Response{
				Err:        err,
				HTTPStatus: errs.HTTPStatus(err),
			}
		}
		return svc.MyMiddleware(req, next)
	},
	Name:    "MyMiddleware",
	PkgName: "svc",
}


// generated types for service otherservice
package otherservice

import _ "encore.dev/appruntime/app/appinit"


// config unmarshallers for service otherservice
package otherservice

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/


// generated types for service svc
package svc

import (
	"context"
	"encore.app/__encore/etype"
	__api "encore.dev/appruntime/api"
	_ "encore.dev/appruntime/app/appinit"
	__model "encore.dev/appruntime/model"
	__serde "encore.dev/appruntime/serde"
	__service "encore.dev/appruntime/service"
	errs "encore.dev/beta/errs"
	uuid "encore.dev/types/uuid"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

var EncoreInternal_ServiceService = &__service.Decl[Service]{
	Service:     "svc",
	Name:        "Service",
	Setup:       initService,
	SetupDefLoc: 38,
}

type EncoreInternal_CronOneReq struct{}

type EncoreInternal_CronOneResp = __api.Void

var EncoreInternal_CronOneHandler = &__api.Desc[*EncoreInternal_CronOneReq, EncoreInternal_CronOneResp]{
	Service:        "svc",
	Endpoint:       "CronOne",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/cron",
	RawPath:        "/cron",
	PathParamNames: nil,
	DefLoc:         24,
	Access:         __api.Private,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_CronOneReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_CronOneReq{}
		return reqData, nil, nil
	},
	CloneReq: func(p *EncoreInternal_CronOneReq) (*EncoreInternal_CronOneReq, error) {
		var clone EncoreInternal_CronOneReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_CronOneReq) (string, __api.UnnamedParams, error) {

		return "/cron", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_CronOneReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_CronOneReq) (EncoreInternal_CronOneResp, error) {
		err := CronOne(ctx)
		if err != nil {
			return EncoreInternal_CronOneResp{}, err
		}
		return EncoreInternal_CronOneResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_CronOneResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallCronOne(ctx context.Context) error {
	_, err := EncoreInternal_CronOneHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_CronOneReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_DIReq struct{}

type EncoreInternal_DIResp = __api.Void

var EncoreInternal_DIHandler = &__api.Desc[*EncoreInternal_DIReq, EncoreInternal_DIResp]{
	Service:        "svc",
	Endpoint:       "DI",
	Methods:        []string{"GET"},
	Raw:            false,
	Path:           "/di",
	RawPath:        "/di",
	PathParamNames: nil,
	DefLoc:         25,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_DIReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_DIReq{}
		return reqData, nil, nil
	},
	CloneReq: func(p *EncoreInternal_DIReq) (*EncoreInternal_DIReq, error) {
		var clone EncoreInternal_DIReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_DIReq) (string, __api.UnnamedParams, error) {

		return "/di", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_DIReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_DIReq) (EncoreInternal_DIResp, error) {
		svc, initErr := EncoreInternal_ServiceService.Get()
		if initErr != nil {
			return EncoreInternal_DIResp{}, initErr
		}
		err := svc.DI(ctx)
		if err != nil {
			return EncoreInternal_DIResp{}, err
		}
		return EncoreInternal_DIResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_DIResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallDI(ctx context.Context) error {
	_, err := EncoreInternal_DIHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_DIReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_DIRawReq struct{}

type EncoreInternal_DIRawResp = __api.Void

var EncoreInternal_DIRawHandler = &__api.Desc[*EncoreInternal_DIRawReq, EncoreInternal_DIRawResp]{
	Service:        "svc",
	Endpoint:       "DIRaw",
	Methods:        []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Raw:            true,
	Path:           "/di/raw",
	RawPath:        "/di/raw",
	PathParamNames: nil,
	DefLoc:         26,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_DIRawReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_DIRawReq{}
		return reqData, nil, nil
	},
	CloneReq: func(p *EncoreInternal_DIRawReq) (*EncoreInternal_DIRawReq, error) {
		var clone EncoreInternal_DIRawReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_DIRawReq) (string, __api.UnnamedParams, error) {

		return "/di/raw", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_DIRawReq) any {
		return nil
	},
	AppHandler: nil,
	RawHandler: func(w http.ResponseWriter, req *http.Request) {
		svc, initErr := EncoreInternal_ServiceService.Get()
		if initErr != nil {
			errs.HTTPErrorWithCode(w, initErr, 0)
			return
		}
		svc.DIRaw(w, req)
	},
	EncodeResp: nil,
	CloneResp:  __api.CloneVoid,
}

type EncoreInternal_EightReq struct {
	Bar string
	Baz string
}

type EncoreInternal_EightResp = Response

var EncoreInternal_EightHandler = &__api.Desc[*EncoreInternal_EightReq, *EncoreInternal_EightResp]{
	Service:        "svc",
	Endpoint:       "Eight",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/eight/:bar/:baz",
	RawPath:        "/eight/:0/:1",
	PathParamNames: []string{"bar", "baz"},
	DefLoc:         27,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_EightReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_EightReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		reqData.Bar = dec.ToString("bar", ps[0], true)

		if value, err := url.PathUnescape(ps[1]); err == nil {
			ps[1] = value
		}

		reqData.Baz = dec.ToString("baz", ps[1], true)
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_EightReq) (*EncoreInternal_EightReq, error) {
		var clone EncoreInternal_EightReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_EightReq) (string, __api.UnnamedParams, error) {
		enc := &etype.Marshaller{}

		params := __api.UnnamedParams{enc.FromString(p.Bar), enc.FromString(p.Baz)}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/eight" + "/" + params[0] + "/" + params[1], params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_EightReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_EightReq) (*EncoreInternal_EightResp, error) {
		resp, err := Eight(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_EightResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("Message", resp.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	CloneResp: func(resp *EncoreInternal_EightResp) (*EncoreInternal_EightResp, error) {
		if resp == nil {
			return nil, nil
		}
		var clone EncoreInternal_EightResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallEight(ctx context.Context, bar string, baz string) (*Response, error) {
	resp, err := EncoreInternal_EightHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_EightReq{bar, baz})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_FiveReq struct {
	Id     uuid.UUID
	Key    uint
	Params *FooParams
}

type EncoreInternal_FiveResp = __api.Void

var EncoreInternal_FiveHandler = &__api.Desc[*EncoreInternal_FiveReq, EncoreInternal_FiveResp]{
	Service:        "svc",
	Endpoint:       "Five",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/five/:id/:key",
	RawPath:        "/five/:0/:1",
	PathParamNames: []string{"id", "key"},
	DefLoc:         28,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FiveReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_FiveReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		reqData.Id = dec.ToUUID("id", ps[0], true)

		reqData.Key = dec.ToUint("key", ps[1], true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_FiveReq) (*EncoreInternal_FiveReq, error) {
		var clone EncoreInternal_FiveReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_FiveReq) (string, __api.UnnamedParams, error) {
		enc := &etype.Marshaller{}

		params := __api.UnnamedParams{enc.FromUUID(p.Id), enc.FromUint(p.Key)}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/five" + "/" + params[0] + "/" + params[1], params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_FiveReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_FiveReq) (EncoreInternal_FiveResp, error) {
		err := Five(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return EncoreInternal_FiveResp{}, err
		}
		return EncoreInternal_FiveResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FiveResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallFive(ctx context.Context, id uuid.UUID, key uint, params *FooParams) error {
	_, err := EncoreInternal_FiveHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_FiveReq{id, key, params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_FourReq struct {
	Baz string
}

type EncoreInternal_FourResp = __api.Void

var EncoreInternal_FourHandler = &__api.Desc[*EncoreInternal_FourReq, EncoreInternal_FourResp]{
	Service:        "svc",
	Endpoint:       "Four",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/four/*baz",
	RawPath:        "/four/*0",
	PathParamNames: []string{"baz"},
	DefLoc:         29,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FourReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_FourReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[0] = strings.TrimPrefix(ps[0], "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		reqData.Baz = dec.ToString("baz", ps[0], true)
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_FourReq) (*EncoreInternal_FourReq, error) {
		var clone EncoreInternal_FourReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_FourReq) (string, __api.UnnamedParams, error) {
		enc := &etype.Marshaller{}

		params := __api.UnnamedParams{enc.FromString(p.Baz)}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/four" + "/" + params[0], params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_FourReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_FourReq) (EncoreInternal_FourResp, error) {
		err := Four(ctx, req.Baz)
		if err != nil {
			return EncoreInternal_FourResp{}, err
		}
		return EncoreInternal_FourResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FourResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallFour(ctx context.Context, baz string) error {
	_, err := EncoreInternal_FourHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_FourReq{baz})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_NineReq struct {
	Bar string
	Baz string
}

type EncoreInternal_NineResp = ComplexResponse

var EncoreInternal_NineHandler = &__api.Desc[*EncoreInternal_NineReq, *EncoreInternal_NineResp]{
	Service:        "svc",
	Endpoint:       "Nine",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/nine/:bar/:baz",
	RawPath:        "/nine/:0/:1",
	PathParamNames: []string{"bar", "baz"},
	DefLoc:         30,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_NineReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_NineReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		reqData.Bar = dec.ToString("bar", ps[0], true)

		if value, err := url.PathUnescape(ps[1]); err == nil {
			ps[1] = value
		}

		reqData.Baz = dec.ToString("baz", ps[1], true)
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_NineReq) (*EncoreInternal_NineReq, error) {
		var clone EncoreInternal_NineReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_NineReq) (string, __api.UnnamedParams, error) {
		enc := &etype.Marshaller{}

		params := __api.UnnamedParams{enc.FromString(p.Bar), enc.FromString(p.Baz)}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/nine" + "/" + params[0] + "/" + params[1], params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_NineReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_NineReq) (*EncoreInternal_NineResp, error) {
		resp, err := Nine(ctx, req.Bar, req.Baz)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_NineResp) (err error) {
		respData := []byte("null\n")
		var headers map[string][]string
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("Message", resp.Message, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(resp.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	CloneResp: func(resp *EncoreInternal_NineResp) (*EncoreInternal_NineResp, error) {
		if resp == nil {
			return nil, nil
		}
		var clone EncoreInternal_NineResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallNine(ctx context.Context, bar string, baz string) (*ComplexResponse, error) {
	resp, err := EncoreInternal_NineHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_NineReq{bar, baz})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_OneReq struct{}

type EncoreInternal_OneResp = __api.Void

var EncoreInternal_OneHandler = &__api.Desc[*EncoreInternal_OneReq, EncoreInternal_OneResp]{
	Service:        "svc",
	Endpoint:       "One",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/svc.One",
	RawPath:        "/svc.One",
	PathParamNames: nil,
	DefLoc:         31,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_OneReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_OneReq{}
		return reqData, nil, nil
	},
	CloneReq: func(p *EncoreInternal_OneReq) (*EncoreInternal_OneReq, error) {
		var clone EncoreInternal_OneReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_OneReq) (string, __api.UnnamedParams, error) {

		return "/svc.One", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_OneReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_OneReq) (EncoreInternal_OneResp, error) {
		err := One(ctx)
		if err != nil {
			return EncoreInternal_OneResp{}, err
		}
		return EncoreInternal_OneResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_OneResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallOne(ctx context.Context) error {
	_, err := EncoreInternal_OneHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_OneReq{})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_QueryReq struct {
	Params *QueryParams
}

type EncoreInternal_QueryResp = QueryParams

var EncoreInternal_QueryHandler = &__api.Desc[*EncoreInternal_QueryReq, *EncoreInternal_QueryResp]{
	Service:        "svc",
	Endpoint:       "Query",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/query",
	RawPath:        "/query",
	PathParamNames: nil,
	DefLoc:         32,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_QueryReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_QueryReq{}
		dec := &etype.Marshaller{}

		params := &QueryParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Time = dec.ToTime("time", qs.Get("time"), false)
			params.UID = dec.ToUserID("uid", qs.Get("uid"), false)
			params.JSON = dec.ToJSON("json", qs.Get("json"), false)
			params.Float32 = dec.ToFloat32("float32", qs.Get("float32"), false)
			params.Float64 = dec.ToFloat64("float64", qs.Get("float64"), false)
			params.Strings = dec.ToStringList("strings", qs["strings"], false)
			params.Times = dec.ToTimeList("times", qs["times"], false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "time":
					dec.ParseJSON("Time", iter, &params.Time)
				case "uid":
					dec.ParseJSON("UID", iter, &params.UID)
				case "json":
					dec.ParseJSON("JSON", iter, &params.JSON)
				case "float32":
					dec.ParseJSON("Float32", iter, &params.Float32)
				case "float64":
					dec.ParseJSON("Float64", iter, &params.Float64)
				case "strings":
					dec.ParseJSON("Strings", iter, &params.Strings)
				case "times":
					dec.ParseJSON("Times", iter, &params.Times)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_QueryReq) (*EncoreInternal_QueryReq, error) {
		var clone EncoreInternal_QueryReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_QueryReq) (string, __api.UnnamedParams, error) {

		return "/query", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_QueryReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_QueryReq) (*EncoreInternal_QueryResp, error) {
		resp, err := Query(ctx, req.Params)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_QueryResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("Time", resp.Time, false)
				ser.WriteField("UID", resp.UID, false)
				ser.WriteField("JSON", resp.JSON, false)
				ser.WriteField("Float32", resp.Float32, false)
				ser.WriteField("Float64", resp.Float64, false)
				ser.WriteField("Strings", resp.Strings, false)
				ser.WriteField("Times", resp.Times, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	CloneResp: func(resp *EncoreInternal_QueryResp) (*EncoreInternal_QueryResp, error) {
		if resp == nil {
			return nil, nil
		}
		var clone EncoreInternal_QueryResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallQuery(ctx context.Context, params *QueryParams) (*QueryParams, error) {
	resp, err := EncoreInternal_QueryHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_QueryReq{params})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_SevenReq struct{}

type EncoreInternal_SevenResp = __api.Void

var EncoreInternal_SevenHandler = &__api.Desc[*EncoreInternal_SevenReq, EncoreInternal_SevenResp]{
	Service:        "svc",
	Endpoint:       "Seven",
	Methods:        []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Raw:            true,
	Path:           "/foo/:bar/:baz",
	RawPath:        "/foo/:0/:1",
	PathParamNames: []string{"bar", "baz"},
	DefLoc:         33,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_SevenReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_SevenReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		_ = dec.ToString("bar", ps[0], true)

		if value, err := url.PathUnescape(ps[1]); err == nil {
			ps[1] = value
		}

		_ = dec.ToString("baz", ps[1], true)
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_SevenReq) (*EncoreInternal_SevenReq, error) {
		var clone EncoreInternal_SevenReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_SevenReq) (string, __api.UnnamedParams, error) {

		return "/foo/:bar/:baz", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_SevenReq) any {
		return nil
	},
	AppHandler: nil,
	RawHandler: func(w http.ResponseWriter, req *http.Request) {
		Seven(w, req)
	},
	EncodeResp: nil,
	CloneResp:  __api.CloneVoid,
}

type EncoreInternal_SixReq struct {
	Id     uuid.UUID
	Key    string
	Params *FooParams
}

type EncoreInternal_SixResp = __api.Void

var EncoreInternal_SixHandler = &__api.Desc[*EncoreInternal_SixReq, EncoreInternal_SixResp]{
	Service:        "svc",
	Endpoint:       "Six",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/six/:id/*key",
	RawPath:        "/six/:0/*1",
	PathParamNames: []string{"id", "key"},
	DefLoc:         34,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_SixReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_SixReq{}
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[1] = strings.TrimPrefix(ps[1], "/")

		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		reqData.Id = dec.ToUUID("id", ps[0], true)

		if value, err := url.PathUnescape(ps[1]); err == nil {
			ps[1] = value
		}

		reqData.Key = dec.ToString("key", ps[1], true)

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "GET":
			// Decode query string
			qs := req.URL.Query()
			params.Name = dec.ToString("name", qs.Get("name"), false)

		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_SixReq) (*EncoreInternal_SixReq, error) {
		var clone EncoreInternal_SixReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_SixReq) (string, __api.UnnamedParams, error) {
		enc := &etype.Marshaller{}

		params := __api.UnnamedParams{enc.FromUUID(p.Id), enc.FromString(p.Key)}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/six" + "/" + params[0] + "/" + params[1], params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_SixReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_SixReq) (EncoreInternal_SixResp, error) {
		err := Six(ctx, req.Id, req.Key, req.Params)
		if err != nil {
			return EncoreInternal_SixResp{}, err
		}
		return EncoreInternal_SixResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_SixResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallSix(ctx context.Context, id uuid.UUID, key string, params *FooParams) error {
	_, err := EncoreInternal_SixHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_SixReq{id, key, params})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_TenReq struct{}

type EncoreInternal_TenResp = HeaderResponse

var EncoreInternal_TenHandler = &__api.Desc[*EncoreInternal_TenReq, *EncoreInternal_TenResp]{
	Service:        "svc",
	Endpoint:       "Ten",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/ten",
	RawPath:        "/ten",
	PathParamNames: nil,
	DefLoc:         35,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_TenReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_TenReq{}
		return reqData, nil, nil
	},
	CloneReq: func(p *EncoreInternal_TenReq) (*EncoreInternal_TenReq, error) {
		var clone EncoreInternal_TenReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_TenReq) (string, __api.UnnamedParams, error) {

		return "/ten", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_TenReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_TenReq) (*EncoreInternal_TenResp, error) {
		resp, err := Ten(ctx)
		if err != nil {
			return nil, err
		}
		return resp, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp *EncoreInternal_TenResp) (err error) {
		respData := []byte{'\n'}
		var headers map[string][]string
		if resp != nil {

			// Encode headers
			headerEncoder := &etype.Marshaller{}
			headers = map[string][]string{"x-header": {headerEncoder.FromString(resp.Header)}}
			if headerEncoder.LastError != nil {
				return headerEncoder.LastError
			}

		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	CloneResp: func(resp *EncoreInternal_TenResp) (*EncoreInternal_TenResp, error) {
		if resp == nil {
			return nil, nil
		}
		var clone EncoreInternal_TenResp
		bytes, err := jsoniter.ConfigDefault.Marshal(resp)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
}

func EncoreInternal_CallTen(ctx context.Context) (*HeaderResponse, error) {
	resp, err := EncoreInternal_TenHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_TenReq{})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type EncoreInternal_ThreeReq struct {
	Id string
}

type EncoreInternal_ThreeResp = __api.Void

var EncoreInternal_ThreeHandler = &__api.Desc[*EncoreInternal_ThreeReq, EncoreInternal_ThreeResp]{
	Service:        "svc",
	Endpoint:       "Three",
	Methods:        []string{"GET", "POST"},
	Raw:            false,
	Path:           "/three/:id",
	RawPath:        "/three/:0",
	PathParamNames: []string{"id"},
	DefLoc:         36,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_ThreeReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_ThreeReq{}
		dec := &etype.Marshaller{}

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}

		reqData.Id = dec.ToString("id", ps[0], true)
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_ThreeReq) (*EncoreInternal_ThreeReq, error) {
		var clone EncoreInternal_ThreeReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_ThreeReq) (string, __api.UnnamedParams, error) {
		enc := &etype.Marshaller{}

		params := __api.UnnamedParams{enc.FromString(p.Id)}
		if enc.LastError != nil {

			return "", nil, enc.LastError
		}

		return "/three" + "/" + params[0], params, nil
	},
	ReqUserPayload: func(p *EncoreInternal_ThreeReq) any {
		return nil
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_ThreeReq) (EncoreInternal_ThreeResp, error) {
		err := Three(ctx, req.Id)
		if err != nil {
			return EncoreInternal_ThreeResp{}, err
		}
		return EncoreInternal_ThreeResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_ThreeResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallThree(ctx context.Context, id string) error {
	_, err := EncoreInternal_ThreeHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_ThreeReq{id})
	if err != nil {
		return err
	}
	return nil
}

type EncoreInternal_TwoReq struct {
	Params *FooParams
}

type EncoreInternal_TwoResp = __api.Void

var EncoreInternal_TwoHandler = &__api.Desc[*EncoreInternal_TwoReq, EncoreInternal_TwoResp]{
	Service:        "svc",
	Endpoint:       "Two",
	Methods:        []string{"POST"},
	Raw:            false,
	Path:           "/svc.Two",
	RawPath:        "/svc.Two",
	PathParamNames: nil,
	DefLoc:         37,
	Access:         __api.Public,
	DecodeReq: func(req *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_TwoReq, pathParams __api.UnnamedParams, err error) {
		reqData = &EncoreInternal_TwoReq{}
		dec := &etype.Marshaller{}

		params := &FooParams{}

		reqData.Params = params

		switch m := req.Method; m {
		case "POST":
			// Decode JSON body
			payload := dec.Body(req.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "name":
					dec.ParseJSON("Name", iter, &params.Name)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if dec.LastError != nil {

			return nil, nil, dec.LastError
		}

		return reqData, ps, nil
	},
	CloneReq: func(p *EncoreInternal_TwoReq) (*EncoreInternal_TwoReq, error) {
		var clone EncoreInternal_TwoReq
		bytes, err := jsoniter.ConfigDefault.Marshal(p)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return &clone, err
	},
	ReqPath: func(p *EncoreInternal_TwoReq) (string, __api.UnnamedParams, error) {

		return "/svc.Two", nil, nil
	},
	ReqUserPayload: func(p *EncoreInternal_TwoReq) any {
		return p.Params
	},
	AppHandler: func(ctx context.Context, req *EncoreInternal_TwoReq) (EncoreInternal_TwoResp, error) {
		err := Two(ctx, req.Params)
		if err != nil {
			return EncoreInternal_TwoResp{}, err
		}
		return EncoreInternal_TwoResp{}, nil
	},
	RawHandler: nil,
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_TwoResp) (err error) {
		return nil
	},
	CloneResp: __api.CloneVoid,
}

func EncoreInternal_CallTwo(ctx context.Context, params *FooParams) error {
	_, err := EncoreInternal_TwoHandler.Call(__api.NewCallContext(ctx), &EncoreInternal_TwoReq{params})
	if err != nil {
		return err
	}
	return nil
}

func EncoreInternal_stringsKeyMapper(key int) string {
	return fmt.Sprintf("foo/%v", key)
}

type EncoreInternal_AuthHandlerAuthParams = AuthParams

var EncoreInternal_AuthHandlerAuthHandler = &__api.AuthHandlerDesc[*EncoreInternal_AuthHandlerAuthParams]{
	Service:     "svc",
	Endpoint:    "AuthHandler",
	DefLoc:      39,
	HasAuthData: true,
	DecodeAuth: func(req *http.Request) (params *EncoreInternal_AuthHandlerAuthParams, err error) {
		params = &EncoreInternal_AuthHandlerAuthParams{}
		dec := &etype.Marshaller{}
		// Decode headers
		h := req.Header
		params.Header1 = dec.ToString("one", h.Get("one"), false)
		params.Header2 = dec.ToInt("two", h.Get("two"), false)
		params.Header3 = dec.ToUint("three", h.Get("three"), false)

		// Decode query string
		qs := req.URL.Query()
		params.Query1 = dec.ToString("one", qs.Get("one"), false)
		params.Query2 = dec.ToStringList("two", qs["two"], false)
		params.Query3 = dec.ToTime("three", qs.Get("three"), false)

		if dec.LastError != nil {
			return nil, errs.B().Code(errs.InvalidArgument).Msgf("invalid auth param: %v", dec.LastError).Err()
		}
		if dec.NonEmptyValues == 0 {
			return nil, errs.B().Code(errs.Unauthenticated).Msg("missing auth param").Err()
		}
		return params, nil
	},
	AuthHandler: func(ctx context.Context, params *EncoreInternal_AuthHandlerAuthParams) (info __model.AuthInfo, err error) {
		info.UID, info.UserData, err = AuthHandler(ctx, params)
		return info, err
	},
}


// encore.gen.go for service svc
// Code generated by encore. DO NOT EDIT.

package svc

import (
	"context"
	"errors"
	"net/http"
)

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func DI(ctx context.Context) error {
	svc, err := EncoreInternal_ServiceService.Get()
	if err != nil {
		return err
	}
	return svc.DI(ctx)
}

func DIRaw(ctx context.Context, req *http.Request) (*http.Response, error) {
	return nil, errors.New("encore: calling raw endpoints is not yet supported")
}


// config unmarshallers for service svc
package svc

import (
	"encoding/json"
	etype "encore.app/__encore/etype"
	config "encore.dev/config"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"strconv"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_Cfg                = encoreInternalTypeConfigUnmarshaler_Cfg
	encoreInternalConfigUnmarshaler_ptr_Optional_bool_ = func(itr *jsoniter.Iterator, path []string) *Optional[bool] {
		return func() *Optional[bool] {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_Optional[bool](func(itr *jsoniter.Iterator, path []string) bool {
				return itr.ReadBool()
			})(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_FooParams will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_FooParams(itr *jsoniter.Iterator, path []string) (obj FooParams) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Name":
			obj.Name = itr.ReadString()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_Cfg will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_Cfg(itr *jsoniter.Iterator, path []string) (obj Cfg) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "DefaultFooParams":
			obj.DefaultFooParams = config.CreateValue[FooParams](encoreInternalTypeConfigUnmarshaler_FooParams(itr, append(path, "DefaultFooParams")), append(path, "DefaultFooParams"))
		case "ReadOnly":
			obj.ReadOnly = config.CreateValue[bool](itr.ReadBool(), append(path, "ReadOnly"))
		case "MagicNumber":
			obj.MagicNumber = itr.ReadInt()
		case "Sub":
			obj.Sub = encoreInternalTypeConfigUnmarshaler_SubType[Optional[string]](encoreInternalTypeConfigUnmarshaler_Optional[string](func(itr *jsoniter.Iterator, path []string) string {
				return itr.ReadString()
			}))(itr, append(path, "Sub"))
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_SubType will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_SubType[T any](_T_unmarshaler config.Unmarshaler[T]) (concreteUnmarshaler config.Unmarshaler[SubType[T]]) {
	return func(itr *jsoniter.Iterator, path []string) (obj SubType[T]) {
		itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
			switch field {
			case "FieldA":
				obj.FieldA = config.CreateValue[string](itr.ReadString(), append(path, "FieldA"))
			case "FieldB":
				obj.FieldB = config.CreateValue[[]string](config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {
					return itr.ReadString()
				}), append(path, "FieldB"))
			case "FieldC":
				obj.FieldC = config.ReadArray[config.Value[int]](itr, func(itr *jsoniter.Iterator, idx int) config.Value[int] {
					return config.CreateValue[int](itr.ReadInt(), append(path, strconv.Itoa(idx)))
				})
			case "FieldD":
				obj.FieldD = config.ReadMap[int, config.Value[string]](itr, func(itr *jsoniter.Iterator, keyAsString string) (int, config.Value[string]) {
					// Decode the map key from the JSON string to the underlying type it needs to be
					keyDecoder := &etype.Marshaller{}
					key := keyDecoder.ToInt("keyAsString", keyAsString, true)
					if keyDecoder.LastError != nil {
						panic(fmt.Sprintf("unable to decode the config: %v", keyDecoder.LastError))
					}

					return key, config.CreateValue[string](itr.ReadString(), append(path, keyAsString))
				})
			case "FieldE":
				obj.FieldE = func() (obj struct {
					SubA config.Value[string]
					SubB FooParams
					Blah config.Value[T]
					Foo  []byte
					Json json.RawMessage
				}) {
					itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
						switch field {
						case "SubA":
							obj.SubA = config.CreateValue[string](itr.ReadString(), append(path, "SubA"))
						case "SubB":
							obj.SubB = encoreInternalTypeConfigUnmarshaler_FooParams(itr, append(path, "SubB"))
						case "Blah":
							obj.Blah = config.CreateValue[T](_T_unmarshaler(itr, append(path, "Blah")), append(path, "Blah"))
						case "Foo":
							obj.Foo = func() (rtn []byte) {
								decoder := &etype.Marshaller{}

								rtn = decoder.ToBytes("value", itr.ReadString(), true)

								if decoder.LastError != nil {
									panic(fmt.Sprintf("unable to decode the config: %v", decoder.LastError))
								}

								return
							}()
						case "Json":
							obj.Json = func() (rtn json.RawMessage) {
								decoder := &etype.Marshaller{}

								rtn = decoder.ToJSON("value", itr.ReadString(), true)

								if decoder.LastError != nil {
									panic(fmt.Sprintf("unable to decode the config: %v", decoder.LastError))
								}

								return
							}()
						}
						return true
					})
					return
				}()
			}
			return true
		})
		return
	}
}

// encoreInternalTypeConfigUnmarshaler_Optional will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_Optional[T any](_T_unmarshaler config.Unmarshaler[T]) (concreteUnmarshaler config.Unmarshaler[Optional[T]]) {
	return func(itr *jsoniter.Iterator, path []string) (obj Optional[T]) {
		itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
			switch field {
			case "Wrapped":
				obj.Wrapped = _T_unmarshaler(itr, append(path, "Wrapped"))
			case "Present":
				obj.Present = itr.ReadBool()
			}
			return true
		})
		return
	}
}
// etype package
package etype

import (
	"encoding/base64"
	stdjson "encoding/json"
	_ "encore.dev/appruntime/app/appinit"
	auth "encore.dev/beta/auth"
	uuid "encore.dev/types/uuid"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"io"
	"io/ioutil"
	"strconv"
	"time"
)

// Marshaller is used to serialize request data into strings and deserialize response data from strings
type Marshaller struct {
	LastError      error // The last error that occurred
	NonEmptyValues int   // The number of values this decoder has decoded
}

func (e *Marshaller) ToString(field string, s string, required bool) (v string) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) FromString(s string) (v string) {
	e.NonEmptyValues++
	return s
}

func (e *Marshaller) ToUUID(field string, s string, required bool) (v uuid.UUID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := uuid.FromString(s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUint(field string, s string, required bool) (v uint) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseUint(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return uint(x)
}

func (e *Marshaller) FromUUID(s uuid.UUID) (v string) {
	e.NonEmptyValues++
	return s.String()
}

func (e *Marshaller) FromUint(s uint) (v string) {
	e.NonEmptyValues++
	return strconv.FormatUint(uint64(s), 10)
}

func (e *Marshaller) ToTime(field string, s string, required bool) (v time.Time) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := time.Parse(time.RFC3339, s)
	e.setErr("invalid parameter", field, err)
	return v
}

func (e *Marshaller) ToUserID(field string, s string, required bool) (v auth.UID) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return auth.UID(s)
}

func (e *Marshaller) ToJSON(field string, s string, required bool) (v stdjson.RawMessage) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	return stdjson.RawMessage(s)
}

func (e *Marshaller) ToFloat32(field string, s string, required bool) (v float32) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 32)
	e.setErr("invalid parameter", field, err)
	return float32(x)
}

func (e *Marshaller) ToFloat64(field string, s string, required bool) (v float64) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseFloat(s, 64)
	e.setErr("invalid parameter", field, err)
	return x
}

func (e *Marshaller) ToStringList(field string, s []string, required bool) (v []string) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToString(field, x, required))
	}
	return v
}

func (e *Marshaller) ToTimeList(field string, s []string, required bool) (v []time.Time) {
	if !required && len(s) == 0 {
		return
	}
	e.NonEmptyValues++
	for _, x := range s {
		v = append(v, e.ToTime(field, x, required))
	}
	return v
}

func (e *Marshaller) ToInt(field string, s string, required bool) (v int) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	x, err := strconv.ParseInt(s, 10, 64)
	e.setErr("invalid parameter", field, err)
	return int(x)
}

func (e *Marshaller) ToBytes(field string, s string, required bool) (v []byte) {
	if !required && s == "" {
		return
	}
	e.NonEmptyValues++
	v, err := base64.URLEncoding.DecodeString(s)
	e.setErr("invalid parameter", field, err)
	return v
}

// setErr sets the last error within the object if one is not already set
func (e *Marshaller) setErr(msg, field string, err error) {
	if err != nil && e.LastError == nil {
		e.LastError = fmt.Errorf("%s: %s: %w", field, msg, err)
	}
}

func (d *Marshaller) Body(body io.Reader) (payload []byte) {
	payload, err := ioutil.ReadAll(body)
	if err == nil && len(payload) == 0 {
		d.setErr("missing request body", "request_body", fmt.Errorf("missing request body"))
	} else if err != nil {
		d.setErr("could not parse request body", "request_body", err)
	}
	return payload
}
func (d *Marshaller) ParseJSON(field string, iter *jsoniter.Iterator, dst interface{}) {
	iter.ReadVal(dst)
	d.setErr("invalid json parameter", field, iter.Error)
}
