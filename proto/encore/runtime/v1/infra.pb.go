// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: encore/runtime/v1/infra.proto

package runtimev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ServerKind int32

const (
	ServerKind_SERVER_KIND_UNSPECIFIED ServerKind = 0
	ServerKind_SERVER_KIND_PRIMARY     ServerKind = 1
	// A hot-standby (a read replica designed to take over write traffic
	// at a moment's notice).
	ServerKind_SERVER_KIND_HOT_STANDBY ServerKind = 2
	// A read-replica.
	ServerKind_SERVER_KIND_READ_REPLICA ServerKind = 3
)

// Enum value maps for ServerKind.
var (
	ServerKind_name = map[int32]string{
		0: "SERVER_KIND_UNSPECIFIED",
		1: "SERVER_KIND_PRIMARY",
		2: "SERVER_KIND_HOT_STANDBY",
		3: "SERVER_KIND_READ_REPLICA",
	}
	ServerKind_value = map[string]int32{
		"SERVER_KIND_UNSPECIFIED":  0,
		"SERVER_KIND_PRIMARY":      1,
		"SERVER_KIND_HOT_STANDBY":  2,
		"SERVER_KIND_READ_REPLICA": 3,
	}
)

func (x ServerKind) Enum() *ServerKind {
	p := new(ServerKind)
	*p = x
	return p
}

func (x ServerKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ServerKind) Descriptor() protoreflect.EnumDescriptor {
	return file_encore_runtime_v1_infra_proto_enumTypes[0].Descriptor()
}

func (ServerKind) Type() protoreflect.EnumType {
	return &file_encore_runtime_v1_infra_proto_enumTypes[0]
}

func (x ServerKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ServerKind.Descriptor instead.
func (ServerKind) EnumDescriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{0}
}

type PubSubTopic_DeliveryGuarantee int32

const (
	PubSubTopic_DELIVERY_GUARANTEE_UNSPECIFIED   PubSubTopic_DeliveryGuarantee = 0
	PubSubTopic_DELIVERY_GUARANTEE_AT_LEAST_ONCE PubSubTopic_DeliveryGuarantee = 1 // All messages will be delivered to each subscription at least once
	PubSubTopic_DELIVERY_GUARANTEE_EXACTLY_ONCE  PubSubTopic_DeliveryGuarantee = 2 // All messages will be delivered to each subscription exactly once
)

// Enum value maps for PubSubTopic_DeliveryGuarantee.
var (
	PubSubTopic_DeliveryGuarantee_name = map[int32]string{
		0: "DELIVERY_GUARANTEE_UNSPECIFIED",
		1: "DELIVERY_GUARANTEE_AT_LEAST_ONCE",
		2: "DELIVERY_GUARANTEE_EXACTLY_ONCE",
	}
	PubSubTopic_DeliveryGuarantee_value = map[string]int32{
		"DELIVERY_GUARANTEE_UNSPECIFIED":   0,
		"DELIVERY_GUARANTEE_AT_LEAST_ONCE": 1,
		"DELIVERY_GUARANTEE_EXACTLY_ONCE":  2,
	}
)

func (x PubSubTopic_DeliveryGuarantee) Enum() *PubSubTopic_DeliveryGuarantee {
	p := new(PubSubTopic_DeliveryGuarantee)
	*p = x
	return p
}

func (x PubSubTopic_DeliveryGuarantee) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PubSubTopic_DeliveryGuarantee) Descriptor() protoreflect.EnumDescriptor {
	return file_encore_runtime_v1_infra_proto_enumTypes[1].Descriptor()
}

func (PubSubTopic_DeliveryGuarantee) Type() protoreflect.EnumType {
	return &file_encore_runtime_v1_infra_proto_enumTypes[1]
}

func (x PubSubTopic_DeliveryGuarantee) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PubSubTopic_DeliveryGuarantee.Descriptor instead.
func (PubSubTopic_DeliveryGuarantee) EnumDescriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{15, 0}
}

type Infrastructure struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	Resources     *Infrastructure_Resources   `protobuf:"bytes,1,opt,name=resources,proto3" json:"resources,omitempty"`
	Credentials   *Infrastructure_Credentials `protobuf:"bytes,2,opt,name=credentials,proto3" json:"credentials,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Infrastructure) Reset() {
	*x = Infrastructure{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Infrastructure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Infrastructure) ProtoMessage() {}

func (x *Infrastructure) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Infrastructure.ProtoReflect.Descriptor instead.
func (*Infrastructure) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{0}
}

func (x *Infrastructure) GetResources() *Infrastructure_Resources {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *Infrastructure) GetCredentials() *Infrastructure_Credentials {
	if x != nil {
		return x.Credentials
	}
	return nil
}

type SQLCluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this cluster.
	Rid           string         `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Servers       []*SQLServer   `protobuf:"bytes,2,rep,name=servers,proto3" json:"servers,omitempty"`
	Databases     []*SQLDatabase `protobuf:"bytes,3,rep,name=databases,proto3" json:"databases,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SQLCluster) Reset() {
	*x = SQLCluster{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SQLCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SQLCluster) ProtoMessage() {}

func (x *SQLCluster) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SQLCluster.ProtoReflect.Descriptor instead.
func (*SQLCluster) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{1}
}

func (x *SQLCluster) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *SQLCluster) GetServers() []*SQLServer {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *SQLCluster) GetDatabases() []*SQLDatabase {
	if x != nil {
		return x.Databases
	}
	return nil
}

type TLSConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server CA Cert PEM to use for verifying the server's certificate.
	ServerCaCert *string `protobuf:"bytes,1,opt,name=server_ca_cert,json=serverCaCert,proto3,oneof" json:"server_ca_cert,omitempty"`
	// If true, skips hostname verification when connecting.
	// If invalid hostnames are trusted, *any* valid certificate for *any* site will be trusted for use.
	// This introduces significant vulnerabilities, and should only be used as a last resort.
	DisableTlsHostnameVerification bool `protobuf:"varint,2,opt,name=disable_tls_hostname_verification,json=disableTlsHostnameVerification,proto3" json:"disable_tls_hostname_verification,omitempty"`
	// If true, skips CA cert validation when connecting.
	// This introduces significant vulnerabilities, and should only be used as a last resort.
	DisableCaValidation bool `protobuf:"varint,3,opt,name=disable_ca_validation,json=disableCaValidation,proto3" json:"disable_ca_validation,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *TLSConfig) Reset() {
	*x = TLSConfig{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSConfig) ProtoMessage() {}

func (x *TLSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TLSConfig.ProtoReflect.Descriptor instead.
func (*TLSConfig) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{2}
}

func (x *TLSConfig) GetServerCaCert() string {
	if x != nil && x.ServerCaCert != nil {
		return *x.ServerCaCert
	}
	return ""
}

func (x *TLSConfig) GetDisableTlsHostnameVerification() bool {
	if x != nil {
		return x.DisableTlsHostnameVerification
	}
	return false
}

func (x *TLSConfig) GetDisableCaValidation() bool {
	if x != nil {
		return x.DisableCaValidation
	}
	return false
}

type SQLServer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this server.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// Host is the host to connect to.
	// Valid formats are "hostname", "hostname:port", and "/path/to/unix.socket".
	Host string     `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Kind ServerKind `protobuf:"varint,3,opt,name=kind,proto3,enum=encore.runtime.v1.ServerKind" json:"kind,omitempty"`
	// TLS configuration to use when connecting.
	TlsConfig     *TLSConfig `protobuf:"bytes,4,opt,name=tls_config,json=tlsConfig,proto3,oneof" json:"tls_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SQLServer) Reset() {
	*x = SQLServer{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SQLServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SQLServer) ProtoMessage() {}

func (x *SQLServer) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SQLServer.ProtoReflect.Descriptor instead.
func (*SQLServer) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{3}
}

func (x *SQLServer) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *SQLServer) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *SQLServer) GetKind() ServerKind {
	if x != nil {
		return x.Kind
	}
	return ServerKind_SERVER_KIND_UNSPECIFIED
}

func (x *SQLServer) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

type ClientCert struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this certificate.
	Rid           string      `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Cert          string      `protobuf:"bytes,2,opt,name=cert,proto3" json:"cert,omitempty"`
	Key           *SecretData `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientCert) Reset() {
	*x = ClientCert{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientCert) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientCert) ProtoMessage() {}

func (x *ClientCert) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientCert.ProtoReflect.Descriptor instead.
func (*ClientCert) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{4}
}

func (x *ClientCert) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *ClientCert) GetCert() string {
	if x != nil {
		return x.Cert
	}
	return ""
}

func (x *ClientCert) GetKey() *SecretData {
	if x != nil {
		return x.Key
	}
	return nil
}

type SQLRole struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this role.
	Rid      string      `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Username string      `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password *SecretData `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// The client cert to use to authenticate, if any.
	ClientCertRid *string `protobuf:"bytes,4,opt,name=client_cert_rid,json=clientCertRid,proto3,oneof" json:"client_cert_rid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SQLRole) Reset() {
	*x = SQLRole{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SQLRole) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SQLRole) ProtoMessage() {}

func (x *SQLRole) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SQLRole.ProtoReflect.Descriptor instead.
func (*SQLRole) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{5}
}

func (x *SQLRole) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *SQLRole) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *SQLRole) GetPassword() *SecretData {
	if x != nil {
		return x.Password
	}
	return nil
}

func (x *SQLRole) GetClientCertRid() string {
	if x != nil && x.ClientCertRid != nil {
		return *x.ClientCertRid
	}
	return ""
}

type SQLDatabase struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this database.
	Rid        string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	EncoreName string `protobuf:"bytes,2,opt,name=encore_name,json=encoreName,proto3" json:"encore_name,omitempty"`
	// The physical name of the database in the cluster.
	CloudName string `protobuf:"bytes,3,opt,name=cloud_name,json=cloudName,proto3" json:"cloud_name,omitempty"`
	// Connection pools to use for connecting to the database.
	ConnPools     []*SQLConnectionPool `protobuf:"bytes,4,rep,name=conn_pools,json=connPools,proto3" json:"conn_pools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SQLDatabase) Reset() {
	*x = SQLDatabase{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SQLDatabase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SQLDatabase) ProtoMessage() {}

func (x *SQLDatabase) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SQLDatabase.ProtoReflect.Descriptor instead.
func (*SQLDatabase) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{6}
}

func (x *SQLDatabase) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *SQLDatabase) GetEncoreName() string {
	if x != nil {
		return x.EncoreName
	}
	return ""
}

func (x *SQLDatabase) GetCloudName() string {
	if x != nil {
		return x.CloudName
	}
	return ""
}

func (x *SQLDatabase) GetConnPools() []*SQLConnectionPool {
	if x != nil {
		return x.ConnPools
	}
	return nil
}

type SQLConnectionPool struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether this connection pool is for read-only servers.
	IsReadonly bool `protobuf:"varint,1,opt,name=is_readonly,json=isReadonly,proto3" json:"is_readonly,omitempty"`
	// The role to use to authenticate.
	RoleRid string `protobuf:"bytes,2,opt,name=role_rid,json=roleRid,proto3" json:"role_rid,omitempty"`
	// The minimum and maximum number of connections to use.
	MinConnections int32 `protobuf:"varint,3,opt,name=min_connections,json=minConnections,proto3" json:"min_connections,omitempty"`
	MaxConnections int32 `protobuf:"varint,4,opt,name=max_connections,json=maxConnections,proto3" json:"max_connections,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SQLConnectionPool) Reset() {
	*x = SQLConnectionPool{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SQLConnectionPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SQLConnectionPool) ProtoMessage() {}

func (x *SQLConnectionPool) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SQLConnectionPool.ProtoReflect.Descriptor instead.
func (*SQLConnectionPool) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{7}
}

func (x *SQLConnectionPool) GetIsReadonly() bool {
	if x != nil {
		return x.IsReadonly
	}
	return false
}

func (x *SQLConnectionPool) GetRoleRid() string {
	if x != nil {
		return x.RoleRid
	}
	return ""
}

func (x *SQLConnectionPool) GetMinConnections() int32 {
	if x != nil {
		return x.MinConnections
	}
	return 0
}

func (x *SQLConnectionPool) GetMaxConnections() int32 {
	if x != nil {
		return x.MaxConnections
	}
	return 0
}

type RedisCluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this cluster.
	Rid           string           `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Servers       []*RedisServer   `protobuf:"bytes,2,rep,name=servers,proto3" json:"servers,omitempty"`
	Databases     []*RedisDatabase `protobuf:"bytes,3,rep,name=databases,proto3" json:"databases,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisCluster) Reset() {
	*x = RedisCluster{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisCluster) ProtoMessage() {}

func (x *RedisCluster) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisCluster.ProtoReflect.Descriptor instead.
func (*RedisCluster) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{8}
}

func (x *RedisCluster) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *RedisCluster) GetServers() []*RedisServer {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *RedisCluster) GetDatabases() []*RedisDatabase {
	if x != nil {
		return x.Databases
	}
	return nil
}

type RedisServer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this server.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// Host is the host to connect to.
	// Valid formats are "hostname", "hostname:port", and "/path/to/unix.socket".
	Host string     `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Kind ServerKind `protobuf:"varint,3,opt,name=kind,proto3,enum=encore.runtime.v1.ServerKind" json:"kind,omitempty"`
	// TLS configuration to use when connecting.
	// If nil, TLS is not used.
	TlsConfig     *TLSConfig `protobuf:"bytes,4,opt,name=tls_config,json=tlsConfig,proto3,oneof" json:"tls_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisServer) Reset() {
	*x = RedisServer{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisServer) ProtoMessage() {}

func (x *RedisServer) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisServer.ProtoReflect.Descriptor instead.
func (*RedisServer) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{9}
}

func (x *RedisServer) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *RedisServer) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *RedisServer) GetKind() ServerKind {
	if x != nil {
		return x.Kind
	}
	return ServerKind_SERVER_KIND_UNSPECIFIED
}

func (x *RedisServer) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

type RedisConnectionPool struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether this connection pool is for read-only servers.
	IsReadonly bool `protobuf:"varint,1,opt,name=is_readonly,json=isReadonly,proto3" json:"is_readonly,omitempty"`
	// The role to use to authenticate.
	RoleRid string `protobuf:"bytes,2,opt,name=role_rid,json=roleRid,proto3" json:"role_rid,omitempty"`
	// The minimum and maximum number of connections to use.
	MinConnections int32 `protobuf:"varint,3,opt,name=min_connections,json=minConnections,proto3" json:"min_connections,omitempty"`
	MaxConnections int32 `protobuf:"varint,4,opt,name=max_connections,json=maxConnections,proto3" json:"max_connections,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RedisConnectionPool) Reset() {
	*x = RedisConnectionPool{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisConnectionPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisConnectionPool) ProtoMessage() {}

func (x *RedisConnectionPool) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisConnectionPool.ProtoReflect.Descriptor instead.
func (*RedisConnectionPool) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{10}
}

func (x *RedisConnectionPool) GetIsReadonly() bool {
	if x != nil {
		return x.IsReadonly
	}
	return false
}

func (x *RedisConnectionPool) GetRoleRid() string {
	if x != nil {
		return x.RoleRid
	}
	return ""
}

func (x *RedisConnectionPool) GetMinConnections() int32 {
	if x != nil {
		return x.MinConnections
	}
	return 0
}

func (x *RedisConnectionPool) GetMaxConnections() int32 {
	if x != nil {
		return x.MaxConnections
	}
	return 0
}

type RedisRole struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this role.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The client cert to use to authenticate, if any.
	ClientCertRid *string `protobuf:"bytes,2,opt,name=client_cert_rid,json=clientCertRid,proto3,oneof" json:"client_cert_rid,omitempty"`
	// How to authenticate with Redis.
	// If unset, no authentication is used.
	//
	// Types that are valid to be assigned to Auth:
	//
	//	*RedisRole_Acl
	//	*RedisRole_AuthString
	Auth          isRedisRole_Auth `protobuf_oneof:"auth"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisRole) Reset() {
	*x = RedisRole{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisRole) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisRole) ProtoMessage() {}

func (x *RedisRole) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisRole.ProtoReflect.Descriptor instead.
func (*RedisRole) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{11}
}

func (x *RedisRole) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *RedisRole) GetClientCertRid() string {
	if x != nil && x.ClientCertRid != nil {
		return *x.ClientCertRid
	}
	return ""
}

func (x *RedisRole) GetAuth() isRedisRole_Auth {
	if x != nil {
		return x.Auth
	}
	return nil
}

func (x *RedisRole) GetAcl() *RedisRole_AuthACL {
	if x != nil {
		if x, ok := x.Auth.(*RedisRole_Acl); ok {
			return x.Acl
		}
	}
	return nil
}

func (x *RedisRole) GetAuthString() *SecretData {
	if x != nil {
		if x, ok := x.Auth.(*RedisRole_AuthString); ok {
			return x.AuthString
		}
	}
	return nil
}

type isRedisRole_Auth interface {
	isRedisRole_Auth()
}

type RedisRole_Acl struct {
	Acl *RedisRole_AuthACL `protobuf:"bytes,10,opt,name=acl,proto3,oneof"` // Redis ACL
}

type RedisRole_AuthString struct {
	AuthString *SecretData `protobuf:"bytes,11,opt,name=auth_string,json=authString,proto3,oneof"` // Redis AUTH string
}

func (*RedisRole_Acl) isRedisRole_Auth() {}

func (*RedisRole_AuthString) isRedisRole_Auth() {}

type RedisDatabase struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique resource id for this database.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The encore name of the database.
	EncoreName string `protobuf:"bytes,2,opt,name=encore_name,json=encoreName,proto3" json:"encore_name,omitempty"`
	// The database index to use, [0-15].
	DatabaseIdx int32 `protobuf:"varint,3,opt,name=database_idx,json=databaseIdx,proto3" json:"database_idx,omitempty"`
	// KeyPrefix specifies a prefix to add to all cache keys
	// for this database. It exists to enable multiple cache clusters
	// to use the same physical Redis database for local development
	// without having to coordinate and persist database index ids.
	KeyPrefix *string `protobuf:"bytes,4,opt,name=key_prefix,json=keyPrefix,proto3,oneof" json:"key_prefix,omitempty"`
	// Connection pools to use for connecting to the database.
	ConnPools     []*RedisConnectionPool `protobuf:"bytes,5,rep,name=conn_pools,json=connPools,proto3" json:"conn_pools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisDatabase) Reset() {
	*x = RedisDatabase{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisDatabase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisDatabase) ProtoMessage() {}

func (x *RedisDatabase) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisDatabase.ProtoReflect.Descriptor instead.
func (*RedisDatabase) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{12}
}

func (x *RedisDatabase) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *RedisDatabase) GetEncoreName() string {
	if x != nil {
		return x.EncoreName
	}
	return ""
}

func (x *RedisDatabase) GetDatabaseIdx() int32 {
	if x != nil {
		return x.DatabaseIdx
	}
	return 0
}

func (x *RedisDatabase) GetKeyPrefix() string {
	if x != nil && x.KeyPrefix != nil {
		return *x.KeyPrefix
	}
	return ""
}

func (x *RedisDatabase) GetConnPools() []*RedisConnectionPool {
	if x != nil {
		return x.ConnPools
	}
	return nil
}

type AppSecret struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this secret.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The encore name of the secret.
	EncoreName string `protobuf:"bytes,2,opt,name=encore_name,json=encoreName,proto3" json:"encore_name,omitempty"`
	// The secret data.
	Data          *SecretData `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppSecret) Reset() {
	*x = AppSecret{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppSecret) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppSecret) ProtoMessage() {}

func (x *AppSecret) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppSecret.ProtoReflect.Descriptor instead.
func (*AppSecret) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{13}
}

func (x *AppSecret) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *AppSecret) GetEncoreName() string {
	if x != nil {
		return x.EncoreName
	}
	return ""
}

func (x *AppSecret) GetData() *SecretData {
	if x != nil {
		return x.Data
	}
	return nil
}

type PubSubCluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this cluster.
	Rid           string                `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Topics        []*PubSubTopic        `protobuf:"bytes,2,rep,name=topics,proto3" json:"topics,omitempty"`
	Subscriptions []*PubSubSubscription `protobuf:"bytes,3,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	// Types that are valid to be assigned to Provider:
	//
	//	*PubSubCluster_Encore
	//	*PubSubCluster_Aws
	//	*PubSubCluster_Gcp
	//	*PubSubCluster_Azure
	//	*PubSubCluster_Nsq
	Provider      isPubSubCluster_Provider `protobuf_oneof:"provider"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubCluster) Reset() {
	*x = PubSubCluster{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubCluster) ProtoMessage() {}

func (x *PubSubCluster) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubCluster.ProtoReflect.Descriptor instead.
func (*PubSubCluster) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{14}
}

func (x *PubSubCluster) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *PubSubCluster) GetTopics() []*PubSubTopic {
	if x != nil {
		return x.Topics
	}
	return nil
}

func (x *PubSubCluster) GetSubscriptions() []*PubSubSubscription {
	if x != nil {
		return x.Subscriptions
	}
	return nil
}

func (x *PubSubCluster) GetProvider() isPubSubCluster_Provider {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *PubSubCluster) GetEncore() *PubSubCluster_EncoreCloud {
	if x != nil {
		if x, ok := x.Provider.(*PubSubCluster_Encore); ok {
			return x.Encore
		}
	}
	return nil
}

func (x *PubSubCluster) GetAws() *PubSubCluster_AWSSqsSns {
	if x != nil {
		if x, ok := x.Provider.(*PubSubCluster_Aws); ok {
			return x.Aws
		}
	}
	return nil
}

func (x *PubSubCluster) GetGcp() *PubSubCluster_GCPPubSub {
	if x != nil {
		if x, ok := x.Provider.(*PubSubCluster_Gcp); ok {
			return x.Gcp
		}
	}
	return nil
}

func (x *PubSubCluster) GetAzure() *PubSubCluster_AzureServiceBus {
	if x != nil {
		if x, ok := x.Provider.(*PubSubCluster_Azure); ok {
			return x.Azure
		}
	}
	return nil
}

func (x *PubSubCluster) GetNsq() *PubSubCluster_NSQ {
	if x != nil {
		if x, ok := x.Provider.(*PubSubCluster_Nsq); ok {
			return x.Nsq
		}
	}
	return nil
}

type isPubSubCluster_Provider interface {
	isPubSubCluster_Provider()
}

type PubSubCluster_Encore struct {
	Encore *PubSubCluster_EncoreCloud `protobuf:"bytes,5,opt,name=encore,proto3,oneof"`
}

type PubSubCluster_Aws struct {
	Aws *PubSubCluster_AWSSqsSns `protobuf:"bytes,6,opt,name=aws,proto3,oneof"`
}

type PubSubCluster_Gcp struct {
	Gcp *PubSubCluster_GCPPubSub `protobuf:"bytes,7,opt,name=gcp,proto3,oneof"`
}

type PubSubCluster_Azure struct {
	Azure *PubSubCluster_AzureServiceBus `protobuf:"bytes,8,opt,name=azure,proto3,oneof"`
}

type PubSubCluster_Nsq struct {
	Nsq *PubSubCluster_NSQ `protobuf:"bytes,9,opt,name=nsq,proto3,oneof"`
}

func (*PubSubCluster_Encore) isPubSubCluster_Provider() {}

func (*PubSubCluster_Aws) isPubSubCluster_Provider() {}

func (*PubSubCluster_Gcp) isPubSubCluster_Provider() {}

func (*PubSubCluster_Azure) isPubSubCluster_Provider() {}

func (*PubSubCluster_Nsq) isPubSubCluster_Provider() {}

type PubSubTopic struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this topic.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The encore name of the topic.
	EncoreName string `protobuf:"bytes,2,opt,name=encore_name,json=encoreName,proto3" json:"encore_name,omitempty"`
	// The cloud name of the topic.
	CloudName string `protobuf:"bytes,3,opt,name=cloud_name,json=cloudName,proto3" json:"cloud_name,omitempty"`
	// The delivery guarantee.
	DeliveryGuarantee PubSubTopic_DeliveryGuarantee `protobuf:"varint,4,opt,name=delivery_guarantee,json=deliveryGuarantee,proto3,enum=encore.runtime.v1.PubSubTopic_DeliveryGuarantee" json:"delivery_guarantee,omitempty"`
	// Optional ordering attribute. Specifies the attribute name
	// to use for message ordering.
	OrderingAttr *string `protobuf:"bytes,5,opt,name=ordering_attr,json=orderingAttr,proto3,oneof" json:"ordering_attr,omitempty"`
	// Provider-specific configuration.
	// Not all providers require this, but it must always be set
	// for the providers that are present.
	//
	// Types that are valid to be assigned to ProviderConfig:
	//
	//	*PubSubTopic_GcpConfig
	ProviderConfig isPubSubTopic_ProviderConfig `protobuf_oneof:"provider_config"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PubSubTopic) Reset() {
	*x = PubSubTopic{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubTopic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubTopic) ProtoMessage() {}

func (x *PubSubTopic) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubTopic.ProtoReflect.Descriptor instead.
func (*PubSubTopic) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{15}
}

func (x *PubSubTopic) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *PubSubTopic) GetEncoreName() string {
	if x != nil {
		return x.EncoreName
	}
	return ""
}

func (x *PubSubTopic) GetCloudName() string {
	if x != nil {
		return x.CloudName
	}
	return ""
}

func (x *PubSubTopic) GetDeliveryGuarantee() PubSubTopic_DeliveryGuarantee {
	if x != nil {
		return x.DeliveryGuarantee
	}
	return PubSubTopic_DELIVERY_GUARANTEE_UNSPECIFIED
}

func (x *PubSubTopic) GetOrderingAttr() string {
	if x != nil && x.OrderingAttr != nil {
		return *x.OrderingAttr
	}
	return ""
}

func (x *PubSubTopic) GetProviderConfig() isPubSubTopic_ProviderConfig {
	if x != nil {
		return x.ProviderConfig
	}
	return nil
}

func (x *PubSubTopic) GetGcpConfig() *PubSubTopic_GCPConfig {
	if x != nil {
		if x, ok := x.ProviderConfig.(*PubSubTopic_GcpConfig); ok {
			return x.GcpConfig
		}
	}
	return nil
}

type isPubSubTopic_ProviderConfig interface {
	isPubSubTopic_ProviderConfig()
}

type PubSubTopic_GcpConfig struct {
	GcpConfig *PubSubTopic_GCPConfig `protobuf:"bytes,10,opt,name=gcp_config,json=gcpConfig,proto3,oneof"` // Null: no provider-specific configuration.
}

func (*PubSubTopic_GcpConfig) isPubSubTopic_ProviderConfig() {}

type PubSubSubscription struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this subscription.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The encore name of the topic this subscription is for.
	TopicEncoreName string `protobuf:"bytes,2,opt,name=topic_encore_name,json=topicEncoreName,proto3" json:"topic_encore_name,omitempty"`
	// The encore name of the subscription.
	SubscriptionEncoreName string `protobuf:"bytes,3,opt,name=subscription_encore_name,json=subscriptionEncoreName,proto3" json:"subscription_encore_name,omitempty"`
	// The cloud name of the subscription.
	TopicCloudName string `protobuf:"bytes,4,opt,name=topic_cloud_name,json=topicCloudName,proto3" json:"topic_cloud_name,omitempty"`
	// The cloud name of the subscription.
	SubscriptionCloudName string `protobuf:"bytes,5,opt,name=subscription_cloud_name,json=subscriptionCloudName,proto3" json:"subscription_cloud_name,omitempty"`
	// If true the application will not actively subscribe but wait
	// for incoming messages to be pushed to it.
	PushOnly bool `protobuf:"varint,6,opt,name=push_only,json=pushOnly,proto3" json:"push_only,omitempty"`
	// Subscription-specific provider configuration.
	// Not all providers require this, but it must always be set
	// for the providers that are present.
	//
	// Types that are valid to be assigned to ProviderConfig:
	//
	//	*PubSubSubscription_GcpConfig
	ProviderConfig isPubSubSubscription_ProviderConfig `protobuf_oneof:"provider_config"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PubSubSubscription) Reset() {
	*x = PubSubSubscription{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubSubscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubSubscription) ProtoMessage() {}

func (x *PubSubSubscription) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubSubscription.ProtoReflect.Descriptor instead.
func (*PubSubSubscription) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{16}
}

func (x *PubSubSubscription) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *PubSubSubscription) GetTopicEncoreName() string {
	if x != nil {
		return x.TopicEncoreName
	}
	return ""
}

func (x *PubSubSubscription) GetSubscriptionEncoreName() string {
	if x != nil {
		return x.SubscriptionEncoreName
	}
	return ""
}

func (x *PubSubSubscription) GetTopicCloudName() string {
	if x != nil {
		return x.TopicCloudName
	}
	return ""
}

func (x *PubSubSubscription) GetSubscriptionCloudName() string {
	if x != nil {
		return x.SubscriptionCloudName
	}
	return ""
}

func (x *PubSubSubscription) GetPushOnly() bool {
	if x != nil {
		return x.PushOnly
	}
	return false
}

func (x *PubSubSubscription) GetProviderConfig() isPubSubSubscription_ProviderConfig {
	if x != nil {
		return x.ProviderConfig
	}
	return nil
}

func (x *PubSubSubscription) GetGcpConfig() *PubSubSubscription_GCPConfig {
	if x != nil {
		if x, ok := x.ProviderConfig.(*PubSubSubscription_GcpConfig); ok {
			return x.GcpConfig
		}
	}
	return nil
}

type isPubSubSubscription_ProviderConfig interface {
	isPubSubSubscription_ProviderConfig()
}

type PubSubSubscription_GcpConfig struct {
	GcpConfig *PubSubSubscription_GCPConfig `protobuf:"bytes,10,opt,name=gcp_config,json=gcpConfig,proto3,oneof"` // Null: no provider-specific configuration.
}

func (*PubSubSubscription_GcpConfig) isPubSubSubscription_ProviderConfig() {}

type BucketCluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this cluster.
	Rid     string    `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	Buckets []*Bucket `protobuf:"bytes,2,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// Types that are valid to be assigned to Provider:
	//
	//	*BucketCluster_S3_
	//	*BucketCluster_Gcs
	Provider      isBucketCluster_Provider `protobuf_oneof:"provider"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketCluster) Reset() {
	*x = BucketCluster{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketCluster) ProtoMessage() {}

func (x *BucketCluster) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketCluster.ProtoReflect.Descriptor instead.
func (*BucketCluster) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{17}
}

func (x *BucketCluster) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *BucketCluster) GetBuckets() []*Bucket {
	if x != nil {
		return x.Buckets
	}
	return nil
}

func (x *BucketCluster) GetProvider() isBucketCluster_Provider {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *BucketCluster) GetS3() *BucketCluster_S3 {
	if x != nil {
		if x, ok := x.Provider.(*BucketCluster_S3_); ok {
			return x.S3
		}
	}
	return nil
}

func (x *BucketCluster) GetGcs() *BucketCluster_GCS {
	if x != nil {
		if x, ok := x.Provider.(*BucketCluster_Gcs); ok {
			return x.Gcs
		}
	}
	return nil
}

type isBucketCluster_Provider interface {
	isBucketCluster_Provider()
}

type BucketCluster_S3_ struct {
	S3 *BucketCluster_S3 `protobuf:"bytes,10,opt,name=s3,proto3,oneof"`
}

type BucketCluster_Gcs struct {
	Gcs *BucketCluster_GCS `protobuf:"bytes,11,opt,name=gcs,proto3,oneof"`
}

func (*BucketCluster_S3_) isBucketCluster_Provider() {}

func (*BucketCluster_Gcs) isBucketCluster_Provider() {}

type Bucket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique resource id for this bucket.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The encore name of the bucket.
	EncoreName string `protobuf:"bytes,2,opt,name=encore_name,json=encoreName,proto3" json:"encore_name,omitempty"`
	// The cloud name of the bucket.
	CloudName string `protobuf:"bytes,3,opt,name=cloud_name,json=cloudName,proto3" json:"cloud_name,omitempty"`
	// Optional key prefix to prepend to all bucket keys.
	//
	// Note: make sure it ends with a slash ("/") if you want
	// to group objects within a certain folder.
	KeyPrefix *string `protobuf:"bytes,4,opt,name=key_prefix,json=keyPrefix,proto3,oneof" json:"key_prefix,omitempty"`
	// Public base URL for accessing objects in this bucket.
	// Must be set for public buckets.
	PublicBaseUrl *string `protobuf:"bytes,5,opt,name=public_base_url,json=publicBaseUrl,proto3,oneof" json:"public_base_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Bucket) Reset() {
	*x = Bucket{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Bucket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bucket) ProtoMessage() {}

func (x *Bucket) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bucket.ProtoReflect.Descriptor instead.
func (*Bucket) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{18}
}

func (x *Bucket) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *Bucket) GetEncoreName() string {
	if x != nil {
		return x.EncoreName
	}
	return ""
}

func (x *Bucket) GetCloudName() string {
	if x != nil {
		return x.CloudName
	}
	return ""
}

func (x *Bucket) GetKeyPrefix() string {
	if x != nil && x.KeyPrefix != nil {
		return *x.KeyPrefix
	}
	return ""
}

func (x *Bucket) GetPublicBaseUrl() string {
	if x != nil && x.PublicBaseUrl != nil {
		return *x.PublicBaseUrl
	}
	return ""
}

type Gateway struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique id for this resource.
	Rid string `protobuf:"bytes,1,opt,name=rid,proto3" json:"rid,omitempty"`
	// The encore name of the gateway.
	EncoreName string `protobuf:"bytes,2,opt,name=encore_name,json=encoreName,proto3" json:"encore_name,omitempty"`
	// The base url for reaching this gateway, for returning to the application
	// via e.g. the metadata APIs.
	BaseUrl string `protobuf:"bytes,3,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	// The hostnames this gateway accepts requests for.
	Hostnames []string `protobuf:"bytes,4,rep,name=hostnames,proto3" json:"hostnames,omitempty"`
	// CORS is the CORS configuration for this gateway.
	Cors          *Gateway_CORS `protobuf:"bytes,5,opt,name=cors,proto3" json:"cors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Gateway) Reset() {
	*x = Gateway{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Gateway) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Gateway) ProtoMessage() {}

func (x *Gateway) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Gateway.ProtoReflect.Descriptor instead.
func (*Gateway) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{19}
}

func (x *Gateway) GetRid() string {
	if x != nil {
		return x.Rid
	}
	return ""
}

func (x *Gateway) GetEncoreName() string {
	if x != nil {
		return x.EncoreName
	}
	return ""
}

func (x *Gateway) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *Gateway) GetHostnames() []string {
	if x != nil {
		return x.Hostnames
	}
	return nil
}

func (x *Gateway) GetCors() *Gateway_CORS {
	if x != nil {
		return x.Cors
	}
	return nil
}

type Infrastructure_Credentials struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientCerts   []*ClientCert          `protobuf:"bytes,1,rep,name=client_certs,json=clientCerts,proto3" json:"client_certs,omitempty"`
	SqlRoles      []*SQLRole             `protobuf:"bytes,2,rep,name=sql_roles,json=sqlRoles,proto3" json:"sql_roles,omitempty"`
	RedisRoles    []*RedisRole           `protobuf:"bytes,3,rep,name=redis_roles,json=redisRoles,proto3" json:"redis_roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Infrastructure_Credentials) Reset() {
	*x = Infrastructure_Credentials{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Infrastructure_Credentials) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Infrastructure_Credentials) ProtoMessage() {}

func (x *Infrastructure_Credentials) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Infrastructure_Credentials.ProtoReflect.Descriptor instead.
func (*Infrastructure_Credentials) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Infrastructure_Credentials) GetClientCerts() []*ClientCert {
	if x != nil {
		return x.ClientCerts
	}
	return nil
}

func (x *Infrastructure_Credentials) GetSqlRoles() []*SQLRole {
	if x != nil {
		return x.SqlRoles
	}
	return nil
}

func (x *Infrastructure_Credentials) GetRedisRoles() []*RedisRole {
	if x != nil {
		return x.RedisRoles
	}
	return nil
}

type Infrastructure_Resources struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Gateways       []*Gateway             `protobuf:"bytes,1,rep,name=gateways,proto3" json:"gateways,omitempty"`
	SqlClusters    []*SQLCluster          `protobuf:"bytes,2,rep,name=sql_clusters,json=sqlClusters,proto3" json:"sql_clusters,omitempty"`
	PubsubClusters []*PubSubCluster       `protobuf:"bytes,3,rep,name=pubsub_clusters,json=pubsubClusters,proto3" json:"pubsub_clusters,omitempty"`
	RedisClusters  []*RedisCluster        `protobuf:"bytes,4,rep,name=redis_clusters,json=redisClusters,proto3" json:"redis_clusters,omitempty"`
	AppSecrets     []*AppSecret           `protobuf:"bytes,5,rep,name=app_secrets,json=appSecrets,proto3" json:"app_secrets,omitempty"`
	BucketClusters []*BucketCluster       `protobuf:"bytes,6,rep,name=bucket_clusters,json=bucketClusters,proto3" json:"bucket_clusters,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Infrastructure_Resources) Reset() {
	*x = Infrastructure_Resources{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Infrastructure_Resources) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Infrastructure_Resources) ProtoMessage() {}

func (x *Infrastructure_Resources) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Infrastructure_Resources.ProtoReflect.Descriptor instead.
func (*Infrastructure_Resources) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Infrastructure_Resources) GetGateways() []*Gateway {
	if x != nil {
		return x.Gateways
	}
	return nil
}

func (x *Infrastructure_Resources) GetSqlClusters() []*SQLCluster {
	if x != nil {
		return x.SqlClusters
	}
	return nil
}

func (x *Infrastructure_Resources) GetPubsubClusters() []*PubSubCluster {
	if x != nil {
		return x.PubsubClusters
	}
	return nil
}

func (x *Infrastructure_Resources) GetRedisClusters() []*RedisCluster {
	if x != nil {
		return x.RedisClusters
	}
	return nil
}

func (x *Infrastructure_Resources) GetAppSecrets() []*AppSecret {
	if x != nil {
		return x.AppSecrets
	}
	return nil
}

func (x *Infrastructure_Resources) GetBucketClusters() []*BucketCluster {
	if x != nil {
		return x.BucketClusters
	}
	return nil
}

type RedisRole_AuthACL struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      *SecretData            `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedisRole_AuthACL) Reset() {
	*x = RedisRole_AuthACL{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedisRole_AuthACL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedisRole_AuthACL) ProtoMessage() {}

func (x *RedisRole_AuthACL) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedisRole_AuthACL.ProtoReflect.Descriptor instead.
func (*RedisRole_AuthACL) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{11, 0}
}

func (x *RedisRole_AuthACL) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *RedisRole_AuthACL) GetPassword() *SecretData {
	if x != nil {
		return x.Password
	}
	return nil
}

type PubSubCluster_EncoreCloud struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubCluster_EncoreCloud) Reset() {
	*x = PubSubCluster_EncoreCloud{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubCluster_EncoreCloud) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubCluster_EncoreCloud) ProtoMessage() {}

func (x *PubSubCluster_EncoreCloud) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubCluster_EncoreCloud.ProtoReflect.Descriptor instead.
func (*PubSubCluster_EncoreCloud) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{14, 0}
}

type PubSubCluster_AWSSqsSns struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubCluster_AWSSqsSns) Reset() {
	*x = PubSubCluster_AWSSqsSns{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubCluster_AWSSqsSns) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubCluster_AWSSqsSns) ProtoMessage() {}

func (x *PubSubCluster_AWSSqsSns) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubCluster_AWSSqsSns.ProtoReflect.Descriptor instead.
func (*PubSubCluster_AWSSqsSns) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{14, 1}
}

type PubSubCluster_GCPPubSub struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubCluster_GCPPubSub) Reset() {
	*x = PubSubCluster_GCPPubSub{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubCluster_GCPPubSub) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubCluster_GCPPubSub) ProtoMessage() {}

func (x *PubSubCluster_GCPPubSub) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubCluster_GCPPubSub.ProtoReflect.Descriptor instead.
func (*PubSubCluster_GCPPubSub) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{14, 2}
}

type PubSubCluster_NSQ struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hosts to connect to NSQ. Must be non-empty.
	Hosts         []string `protobuf:"bytes,1,rep,name=hosts,proto3" json:"hosts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubCluster_NSQ) Reset() {
	*x = PubSubCluster_NSQ{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubCluster_NSQ) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubCluster_NSQ) ProtoMessage() {}

func (x *PubSubCluster_NSQ) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubCluster_NSQ.ProtoReflect.Descriptor instead.
func (*PubSubCluster_NSQ) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{14, 3}
}

func (x *PubSubCluster_NSQ) GetHosts() []string {
	if x != nil {
		return x.Hosts
	}
	return nil
}

type PubSubCluster_AzureServiceBus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Namespace     string                 `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubCluster_AzureServiceBus) Reset() {
	*x = PubSubCluster_AzureServiceBus{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubCluster_AzureServiceBus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubCluster_AzureServiceBus) ProtoMessage() {}

func (x *PubSubCluster_AzureServiceBus) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubCluster_AzureServiceBus.ProtoReflect.Descriptor instead.
func (*PubSubCluster_AzureServiceBus) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{14, 4}
}

func (x *PubSubCluster_AzureServiceBus) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

type PubSubTopic_GCPConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The GCP project id where the topic exists.
	ProjectId     string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PubSubTopic_GCPConfig) Reset() {
	*x = PubSubTopic_GCPConfig{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubTopic_GCPConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubTopic_GCPConfig) ProtoMessage() {}

func (x *PubSubTopic_GCPConfig) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubTopic_GCPConfig.ProtoReflect.Descriptor instead.
func (*PubSubTopic_GCPConfig) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{15, 0}
}

func (x *PubSubTopic_GCPConfig) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

type PubSubSubscription_GCPConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The GCP project id where the subscription exists.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// The service account used to authenticate messages being delivered over push.
	// If unset, pushes are rejected.
	PushServiceAccount *string `protobuf:"bytes,2,opt,name=push_service_account,json=pushServiceAccount,proto3,oneof" json:"push_service_account,omitempty"`
	// The audience to use when validating JWTs delivered over push.
	// If set, the JWT audience claim must match. If unset, any JWT audience is allowed.
	PushJwtAudience *string `protobuf:"bytes,3,opt,name=push_jwt_audience,json=pushJwtAudience,proto3,oneof" json:"push_jwt_audience,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PubSubSubscription_GCPConfig) Reset() {
	*x = PubSubSubscription_GCPConfig{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PubSubSubscription_GCPConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PubSubSubscription_GCPConfig) ProtoMessage() {}

func (x *PubSubSubscription_GCPConfig) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PubSubSubscription_GCPConfig.ProtoReflect.Descriptor instead.
func (*PubSubSubscription_GCPConfig) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{16, 0}
}

func (x *PubSubSubscription_GCPConfig) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *PubSubSubscription_GCPConfig) GetPushServiceAccount() string {
	if x != nil && x.PushServiceAccount != nil {
		return *x.PushServiceAccount
	}
	return ""
}

func (x *PubSubSubscription_GCPConfig) GetPushJwtAudience() string {
	if x != nil && x.PushJwtAudience != nil {
		return *x.PushJwtAudience
	}
	return ""
}

type BucketCluster_S3 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Region to connect to.
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// Endpoint override, if any. Must be specified if using a non-standard AWS region.
	Endpoint *string `protobuf:"bytes,2,opt,name=endpoint,proto3,oneof" json:"endpoint,omitempty"`
	// Set these to use explicit credentials for this bucket,
	// as opposed to resolving using AWS's default credential chain.
	AccessKeyId     *string     `protobuf:"bytes,3,opt,name=access_key_id,json=accessKeyId,proto3,oneof" json:"access_key_id,omitempty"`
	SecretAccessKey *SecretData `protobuf:"bytes,4,opt,name=secret_access_key,json=secretAccessKey,proto3,oneof" json:"secret_access_key,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BucketCluster_S3) Reset() {
	*x = BucketCluster_S3{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketCluster_S3) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketCluster_S3) ProtoMessage() {}

func (x *BucketCluster_S3) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketCluster_S3.ProtoReflect.Descriptor instead.
func (*BucketCluster_S3) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{17, 0}
}

func (x *BucketCluster_S3) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *BucketCluster_S3) GetEndpoint() string {
	if x != nil && x.Endpoint != nil {
		return *x.Endpoint
	}
	return ""
}

func (x *BucketCluster_S3) GetAccessKeyId() string {
	if x != nil && x.AccessKeyId != nil {
		return *x.AccessKeyId
	}
	return ""
}

func (x *BucketCluster_S3) GetSecretAccessKey() *SecretData {
	if x != nil {
		return x.SecretAccessKey
	}
	return nil
}

type BucketCluster_GCS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Endpoint override, if any. Defaults to https://storage.googleapis.com if unset.
	Endpoint *string `protobuf:"bytes,1,opt,name=endpoint,proto3,oneof" json:"endpoint,omitempty"`
	// Whether to connect anonymously or if a service account should be resolved.
	Anonymous bool `protobuf:"varint,2,opt,name=anonymous,proto3" json:"anonymous,omitempty"`
	// Additional options for signed URLs when running in local dev mode.
	// Only use with anonymous mode.
	LocalSign     *BucketCluster_GCS_LocalSignOptions `protobuf:"bytes,3,opt,name=local_sign,json=localSign,proto3,oneof" json:"local_sign,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketCluster_GCS) Reset() {
	*x = BucketCluster_GCS{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketCluster_GCS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketCluster_GCS) ProtoMessage() {}

func (x *BucketCluster_GCS) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketCluster_GCS.ProtoReflect.Descriptor instead.
func (*BucketCluster_GCS) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{17, 1}
}

func (x *BucketCluster_GCS) GetEndpoint() string {
	if x != nil && x.Endpoint != nil {
		return *x.Endpoint
	}
	return ""
}

func (x *BucketCluster_GCS) GetAnonymous() bool {
	if x != nil {
		return x.Anonymous
	}
	return false
}

func (x *BucketCluster_GCS) GetLocalSign() *BucketCluster_GCS_LocalSignOptions {
	if x != nil {
		return x.LocalSign
	}
	return nil
}

type BucketCluster_GCS_LocalSignOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Base prefix to use for presigned URLs.
	BaseUrl string `protobuf:"bytes,1,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	// Use these credentials to sign local URLs. Only pass dummy credentials
	// here, no actual secrets.
	AccessId      string `protobuf:"bytes,2,opt,name=access_id,json=accessId,proto3" json:"access_id,omitempty"`
	PrivateKey    string `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketCluster_GCS_LocalSignOptions) Reset() {
	*x = BucketCluster_GCS_LocalSignOptions{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketCluster_GCS_LocalSignOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketCluster_GCS_LocalSignOptions) ProtoMessage() {}

func (x *BucketCluster_GCS_LocalSignOptions) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketCluster_GCS_LocalSignOptions.ProtoReflect.Descriptor instead.
func (*BucketCluster_GCS_LocalSignOptions) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{17, 1, 0}
}

func (x *BucketCluster_GCS_LocalSignOptions) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *BucketCluster_GCS_LocalSignOptions) GetAccessId() string {
	if x != nil {
		return x.AccessId
	}
	return ""
}

func (x *BucketCluster_GCS_LocalSignOptions) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

// CORS describes the CORS configuration for a gateway.
type Gateway_CORS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Debug bool                   `protobuf:"varint,1,opt,name=debug,proto3" json:"debug,omitempty"`
	// If true, causes Encore to respond to OPTIONS requests
	// without setting Access-Control-Allow-Credentials: true.
	DisableCredentials bool `protobuf:"varint,2,opt,name=disable_credentials,json=disableCredentials,proto3" json:"disable_credentials,omitempty"`
	// Specifies the allowed origins for requests that include credentials.
	// If a request is made from an Origin in this list
	// Encore responds with Access-Control-Allow-Origin: <Origin>.
	//
	// If disable_credentials is true this field is not used.
	//
	// Types that are valid to be assigned to AllowedOriginsWithCredentials:
	//
	//	*Gateway_CORS_AllowedOrigins
	//	*Gateway_CORS_UnsafeAllowAllOriginsWithCredentials
	AllowedOriginsWithCredentials isGateway_CORS_AllowedOriginsWithCredentials `protobuf_oneof:"allowed_origins_with_credentials"`
	// Specifies the allowed origins for requests
	// that don't include credentials.
	//
	// The URLs in this list may include wildcards (e.g. "https://*.example.com"
	// or "https://*-myapp.example.com").
	AllowedOriginsWithoutCredentials *Gateway_CORSAllowedOrigins `protobuf:"bytes,5,opt,name=allowed_origins_without_credentials,json=allowedOriginsWithoutCredentials,proto3" json:"allowed_origins_without_credentials,omitempty"`
	// Specifies extra headers to allow, beyond
	// the default set always recognized by Encore.
	// As a special case, if the list contains "*" all headers are allowed.
	ExtraAllowedHeaders []string `protobuf:"bytes,6,rep,name=extra_allowed_headers,json=extraAllowedHeaders,proto3" json:"extra_allowed_headers,omitempty"`
	// Specifies extra headers to expose, beyond
	// the default set always recognized by Encore.
	// As a special case, if the list contains "*" all headers are allowed.
	ExtraExposedHeaders []string `protobuf:"bytes,7,rep,name=extra_exposed_headers,json=extraExposedHeaders,proto3" json:"extra_exposed_headers,omitempty"`
	// If true, allows requests to Encore apps running
	// on private networks from websites.
	// See: https://wicg.github.io/private-network-access/
	AllowPrivateNetworkAccess bool `protobuf:"varint,8,opt,name=allow_private_network_access,json=allowPrivateNetworkAccess,proto3" json:"allow_private_network_access,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *Gateway_CORS) Reset() {
	*x = Gateway_CORS{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Gateway_CORS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Gateway_CORS) ProtoMessage() {}

func (x *Gateway_CORS) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Gateway_CORS.ProtoReflect.Descriptor instead.
func (*Gateway_CORS) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{19, 0}
}

func (x *Gateway_CORS) GetDebug() bool {
	if x != nil {
		return x.Debug
	}
	return false
}

func (x *Gateway_CORS) GetDisableCredentials() bool {
	if x != nil {
		return x.DisableCredentials
	}
	return false
}

func (x *Gateway_CORS) GetAllowedOriginsWithCredentials() isGateway_CORS_AllowedOriginsWithCredentials {
	if x != nil {
		return x.AllowedOriginsWithCredentials
	}
	return nil
}

func (x *Gateway_CORS) GetAllowedOrigins() *Gateway_CORSAllowedOrigins {
	if x != nil {
		if x, ok := x.AllowedOriginsWithCredentials.(*Gateway_CORS_AllowedOrigins); ok {
			return x.AllowedOrigins
		}
	}
	return nil
}

func (x *Gateway_CORS) GetUnsafeAllowAllOriginsWithCredentials() bool {
	if x != nil {
		if x, ok := x.AllowedOriginsWithCredentials.(*Gateway_CORS_UnsafeAllowAllOriginsWithCredentials); ok {
			return x.UnsafeAllowAllOriginsWithCredentials
		}
	}
	return false
}

func (x *Gateway_CORS) GetAllowedOriginsWithoutCredentials() *Gateway_CORSAllowedOrigins {
	if x != nil {
		return x.AllowedOriginsWithoutCredentials
	}
	return nil
}

func (x *Gateway_CORS) GetExtraAllowedHeaders() []string {
	if x != nil {
		return x.ExtraAllowedHeaders
	}
	return nil
}

func (x *Gateway_CORS) GetExtraExposedHeaders() []string {
	if x != nil {
		return x.ExtraExposedHeaders
	}
	return nil
}

func (x *Gateway_CORS) GetAllowPrivateNetworkAccess() bool {
	if x != nil {
		return x.AllowPrivateNetworkAccess
	}
	return false
}

type isGateway_CORS_AllowedOriginsWithCredentials interface {
	isGateway_CORS_AllowedOriginsWithCredentials()
}

type Gateway_CORS_AllowedOrigins struct {
	AllowedOrigins *Gateway_CORSAllowedOrigins `protobuf:"bytes,3,opt,name=allowed_origins,json=allowedOrigins,proto3,oneof"`
}

type Gateway_CORS_UnsafeAllowAllOriginsWithCredentials struct {
	UnsafeAllowAllOriginsWithCredentials bool `protobuf:"varint,4,opt,name=unsafe_allow_all_origins_with_credentials,json=unsafeAllowAllOriginsWithCredentials,proto3,oneof"`
}

func (*Gateway_CORS_AllowedOrigins) isGateway_CORS_AllowedOriginsWithCredentials() {}

func (*Gateway_CORS_UnsafeAllowAllOriginsWithCredentials) isGateway_CORS_AllowedOriginsWithCredentials() {
}

type Gateway_CORSAllowedOrigins struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of allowed origins.
	// The URLs in this list may include wildcards (e.g. "https://*.example.com"
	// or "https://*-myapp.example.com").
	//
	// The string "*" allows all origins, except for requests with credentials;
	// use CORS.unsafe_allow_unsafe_all_origins_with_credentials for that.
	AllowedOrigins []string `protobuf:"bytes,1,rep,name=allowed_origins,json=allowedOrigins,proto3" json:"allowed_origins,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Gateway_CORSAllowedOrigins) Reset() {
	*x = Gateway_CORSAllowedOrigins{}
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Gateway_CORSAllowedOrigins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Gateway_CORSAllowedOrigins) ProtoMessage() {}

func (x *Gateway_CORSAllowedOrigins) ProtoReflect() protoreflect.Message {
	mi := &file_encore_runtime_v1_infra_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Gateway_CORSAllowedOrigins.ProtoReflect.Descriptor instead.
func (*Gateway_CORSAllowedOrigins) Descriptor() ([]byte, []int) {
	return file_encore_runtime_v1_infra_proto_rawDescGZIP(), []int{19, 1}
}

func (x *Gateway_CORSAllowedOrigins) GetAllowedOrigins() []string {
	if x != nil {
		return x.AllowedOrigins
	}
	return nil
}

var File_encore_runtime_v1_infra_proto protoreflect.FileDescriptor

const file_encore_runtime_v1_infra_proto_rawDesc = "" +
	"\n" +
	"\x1dencore/runtime/v1/infra.proto\x12\x11encore.runtime.v1\x1a\"encore/runtime/v1/secretdata.proto\"\x9b\x06\n" +
	"\x0eInfrastructure\x12I\n" +
	"\tresources\x18\x01 \x01(\v2+.encore.runtime.v1.Infrastructure.ResourcesR\tresources\x12O\n" +
	"\vcredentials\x18\x02 \x01(\v2-.encore.runtime.v1.Infrastructure.CredentialsR\vcredentials\x1a\xc7\x01\n" +
	"\vCredentials\x12@\n" +
	"\fclient_certs\x18\x01 \x03(\v2\x1d.encore.runtime.v1.ClientCertR\vclientCerts\x127\n" +
	"\tsql_roles\x18\x02 \x03(\v2\x1a.encore.runtime.v1.SQLRoleR\bsqlRoles\x12=\n" +
	"\vredis_roles\x18\x03 \x03(\v2\x1c.encore.runtime.v1.RedisRoleR\n" +
	"redisRoles\x1a\xa2\x03\n" +
	"\tResources\x126\n" +
	"\bgateways\x18\x01 \x03(\v2\x1a.encore.runtime.v1.GatewayR\bgateways\x12@\n" +
	"\fsql_clusters\x18\x02 \x03(\v2\x1d.encore.runtime.v1.SQLClusterR\vsqlClusters\x12I\n" +
	"\x0fpubsub_clusters\x18\x03 \x03(\v2 .encore.runtime.v1.PubSubClusterR\x0epubsubClusters\x12F\n" +
	"\x0eredis_clusters\x18\x04 \x03(\v2\x1f.encore.runtime.v1.RedisClusterR\rredisClusters\x12=\n" +
	"\vapp_secrets\x18\x05 \x03(\v2\x1c.encore.runtime.v1.AppSecretR\n" +
	"appSecrets\x12I\n" +
	"\x0fbucket_clusters\x18\x06 \x03(\v2 .encore.runtime.v1.BucketClusterR\x0ebucketClusters\"\x94\x01\n" +
	"\n" +
	"SQLCluster\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x126\n" +
	"\aservers\x18\x02 \x03(\v2\x1c.encore.runtime.v1.SQLServerR\aservers\x12<\n" +
	"\tdatabases\x18\x03 \x03(\v2\x1e.encore.runtime.v1.SQLDatabaseR\tdatabases\"\xc8\x01\n" +
	"\tTLSConfig\x12)\n" +
	"\x0eserver_ca_cert\x18\x01 \x01(\tH\x00R\fserverCaCert\x88\x01\x01\x12I\n" +
	"!disable_tls_hostname_verification\x18\x02 \x01(\bR\x1edisableTlsHostnameVerification\x122\n" +
	"\x15disable_ca_validation\x18\x03 \x01(\bR\x13disableCaValidationB\x11\n" +
	"\x0f_server_ca_cert\"\xb5\x01\n" +
	"\tSQLServer\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x12\n" +
	"\x04host\x18\x02 \x01(\tR\x04host\x121\n" +
	"\x04kind\x18\x03 \x01(\x0e2\x1d.encore.runtime.v1.ServerKindR\x04kind\x12@\n" +
	"\n" +
	"tls_config\x18\x04 \x01(\v2\x1c.encore.runtime.v1.TLSConfigH\x00R\ttlsConfig\x88\x01\x01B\r\n" +
	"\v_tls_config\"c\n" +
	"\n" +
	"ClientCert\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x12\n" +
	"\x04cert\x18\x02 \x01(\tR\x04cert\x12/\n" +
	"\x03key\x18\x03 \x01(\v2\x1d.encore.runtime.v1.SecretDataR\x03key\"\xb3\x01\n" +
	"\aSQLRole\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1a\n" +
	"\busername\x18\x02 \x01(\tR\busername\x129\n" +
	"\bpassword\x18\x03 \x01(\v2\x1d.encore.runtime.v1.SecretDataR\bpassword\x12+\n" +
	"\x0fclient_cert_rid\x18\x04 \x01(\tH\x00R\rclientCertRid\x88\x01\x01B\x12\n" +
	"\x10_client_cert_rid\"\xa4\x01\n" +
	"\vSQLDatabase\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1f\n" +
	"\vencore_name\x18\x02 \x01(\tR\n" +
	"encoreName\x12\x1d\n" +
	"\n" +
	"cloud_name\x18\x03 \x01(\tR\tcloudName\x12C\n" +
	"\n" +
	"conn_pools\x18\x04 \x03(\v2$.encore.runtime.v1.SQLConnectionPoolR\tconnPools\"\xa1\x01\n" +
	"\x11SQLConnectionPool\x12\x1f\n" +
	"\vis_readonly\x18\x01 \x01(\bR\n" +
	"isReadonly\x12\x19\n" +
	"\brole_rid\x18\x02 \x01(\tR\aroleRid\x12'\n" +
	"\x0fmin_connections\x18\x03 \x01(\x05R\x0eminConnections\x12'\n" +
	"\x0fmax_connections\x18\x04 \x01(\x05R\x0emaxConnections\"\x9a\x01\n" +
	"\fRedisCluster\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x128\n" +
	"\aservers\x18\x02 \x03(\v2\x1e.encore.runtime.v1.RedisServerR\aservers\x12>\n" +
	"\tdatabases\x18\x03 \x03(\v2 .encore.runtime.v1.RedisDatabaseR\tdatabases\"\xb7\x01\n" +
	"\vRedisServer\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x12\n" +
	"\x04host\x18\x02 \x01(\tR\x04host\x121\n" +
	"\x04kind\x18\x03 \x01(\x0e2\x1d.encore.runtime.v1.ServerKindR\x04kind\x12@\n" +
	"\n" +
	"tls_config\x18\x04 \x01(\v2\x1c.encore.runtime.v1.TLSConfigH\x00R\ttlsConfig\x88\x01\x01B\r\n" +
	"\v_tls_config\"\xa3\x01\n" +
	"\x13RedisConnectionPool\x12\x1f\n" +
	"\vis_readonly\x18\x01 \x01(\bR\n" +
	"isReadonly\x12\x19\n" +
	"\brole_rid\x18\x02 \x01(\tR\aroleRid\x12'\n" +
	"\x0fmin_connections\x18\x03 \x01(\x05R\x0eminConnections\x12'\n" +
	"\x0fmax_connections\x18\x04 \x01(\x05R\x0emaxConnections\"\xc4\x02\n" +
	"\tRedisRole\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12+\n" +
	"\x0fclient_cert_rid\x18\x02 \x01(\tH\x01R\rclientCertRid\x88\x01\x01\x128\n" +
	"\x03acl\x18\n" +
	" \x01(\v2$.encore.runtime.v1.RedisRole.AuthACLH\x00R\x03acl\x12@\n" +
	"\vauth_string\x18\v \x01(\v2\x1d.encore.runtime.v1.SecretDataH\x00R\n" +
	"authString\x1a`\n" +
	"\aAuthACL\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x129\n" +
	"\bpassword\x18\x02 \x01(\v2\x1d.encore.runtime.v1.SecretDataR\bpasswordB\x06\n" +
	"\x04authB\x12\n" +
	"\x10_client_cert_rid\"\xdf\x01\n" +
	"\rRedisDatabase\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1f\n" +
	"\vencore_name\x18\x02 \x01(\tR\n" +
	"encoreName\x12!\n" +
	"\fdatabase_idx\x18\x03 \x01(\x05R\vdatabaseIdx\x12\"\n" +
	"\n" +
	"key_prefix\x18\x04 \x01(\tH\x00R\tkeyPrefix\x88\x01\x01\x12E\n" +
	"\n" +
	"conn_pools\x18\x05 \x03(\v2&.encore.runtime.v1.RedisConnectionPoolR\tconnPoolsB\r\n" +
	"\v_key_prefix\"q\n" +
	"\tAppSecret\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1f\n" +
	"\vencore_name\x18\x02 \x01(\tR\n" +
	"encoreName\x121\n" +
	"\x04data\x18\x03 \x01(\v2\x1d.encore.runtime.v1.SecretDataR\x04data\"\xf5\x04\n" +
	"\rPubSubCluster\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x126\n" +
	"\x06topics\x18\x02 \x03(\v2\x1e.encore.runtime.v1.PubSubTopicR\x06topics\x12K\n" +
	"\rsubscriptions\x18\x03 \x03(\v2%.encore.runtime.v1.PubSubSubscriptionR\rsubscriptions\x12F\n" +
	"\x06encore\x18\x05 \x01(\v2,.encore.runtime.v1.PubSubCluster.EncoreCloudH\x00R\x06encore\x12>\n" +
	"\x03aws\x18\x06 \x01(\v2*.encore.runtime.v1.PubSubCluster.AWSSqsSnsH\x00R\x03aws\x12>\n" +
	"\x03gcp\x18\a \x01(\v2*.encore.runtime.v1.PubSubCluster.GCPPubSubH\x00R\x03gcp\x12H\n" +
	"\x05azure\x18\b \x01(\v20.encore.runtime.v1.PubSubCluster.AzureServiceBusH\x00R\x05azure\x128\n" +
	"\x03nsq\x18\t \x01(\v2$.encore.runtime.v1.PubSubCluster.NSQH\x00R\x03nsq\x1a\r\n" +
	"\vEncoreCloud\x1a\v\n" +
	"\tAWSSqsSns\x1a\v\n" +
	"\tGCPPubSub\x1a\x1b\n" +
	"\x03NSQ\x12\x14\n" +
	"\x05hosts\x18\x01 \x03(\tR\x05hosts\x1a/\n" +
	"\x0fAzureServiceBus\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespaceB\n" +
	"\n" +
	"\bprovider\"\x8b\x04\n" +
	"\vPubSubTopic\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1f\n" +
	"\vencore_name\x18\x02 \x01(\tR\n" +
	"encoreName\x12\x1d\n" +
	"\n" +
	"cloud_name\x18\x03 \x01(\tR\tcloudName\x12_\n" +
	"\x12delivery_guarantee\x18\x04 \x01(\x0e20.encore.runtime.v1.PubSubTopic.DeliveryGuaranteeR\x11deliveryGuarantee\x12(\n" +
	"\rordering_attr\x18\x05 \x01(\tH\x01R\forderingAttr\x88\x01\x01\x12I\n" +
	"\n" +
	"gcp_config\x18\n" +
	" \x01(\v2(.encore.runtime.v1.PubSubTopic.GCPConfigH\x00R\tgcpConfig\x1a*\n" +
	"\tGCPConfig\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\"\x82\x01\n" +
	"\x11DeliveryGuarantee\x12\"\n" +
	"\x1eDELIVERY_GUARANTEE_UNSPECIFIED\x10\x00\x12$\n" +
	" DELIVERY_GUARANTEE_AT_LEAST_ONCE\x10\x01\x12#\n" +
	"\x1fDELIVERY_GUARANTEE_EXACTLY_ONCE\x10\x02B\x11\n" +
	"\x0fprovider_configB\x10\n" +
	"\x0e_ordering_attr\"\xb4\x04\n" +
	"\x12PubSubSubscription\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12*\n" +
	"\x11topic_encore_name\x18\x02 \x01(\tR\x0ftopicEncoreName\x128\n" +
	"\x18subscription_encore_name\x18\x03 \x01(\tR\x16subscriptionEncoreName\x12(\n" +
	"\x10topic_cloud_name\x18\x04 \x01(\tR\x0etopicCloudName\x126\n" +
	"\x17subscription_cloud_name\x18\x05 \x01(\tR\x15subscriptionCloudName\x12\x1b\n" +
	"\tpush_only\x18\x06 \x01(\bR\bpushOnly\x12P\n" +
	"\n" +
	"gcp_config\x18\n" +
	" \x01(\v2/.encore.runtime.v1.PubSubSubscription.GCPConfigH\x00R\tgcpConfig\x1a\xc1\x01\n" +
	"\tGCPConfig\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x125\n" +
	"\x14push_service_account\x18\x02 \x01(\tH\x00R\x12pushServiceAccount\x88\x01\x01\x12/\n" +
	"\x11push_jwt_audience\x18\x03 \x01(\tH\x01R\x0fpushJwtAudience\x88\x01\x01B\x17\n" +
	"\x15_push_service_accountB\x14\n" +
	"\x12_push_jwt_audienceB\x11\n" +
	"\x0fprovider_config\"\xec\x05\n" +
	"\rBucketCluster\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x123\n" +
	"\abuckets\x18\x02 \x03(\v2\x19.encore.runtime.v1.BucketR\abuckets\x125\n" +
	"\x02s3\x18\n" +
	" \x01(\v2#.encore.runtime.v1.BucketCluster.S3H\x00R\x02s3\x128\n" +
	"\x03gcs\x18\v \x01(\v2$.encore.runtime.v1.BucketCluster.GCSH\x00R\x03gcs\x1a\xeb\x01\n" +
	"\x02S3\x12\x16\n" +
	"\x06region\x18\x01 \x01(\tR\x06region\x12\x1f\n" +
	"\bendpoint\x18\x02 \x01(\tH\x00R\bendpoint\x88\x01\x01\x12'\n" +
	"\raccess_key_id\x18\x03 \x01(\tH\x01R\vaccessKeyId\x88\x01\x01\x12N\n" +
	"\x11secret_access_key\x18\x04 \x01(\v2\x1d.encore.runtime.v1.SecretDataH\x02R\x0fsecretAccessKey\x88\x01\x01B\v\n" +
	"\t_endpointB\x10\n" +
	"\x0e_access_key_idB\x14\n" +
	"\x12_secret_access_key\x1a\xa8\x02\n" +
	"\x03GCS\x12\x1f\n" +
	"\bendpoint\x18\x01 \x01(\tH\x00R\bendpoint\x88\x01\x01\x12\x1c\n" +
	"\tanonymous\x18\x02 \x01(\bR\tanonymous\x12Y\n" +
	"\n" +
	"local_sign\x18\x03 \x01(\v25.encore.runtime.v1.BucketCluster.GCS.LocalSignOptionsH\x01R\tlocalSign\x88\x01\x01\x1ak\n" +
	"\x10LocalSignOptions\x12\x19\n" +
	"\bbase_url\x18\x01 \x01(\tR\abaseUrl\x12\x1b\n" +
	"\taccess_id\x18\x02 \x01(\tR\baccessId\x12\x1f\n" +
	"\vprivate_key\x18\x03 \x01(\tR\n" +
	"privateKeyB\v\n" +
	"\t_endpointB\r\n" +
	"\v_local_signB\n" +
	"\n" +
	"\bprovider\"\xce\x01\n" +
	"\x06Bucket\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1f\n" +
	"\vencore_name\x18\x02 \x01(\tR\n" +
	"encoreName\x12\x1d\n" +
	"\n" +
	"cloud_name\x18\x03 \x01(\tR\tcloudName\x12\"\n" +
	"\n" +
	"key_prefix\x18\x04 \x01(\tH\x00R\tkeyPrefix\x88\x01\x01\x12+\n" +
	"\x0fpublic_base_url\x18\x05 \x01(\tH\x01R\rpublicBaseUrl\x88\x01\x01B\r\n" +
	"\v_key_prefixB\x12\n" +
	"\x10_public_base_url\"\xb9\x06\n" +
	"\aGateway\x12\x10\n" +
	"\x03rid\x18\x01 \x01(\tR\x03rid\x12\x1f\n" +
	"\vencore_name\x18\x02 \x01(\tR\n" +
	"encoreName\x12\x19\n" +
	"\bbase_url\x18\x03 \x01(\tR\abaseUrl\x12\x1c\n" +
	"\thostnames\x18\x04 \x03(\tR\thostnames\x123\n" +
	"\x04cors\x18\x05 \x01(\v2\x1f.encore.runtime.v1.Gateway.CORSR\x04cors\x1a\xcd\x04\n" +
	"\x04CORS\x12\x14\n" +
	"\x05debug\x18\x01 \x01(\bR\x05debug\x12/\n" +
	"\x13disable_credentials\x18\x02 \x01(\bR\x12disableCredentials\x12X\n" +
	"\x0fallowed_origins\x18\x03 \x01(\v2-.encore.runtime.v1.Gateway.CORSAllowedOriginsH\x00R\x0eallowedOrigins\x12Y\n" +
	")unsafe_allow_all_origins_with_credentials\x18\x04 \x01(\bH\x00R$unsafeAllowAllOriginsWithCredentials\x12|\n" +
	"#allowed_origins_without_credentials\x18\x05 \x01(\v2-.encore.runtime.v1.Gateway.CORSAllowedOriginsR allowedOriginsWithoutCredentials\x122\n" +
	"\x15extra_allowed_headers\x18\x06 \x03(\tR\x13extraAllowedHeaders\x122\n" +
	"\x15extra_exposed_headers\x18\a \x03(\tR\x13extraExposedHeaders\x12?\n" +
	"\x1callow_private_network_access\x18\b \x01(\bR\x19allowPrivateNetworkAccessB\"\n" +
	" allowed_origins_with_credentials\x1a=\n" +
	"\x12CORSAllowedOrigins\x12'\n" +
	"\x0fallowed_origins\x18\x01 \x03(\tR\x0eallowedOrigins*}\n" +
	"\n" +
	"ServerKind\x12\x1b\n" +
	"\x17SERVER_KIND_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13SERVER_KIND_PRIMARY\x10\x01\x12\x1b\n" +
	"\x17SERVER_KIND_HOT_STANDBY\x10\x02\x12\x1c\n" +
	"\x18SERVER_KIND_READ_REPLICA\x10\x03B,Z*encr.dev/proto/encore/runtime/v1;runtimev1b\x06proto3"

var (
	file_encore_runtime_v1_infra_proto_rawDescOnce sync.Once
	file_encore_runtime_v1_infra_proto_rawDescData []byte
)

func file_encore_runtime_v1_infra_proto_rawDescGZIP() []byte {
	file_encore_runtime_v1_infra_proto_rawDescOnce.Do(func() {
		file_encore_runtime_v1_infra_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_encore_runtime_v1_infra_proto_rawDesc), len(file_encore_runtime_v1_infra_proto_rawDesc)))
	})
	return file_encore_runtime_v1_infra_proto_rawDescData
}

var file_encore_runtime_v1_infra_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_encore_runtime_v1_infra_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_encore_runtime_v1_infra_proto_goTypes = []any{
	(ServerKind)(0),                            // 0: encore.runtime.v1.ServerKind
	(PubSubTopic_DeliveryGuarantee)(0),         // 1: encore.runtime.v1.PubSubTopic.DeliveryGuarantee
	(*Infrastructure)(nil),                     // 2: encore.runtime.v1.Infrastructure
	(*SQLCluster)(nil),                         // 3: encore.runtime.v1.SQLCluster
	(*TLSConfig)(nil),                          // 4: encore.runtime.v1.TLSConfig
	(*SQLServer)(nil),                          // 5: encore.runtime.v1.SQLServer
	(*ClientCert)(nil),                         // 6: encore.runtime.v1.ClientCert
	(*SQLRole)(nil),                            // 7: encore.runtime.v1.SQLRole
	(*SQLDatabase)(nil),                        // 8: encore.runtime.v1.SQLDatabase
	(*SQLConnectionPool)(nil),                  // 9: encore.runtime.v1.SQLConnectionPool
	(*RedisCluster)(nil),                       // 10: encore.runtime.v1.RedisCluster
	(*RedisServer)(nil),                        // 11: encore.runtime.v1.RedisServer
	(*RedisConnectionPool)(nil),                // 12: encore.runtime.v1.RedisConnectionPool
	(*RedisRole)(nil),                          // 13: encore.runtime.v1.RedisRole
	(*RedisDatabase)(nil),                      // 14: encore.runtime.v1.RedisDatabase
	(*AppSecret)(nil),                          // 15: encore.runtime.v1.AppSecret
	(*PubSubCluster)(nil),                      // 16: encore.runtime.v1.PubSubCluster
	(*PubSubTopic)(nil),                        // 17: encore.runtime.v1.PubSubTopic
	(*PubSubSubscription)(nil),                 // 18: encore.runtime.v1.PubSubSubscription
	(*BucketCluster)(nil),                      // 19: encore.runtime.v1.BucketCluster
	(*Bucket)(nil),                             // 20: encore.runtime.v1.Bucket
	(*Gateway)(nil),                            // 21: encore.runtime.v1.Gateway
	(*Infrastructure_Credentials)(nil),         // 22: encore.runtime.v1.Infrastructure.Credentials
	(*Infrastructure_Resources)(nil),           // 23: encore.runtime.v1.Infrastructure.Resources
	(*RedisRole_AuthACL)(nil),                  // 24: encore.runtime.v1.RedisRole.AuthACL
	(*PubSubCluster_EncoreCloud)(nil),          // 25: encore.runtime.v1.PubSubCluster.EncoreCloud
	(*PubSubCluster_AWSSqsSns)(nil),            // 26: encore.runtime.v1.PubSubCluster.AWSSqsSns
	(*PubSubCluster_GCPPubSub)(nil),            // 27: encore.runtime.v1.PubSubCluster.GCPPubSub
	(*PubSubCluster_NSQ)(nil),                  // 28: encore.runtime.v1.PubSubCluster.NSQ
	(*PubSubCluster_AzureServiceBus)(nil),      // 29: encore.runtime.v1.PubSubCluster.AzureServiceBus
	(*PubSubTopic_GCPConfig)(nil),              // 30: encore.runtime.v1.PubSubTopic.GCPConfig
	(*PubSubSubscription_GCPConfig)(nil),       // 31: encore.runtime.v1.PubSubSubscription.GCPConfig
	(*BucketCluster_S3)(nil),                   // 32: encore.runtime.v1.BucketCluster.S3
	(*BucketCluster_GCS)(nil),                  // 33: encore.runtime.v1.BucketCluster.GCS
	(*BucketCluster_GCS_LocalSignOptions)(nil), // 34: encore.runtime.v1.BucketCluster.GCS.LocalSignOptions
	(*Gateway_CORS)(nil),                       // 35: encore.runtime.v1.Gateway.CORS
	(*Gateway_CORSAllowedOrigins)(nil),         // 36: encore.runtime.v1.Gateway.CORSAllowedOrigins
	(*SecretData)(nil),                         // 37: encore.runtime.v1.SecretData
}
var file_encore_runtime_v1_infra_proto_depIdxs = []int32{
	23, // 0: encore.runtime.v1.Infrastructure.resources:type_name -> encore.runtime.v1.Infrastructure.Resources
	22, // 1: encore.runtime.v1.Infrastructure.credentials:type_name -> encore.runtime.v1.Infrastructure.Credentials
	5,  // 2: encore.runtime.v1.SQLCluster.servers:type_name -> encore.runtime.v1.SQLServer
	8,  // 3: encore.runtime.v1.SQLCluster.databases:type_name -> encore.runtime.v1.SQLDatabase
	0,  // 4: encore.runtime.v1.SQLServer.kind:type_name -> encore.runtime.v1.ServerKind
	4,  // 5: encore.runtime.v1.SQLServer.tls_config:type_name -> encore.runtime.v1.TLSConfig
	37, // 6: encore.runtime.v1.ClientCert.key:type_name -> encore.runtime.v1.SecretData
	37, // 7: encore.runtime.v1.SQLRole.password:type_name -> encore.runtime.v1.SecretData
	9,  // 8: encore.runtime.v1.SQLDatabase.conn_pools:type_name -> encore.runtime.v1.SQLConnectionPool
	11, // 9: encore.runtime.v1.RedisCluster.servers:type_name -> encore.runtime.v1.RedisServer
	14, // 10: encore.runtime.v1.RedisCluster.databases:type_name -> encore.runtime.v1.RedisDatabase
	0,  // 11: encore.runtime.v1.RedisServer.kind:type_name -> encore.runtime.v1.ServerKind
	4,  // 12: encore.runtime.v1.RedisServer.tls_config:type_name -> encore.runtime.v1.TLSConfig
	24, // 13: encore.runtime.v1.RedisRole.acl:type_name -> encore.runtime.v1.RedisRole.AuthACL
	37, // 14: encore.runtime.v1.RedisRole.auth_string:type_name -> encore.runtime.v1.SecretData
	12, // 15: encore.runtime.v1.RedisDatabase.conn_pools:type_name -> encore.runtime.v1.RedisConnectionPool
	37, // 16: encore.runtime.v1.AppSecret.data:type_name -> encore.runtime.v1.SecretData
	17, // 17: encore.runtime.v1.PubSubCluster.topics:type_name -> encore.runtime.v1.PubSubTopic
	18, // 18: encore.runtime.v1.PubSubCluster.subscriptions:type_name -> encore.runtime.v1.PubSubSubscription
	25, // 19: encore.runtime.v1.PubSubCluster.encore:type_name -> encore.runtime.v1.PubSubCluster.EncoreCloud
	26, // 20: encore.runtime.v1.PubSubCluster.aws:type_name -> encore.runtime.v1.PubSubCluster.AWSSqsSns
	27, // 21: encore.runtime.v1.PubSubCluster.gcp:type_name -> encore.runtime.v1.PubSubCluster.GCPPubSub
	29, // 22: encore.runtime.v1.PubSubCluster.azure:type_name -> encore.runtime.v1.PubSubCluster.AzureServiceBus
	28, // 23: encore.runtime.v1.PubSubCluster.nsq:type_name -> encore.runtime.v1.PubSubCluster.NSQ
	1,  // 24: encore.runtime.v1.PubSubTopic.delivery_guarantee:type_name -> encore.runtime.v1.PubSubTopic.DeliveryGuarantee
	30, // 25: encore.runtime.v1.PubSubTopic.gcp_config:type_name -> encore.runtime.v1.PubSubTopic.GCPConfig
	31, // 26: encore.runtime.v1.PubSubSubscription.gcp_config:type_name -> encore.runtime.v1.PubSubSubscription.GCPConfig
	20, // 27: encore.runtime.v1.BucketCluster.buckets:type_name -> encore.runtime.v1.Bucket
	32, // 28: encore.runtime.v1.BucketCluster.s3:type_name -> encore.runtime.v1.BucketCluster.S3
	33, // 29: encore.runtime.v1.BucketCluster.gcs:type_name -> encore.runtime.v1.BucketCluster.GCS
	35, // 30: encore.runtime.v1.Gateway.cors:type_name -> encore.runtime.v1.Gateway.CORS
	6,  // 31: encore.runtime.v1.Infrastructure.Credentials.client_certs:type_name -> encore.runtime.v1.ClientCert
	7,  // 32: encore.runtime.v1.Infrastructure.Credentials.sql_roles:type_name -> encore.runtime.v1.SQLRole
	13, // 33: encore.runtime.v1.Infrastructure.Credentials.redis_roles:type_name -> encore.runtime.v1.RedisRole
	21, // 34: encore.runtime.v1.Infrastructure.Resources.gateways:type_name -> encore.runtime.v1.Gateway
	3,  // 35: encore.runtime.v1.Infrastructure.Resources.sql_clusters:type_name -> encore.runtime.v1.SQLCluster
	16, // 36: encore.runtime.v1.Infrastructure.Resources.pubsub_clusters:type_name -> encore.runtime.v1.PubSubCluster
	10, // 37: encore.runtime.v1.Infrastructure.Resources.redis_clusters:type_name -> encore.runtime.v1.RedisCluster
	15, // 38: encore.runtime.v1.Infrastructure.Resources.app_secrets:type_name -> encore.runtime.v1.AppSecret
	19, // 39: encore.runtime.v1.Infrastructure.Resources.bucket_clusters:type_name -> encore.runtime.v1.BucketCluster
	37, // 40: encore.runtime.v1.RedisRole.AuthACL.password:type_name -> encore.runtime.v1.SecretData
	37, // 41: encore.runtime.v1.BucketCluster.S3.secret_access_key:type_name -> encore.runtime.v1.SecretData
	34, // 42: encore.runtime.v1.BucketCluster.GCS.local_sign:type_name -> encore.runtime.v1.BucketCluster.GCS.LocalSignOptions
	36, // 43: encore.runtime.v1.Gateway.CORS.allowed_origins:type_name -> encore.runtime.v1.Gateway.CORSAllowedOrigins
	36, // 44: encore.runtime.v1.Gateway.CORS.allowed_origins_without_credentials:type_name -> encore.runtime.v1.Gateway.CORSAllowedOrigins
	45, // [45:45] is the sub-list for method output_type
	45, // [45:45] is the sub-list for method input_type
	45, // [45:45] is the sub-list for extension type_name
	45, // [45:45] is the sub-list for extension extendee
	0,  // [0:45] is the sub-list for field type_name
}

func init() { file_encore_runtime_v1_infra_proto_init() }
func file_encore_runtime_v1_infra_proto_init() {
	if File_encore_runtime_v1_infra_proto != nil {
		return
	}
	file_encore_runtime_v1_secretdata_proto_init()
	file_encore_runtime_v1_infra_proto_msgTypes[2].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[3].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[5].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[9].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[11].OneofWrappers = []any{
		(*RedisRole_Acl)(nil),
		(*RedisRole_AuthString)(nil),
	}
	file_encore_runtime_v1_infra_proto_msgTypes[12].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[14].OneofWrappers = []any{
		(*PubSubCluster_Encore)(nil),
		(*PubSubCluster_Aws)(nil),
		(*PubSubCluster_Gcp)(nil),
		(*PubSubCluster_Azure)(nil),
		(*PubSubCluster_Nsq)(nil),
	}
	file_encore_runtime_v1_infra_proto_msgTypes[15].OneofWrappers = []any{
		(*PubSubTopic_GcpConfig)(nil),
	}
	file_encore_runtime_v1_infra_proto_msgTypes[16].OneofWrappers = []any{
		(*PubSubSubscription_GcpConfig)(nil),
	}
	file_encore_runtime_v1_infra_proto_msgTypes[17].OneofWrappers = []any{
		(*BucketCluster_S3_)(nil),
		(*BucketCluster_Gcs)(nil),
	}
	file_encore_runtime_v1_infra_proto_msgTypes[18].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[29].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[30].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[31].OneofWrappers = []any{}
	file_encore_runtime_v1_infra_proto_msgTypes[33].OneofWrappers = []any{
		(*Gateway_CORS_AllowedOrigins)(nil),
		(*Gateway_CORS_UnsafeAllowAllOriginsWithCredentials)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_encore_runtime_v1_infra_proto_rawDesc), len(file_encore_runtime_v1_infra_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   35,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_encore_runtime_v1_infra_proto_goTypes,
		DependencyIndexes: file_encore_runtime_v1_infra_proto_depIdxs,
		EnumInfos:         file_encore_runtime_v1_infra_proto_enumTypes,
		MessageInfos:      file_encore_runtime_v1_infra_proto_msgTypes,
	}.Build()
	File_encore_runtime_v1_infra_proto = out.File
	file_encore_runtime_v1_infra_proto_goTypes = nil
	file_encore_runtime_v1_infra_proto_depIdxs = nil
}
